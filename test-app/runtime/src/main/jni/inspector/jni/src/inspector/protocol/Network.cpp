// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/inspector/protocol/Network.h"

#include "src/inspector/protocol/Protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/find_by_first.h"
#include "third_party/inspector_protocol/crdtp/span.h"

namespace v8_inspector {
namespace protocol {
namespace Network {

using v8_crdtp::DeserializerState;
using v8_crdtp::ProtocolTypeTraits;

// ------------- Enum values from types.

const char Metainfo::domainName[] = "Network";
const char Metainfo::commandPrefix[] = "Network.";
const char Metainfo::version[] = "1.3";

namespace ResourceTypeEnum {
const char Document[] = "Document";
const char Stylesheet[] = "Stylesheet";
const char Image[] = "Image";
const char Media[] = "Media";
const char Font[] = "Font";
const char Script[] = "Script";
const char TextTrack[] = "TextTrack";
const char XHR[] = "XHR";
const char Fetch[] = "Fetch";
const char EventSource[] = "EventSource";
const char WebSocket[] = "WebSocket";
const char Manifest[] = "Manifest";
const char SignedExchange[] = "SignedExchange";
const char Ping[] = "Ping";
const char CSPViolationReport[] = "CSPViolationReport";
const char Other[] = "Other";
} // namespace ResourceTypeEnum





namespace ErrorReasonEnum {
const char Failed[] = "Failed";
const char Aborted[] = "Aborted";
const char TimedOut[] = "TimedOut";
const char AccessDenied[] = "AccessDenied";
const char ConnectionClosed[] = "ConnectionClosed";
const char ConnectionReset[] = "ConnectionReset";
const char ConnectionRefused[] = "ConnectionRefused";
const char ConnectionAborted[] = "ConnectionAborted";
const char ConnectionFailed[] = "ConnectionFailed";
const char NameNotResolved[] = "NameNotResolved";
const char InternetDisconnected[] = "InternetDisconnected";
const char AddressUnreachable[] = "AddressUnreachable";
const char BlockedByClient[] = "BlockedByClient";
const char BlockedByResponse[] = "BlockedByResponse";
} // namespace ErrorReasonEnum





namespace ConnectionTypeEnum {
const char None[] = "none";
const char Cellular2g[] = "cellular2g";
const char Cellular3g[] = "cellular3g";
const char Cellular4g[] = "cellular4g";
const char Bluetooth[] = "bluetooth";
const char Ethernet[] = "ethernet";
const char Wifi[] = "wifi";
const char Wimax[] = "wimax";
const char Other[] = "other";
} // namespace ConnectionTypeEnum


namespace CookieSameSiteEnum {
const char Strict[] = "Strict";
const char Lax[] = "Lax";
} // namespace CookieSameSiteEnum


V8_CRDTP_BEGIN_DESERIALIZER(ResourceTiming)
    V8_CRDTP_DESERIALIZE_FIELD("connectEnd", m_connectEnd),
    V8_CRDTP_DESERIALIZE_FIELD("connectStart", m_connectStart),
    V8_CRDTP_DESERIALIZE_FIELD("dnsEnd", m_dnsEnd),
    V8_CRDTP_DESERIALIZE_FIELD("dnsStart", m_dnsStart),
    V8_CRDTP_DESERIALIZE_FIELD("proxyEnd", m_proxyEnd),
    V8_CRDTP_DESERIALIZE_FIELD("proxyStart", m_proxyStart),
    V8_CRDTP_DESERIALIZE_FIELD("pushEnd", m_pushEnd),
    V8_CRDTP_DESERIALIZE_FIELD("pushStart", m_pushStart),
    V8_CRDTP_DESERIALIZE_FIELD("receiveHeadersEnd", m_receiveHeadersEnd),
    V8_CRDTP_DESERIALIZE_FIELD("requestTime", m_requestTime),
    V8_CRDTP_DESERIALIZE_FIELD("sendEnd", m_sendEnd),
    V8_CRDTP_DESERIALIZE_FIELD("sendStart", m_sendStart),
    V8_CRDTP_DESERIALIZE_FIELD("sslEnd", m_sslEnd),
    V8_CRDTP_DESERIALIZE_FIELD("sslStart", m_sslStart),
    V8_CRDTP_DESERIALIZE_FIELD("workerReady", m_workerReady),
    V8_CRDTP_DESERIALIZE_FIELD("workerStart", m_workerStart),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(ResourceTiming)
    V8_CRDTP_SERIALIZE_FIELD("requestTime", m_requestTime);
    V8_CRDTP_SERIALIZE_FIELD("proxyStart", m_proxyStart);
    V8_CRDTP_SERIALIZE_FIELD("proxyEnd", m_proxyEnd);
    V8_CRDTP_SERIALIZE_FIELD("dnsStart", m_dnsStart);
    V8_CRDTP_SERIALIZE_FIELD("dnsEnd", m_dnsEnd);
    V8_CRDTP_SERIALIZE_FIELD("connectStart", m_connectStart);
    V8_CRDTP_SERIALIZE_FIELD("connectEnd", m_connectEnd);
    V8_CRDTP_SERIALIZE_FIELD("sslStart", m_sslStart);
    V8_CRDTP_SERIALIZE_FIELD("sslEnd", m_sslEnd);
    V8_CRDTP_SERIALIZE_FIELD("workerStart", m_workerStart);
    V8_CRDTP_SERIALIZE_FIELD("workerReady", m_workerReady);
    V8_CRDTP_SERIALIZE_FIELD("sendStart", m_sendStart);
    V8_CRDTP_SERIALIZE_FIELD("sendEnd", m_sendEnd);
    V8_CRDTP_SERIALIZE_FIELD("pushStart", m_pushStart);
    V8_CRDTP_SERIALIZE_FIELD("pushEnd", m_pushEnd);
    V8_CRDTP_SERIALIZE_FIELD("receiveHeadersEnd", m_receiveHeadersEnd);
V8_CRDTP_END_SERIALIZER();


namespace ResourcePriorityEnum {
const char VeryLow[] = "VeryLow";
const char Low[] = "Low";
const char Medium[] = "Medium";
const char High[] = "High";
const char VeryHigh[] = "VeryHigh";
} // namespace ResourcePriorityEnum



const char* Request::ReferrerPolicyEnum::UnsafeUrl = "unsafe-url";
const char* Request::ReferrerPolicyEnum::NoReferrerWhenDowngrade = "no-referrer-when-downgrade";
const char* Request::ReferrerPolicyEnum::NoReferrer = "no-referrer";
const char* Request::ReferrerPolicyEnum::Origin = "origin";
const char* Request::ReferrerPolicyEnum::OriginWhenCrossOrigin = "origin-when-cross-origin";
const char* Request::ReferrerPolicyEnum::SameOrigin = "same-origin";
const char* Request::ReferrerPolicyEnum::StrictOrigin = "strict-origin";
const char* Request::ReferrerPolicyEnum::StrictOriginWhenCrossOrigin = "strict-origin-when-cross-origin";
V8_CRDTP_BEGIN_DESERIALIZER(Request)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("hasPostData", m_hasPostData),
    V8_CRDTP_DESERIALIZE_FIELD("headers", m_headers),
    V8_CRDTP_DESERIALIZE_FIELD("initialPriority", m_initialPriority),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("isLinkPreload", m_isLinkPreload),
    V8_CRDTP_DESERIALIZE_FIELD("method", m_method),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("mixedContentType", m_mixedContentType),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("postData", m_postData),
    V8_CRDTP_DESERIALIZE_FIELD("referrerPolicy", m_referrerPolicy),
    V8_CRDTP_DESERIALIZE_FIELD("url", m_url),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("urlFragment", m_urlFragment),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(Request)
    V8_CRDTP_SERIALIZE_FIELD("url", m_url);
    V8_CRDTP_SERIALIZE_FIELD("urlFragment", m_urlFragment);
    V8_CRDTP_SERIALIZE_FIELD("method", m_method);
    V8_CRDTP_SERIALIZE_FIELD("headers", m_headers);
    V8_CRDTP_SERIALIZE_FIELD("postData", m_postData);
    V8_CRDTP_SERIALIZE_FIELD("hasPostData", m_hasPostData);
    V8_CRDTP_SERIALIZE_FIELD("mixedContentType", m_mixedContentType);
    V8_CRDTP_SERIALIZE_FIELD("initialPriority", m_initialPriority);
    V8_CRDTP_SERIALIZE_FIELD("referrerPolicy", m_referrerPolicy);
    V8_CRDTP_SERIALIZE_FIELD("isLinkPreload", m_isLinkPreload);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(SignedCertificateTimestamp)
    V8_CRDTP_DESERIALIZE_FIELD("hashAlgorithm", m_hashAlgorithm),
    V8_CRDTP_DESERIALIZE_FIELD("logDescription", m_logDescription),
    V8_CRDTP_DESERIALIZE_FIELD("logId", m_logId),
    V8_CRDTP_DESERIALIZE_FIELD("origin", m_origin),
    V8_CRDTP_DESERIALIZE_FIELD("signatureAlgorithm", m_signatureAlgorithm),
    V8_CRDTP_DESERIALIZE_FIELD("signatureData", m_signatureData),
    V8_CRDTP_DESERIALIZE_FIELD("status", m_status),
    V8_CRDTP_DESERIALIZE_FIELD("timestamp", m_timestamp),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(SignedCertificateTimestamp)
    V8_CRDTP_SERIALIZE_FIELD("status", m_status);
    V8_CRDTP_SERIALIZE_FIELD("origin", m_origin);
    V8_CRDTP_SERIALIZE_FIELD("logDescription", m_logDescription);
    V8_CRDTP_SERIALIZE_FIELD("logId", m_logId);
    V8_CRDTP_SERIALIZE_FIELD("timestamp", m_timestamp);
    V8_CRDTP_SERIALIZE_FIELD("hashAlgorithm", m_hashAlgorithm);
    V8_CRDTP_SERIALIZE_FIELD("signatureAlgorithm", m_signatureAlgorithm);
    V8_CRDTP_SERIALIZE_FIELD("signatureData", m_signatureData);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(SecurityDetails)
    V8_CRDTP_DESERIALIZE_FIELD("certificateId", m_certificateId),
    V8_CRDTP_DESERIALIZE_FIELD("certificateTransparencyCompliance", m_certificateTransparencyCompliance),
    V8_CRDTP_DESERIALIZE_FIELD("cipher", m_cipher),
    V8_CRDTP_DESERIALIZE_FIELD("issuer", m_issuer),
    V8_CRDTP_DESERIALIZE_FIELD("keyExchange", m_keyExchange),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("keyExchangeGroup", m_keyExchangeGroup),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("mac", m_mac),
    V8_CRDTP_DESERIALIZE_FIELD("protocol", m_protocol),
    V8_CRDTP_DESERIALIZE_FIELD("sanList", m_sanList),
    V8_CRDTP_DESERIALIZE_FIELD("signedCertificateTimestampList", m_signedCertificateTimestampList),
    V8_CRDTP_DESERIALIZE_FIELD("subjectName", m_subjectName),
    V8_CRDTP_DESERIALIZE_FIELD("validFrom", m_validFrom),
    V8_CRDTP_DESERIALIZE_FIELD("validTo", m_validTo),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(SecurityDetails)
    V8_CRDTP_SERIALIZE_FIELD("protocol", m_protocol);
    V8_CRDTP_SERIALIZE_FIELD("keyExchange", m_keyExchange);
    V8_CRDTP_SERIALIZE_FIELD("keyExchangeGroup", m_keyExchangeGroup);
    V8_CRDTP_SERIALIZE_FIELD("cipher", m_cipher);
    V8_CRDTP_SERIALIZE_FIELD("mac", m_mac);
    V8_CRDTP_SERIALIZE_FIELD("certificateId", m_certificateId);
    V8_CRDTP_SERIALIZE_FIELD("subjectName", m_subjectName);
    V8_CRDTP_SERIALIZE_FIELD("sanList", m_sanList);
    V8_CRDTP_SERIALIZE_FIELD("issuer", m_issuer);
    V8_CRDTP_SERIALIZE_FIELD("validFrom", m_validFrom);
    V8_CRDTP_SERIALIZE_FIELD("validTo", m_validTo);
    V8_CRDTP_SERIALIZE_FIELD("signedCertificateTimestampList", m_signedCertificateTimestampList);
    V8_CRDTP_SERIALIZE_FIELD("certificateTransparencyCompliance", m_certificateTransparencyCompliance);
V8_CRDTP_END_SERIALIZER();


namespace CertificateTransparencyComplianceEnum {
const char Unknown[] = "unknown";
const char NotCompliant[] = "not-compliant";
const char Compliant[] = "compliant";
} // namespace CertificateTransparencyComplianceEnum


namespace BlockedReasonEnum {
const char Other[] = "other";
const char Csp[] = "csp";
const char MixedContent[] = "mixed-content";
const char Origin[] = "origin";
const char Inspector[] = "inspector";
const char SubresourceFilter[] = "subresource-filter";
const char ContentType[] = "content-type";
const char CollapsedByClient[] = "collapsed-by-client";
} // namespace BlockedReasonEnum


V8_CRDTP_BEGIN_DESERIALIZER(Response)
    V8_CRDTP_DESERIALIZE_FIELD("connectionId", m_connectionId),
    V8_CRDTP_DESERIALIZE_FIELD("connectionReused", m_connectionReused),
    V8_CRDTP_DESERIALIZE_FIELD("encodedDataLength", m_encodedDataLength),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("fromDiskCache", m_fromDiskCache),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("fromServiceWorker", m_fromServiceWorker),
    V8_CRDTP_DESERIALIZE_FIELD("headers", m_headers),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("headersText", m_headersText),
    V8_CRDTP_DESERIALIZE_FIELD("mimeType", m_mimeType),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("protocol", m_protocol),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("remoteIPAddress", m_remoteIPAddress),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("remotePort", m_remotePort),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("requestHeaders", m_requestHeaders),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("requestHeadersText", m_requestHeadersText),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("securityDetails", m_securityDetails),
    V8_CRDTP_DESERIALIZE_FIELD("securityState", m_securityState),
    V8_CRDTP_DESERIALIZE_FIELD("status", m_status),
    V8_CRDTP_DESERIALIZE_FIELD("statusText", m_statusText),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("timing", m_timing),
    V8_CRDTP_DESERIALIZE_FIELD("url", m_url),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(Response)
    V8_CRDTP_SERIALIZE_FIELD("url", m_url);
    V8_CRDTP_SERIALIZE_FIELD("status", m_status);
    V8_CRDTP_SERIALIZE_FIELD("statusText", m_statusText);
    V8_CRDTP_SERIALIZE_FIELD("headers", m_headers);
    V8_CRDTP_SERIALIZE_FIELD("headersText", m_headersText);
    V8_CRDTP_SERIALIZE_FIELD("mimeType", m_mimeType);
    V8_CRDTP_SERIALIZE_FIELD("requestHeaders", m_requestHeaders);
    V8_CRDTP_SERIALIZE_FIELD("requestHeadersText", m_requestHeadersText);
    V8_CRDTP_SERIALIZE_FIELD("connectionReused", m_connectionReused);
    V8_CRDTP_SERIALIZE_FIELD("connectionId", m_connectionId);
    V8_CRDTP_SERIALIZE_FIELD("remoteIPAddress", m_remoteIPAddress);
    V8_CRDTP_SERIALIZE_FIELD("remotePort", m_remotePort);
    V8_CRDTP_SERIALIZE_FIELD("fromDiskCache", m_fromDiskCache);
    V8_CRDTP_SERIALIZE_FIELD("fromServiceWorker", m_fromServiceWorker);
    V8_CRDTP_SERIALIZE_FIELD("encodedDataLength", m_encodedDataLength);
    V8_CRDTP_SERIALIZE_FIELD("timing", m_timing);
    V8_CRDTP_SERIALIZE_FIELD("protocol", m_protocol);
    V8_CRDTP_SERIALIZE_FIELD("securityState", m_securityState);
    V8_CRDTP_SERIALIZE_FIELD("securityDetails", m_securityDetails);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(WebSocketRequest)
    V8_CRDTP_DESERIALIZE_FIELD("headers", m_headers),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(WebSocketRequest)
    V8_CRDTP_SERIALIZE_FIELD("headers", m_headers);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(WebSocketResponse)
    V8_CRDTP_DESERIALIZE_FIELD("headers", m_headers),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("headersText", m_headersText),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("requestHeaders", m_requestHeaders),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("requestHeadersText", m_requestHeadersText),
    V8_CRDTP_DESERIALIZE_FIELD("status", m_status),
    V8_CRDTP_DESERIALIZE_FIELD("statusText", m_statusText),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(WebSocketResponse)
    V8_CRDTP_SERIALIZE_FIELD("status", m_status);
    V8_CRDTP_SERIALIZE_FIELD("statusText", m_statusText);
    V8_CRDTP_SERIALIZE_FIELD("headers", m_headers);
    V8_CRDTP_SERIALIZE_FIELD("headersText", m_headersText);
    V8_CRDTP_SERIALIZE_FIELD("requestHeaders", m_requestHeaders);
    V8_CRDTP_SERIALIZE_FIELD("requestHeadersText", m_requestHeadersText);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(WebSocketFrame)
    V8_CRDTP_DESERIALIZE_FIELD("mask", m_mask),
    V8_CRDTP_DESERIALIZE_FIELD("opcode", m_opcode),
    V8_CRDTP_DESERIALIZE_FIELD("payloadData", m_payloadData),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(WebSocketFrame)
    V8_CRDTP_SERIALIZE_FIELD("opcode", m_opcode);
    V8_CRDTP_SERIALIZE_FIELD("mask", m_mask);
    V8_CRDTP_SERIALIZE_FIELD("payloadData", m_payloadData);
V8_CRDTP_END_SERIALIZER();



const char* Initiator::TypeEnum::Parser = "parser";
const char* Initiator::TypeEnum::Script = "script";
const char* Initiator::TypeEnum::Preload = "preload";
const char* Initiator::TypeEnum::SignedExchange = "SignedExchange";
const char* Initiator::TypeEnum::Other = "other";
V8_CRDTP_BEGIN_DESERIALIZER(Initiator)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("lineNumber", m_lineNumber),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("stack", m_stack),
    V8_CRDTP_DESERIALIZE_FIELD("type", m_type),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("url", m_url),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(Initiator)
    V8_CRDTP_SERIALIZE_FIELD("type", m_type);
    V8_CRDTP_SERIALIZE_FIELD("stack", m_stack);
    V8_CRDTP_SERIALIZE_FIELD("url", m_url);
    V8_CRDTP_SERIALIZE_FIELD("lineNumber", m_lineNumber);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(Cookie)
    V8_CRDTP_DESERIALIZE_FIELD("domain", m_domain),
    V8_CRDTP_DESERIALIZE_FIELD("expires", m_expires),
    V8_CRDTP_DESERIALIZE_FIELD("httpOnly", m_httpOnly),
    V8_CRDTP_DESERIALIZE_FIELD("name", m_name),
    V8_CRDTP_DESERIALIZE_FIELD("path", m_path),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("sameSite", m_sameSite),
    V8_CRDTP_DESERIALIZE_FIELD("secure", m_secure),
    V8_CRDTP_DESERIALIZE_FIELD("session", m_session),
    V8_CRDTP_DESERIALIZE_FIELD("size", m_size),
    V8_CRDTP_DESERIALIZE_FIELD("value", m_value),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(Cookie)
    V8_CRDTP_SERIALIZE_FIELD("name", m_name);
    V8_CRDTP_SERIALIZE_FIELD("value", m_value);
    V8_CRDTP_SERIALIZE_FIELD("domain", m_domain);
    V8_CRDTP_SERIALIZE_FIELD("path", m_path);
    V8_CRDTP_SERIALIZE_FIELD("expires", m_expires);
    V8_CRDTP_SERIALIZE_FIELD("size", m_size);
    V8_CRDTP_SERIALIZE_FIELD("httpOnly", m_httpOnly);
    V8_CRDTP_SERIALIZE_FIELD("secure", m_secure);
    V8_CRDTP_SERIALIZE_FIELD("session", m_session);
    V8_CRDTP_SERIALIZE_FIELD("sameSite", m_sameSite);
V8_CRDTP_END_SERIALIZER();



const char* AuthChallenge::SourceEnum::Server = "Server";
const char* AuthChallenge::SourceEnum::Proxy = "Proxy";
V8_CRDTP_BEGIN_DESERIALIZER(AuthChallenge)
    V8_CRDTP_DESERIALIZE_FIELD("origin", m_origin),
    V8_CRDTP_DESERIALIZE_FIELD("realm", m_realm),
    V8_CRDTP_DESERIALIZE_FIELD("scheme", m_scheme),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("source", m_source),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(AuthChallenge)
    V8_CRDTP_SERIALIZE_FIELD("source", m_source);
    V8_CRDTP_SERIALIZE_FIELD("origin", m_origin);
    V8_CRDTP_SERIALIZE_FIELD("scheme", m_scheme);
    V8_CRDTP_SERIALIZE_FIELD("realm", m_realm);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(SignedExchangeSignature)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("certSha256", m_certSha256),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("certUrl", m_certUrl),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("certificates", m_certificates),
    V8_CRDTP_DESERIALIZE_FIELD("date", m_date),
    V8_CRDTP_DESERIALIZE_FIELD("expires", m_expires),
    V8_CRDTP_DESERIALIZE_FIELD("integrity", m_integrity),
    V8_CRDTP_DESERIALIZE_FIELD("label", m_label),
    V8_CRDTP_DESERIALIZE_FIELD("signature", m_signature),
    V8_CRDTP_DESERIALIZE_FIELD("validityUrl", m_validityUrl),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(SignedExchangeSignature)
    V8_CRDTP_SERIALIZE_FIELD("label", m_label);
    V8_CRDTP_SERIALIZE_FIELD("signature", m_signature);
    V8_CRDTP_SERIALIZE_FIELD("integrity", m_integrity);
    V8_CRDTP_SERIALIZE_FIELD("certUrl", m_certUrl);
    V8_CRDTP_SERIALIZE_FIELD("certSha256", m_certSha256);
    V8_CRDTP_SERIALIZE_FIELD("validityUrl", m_validityUrl);
    V8_CRDTP_SERIALIZE_FIELD("date", m_date);
    V8_CRDTP_SERIALIZE_FIELD("expires", m_expires);
    V8_CRDTP_SERIALIZE_FIELD("certificates", m_certificates);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(SignedExchangeHeader)
    V8_CRDTP_DESERIALIZE_FIELD("requestUrl", m_requestUrl),
    V8_CRDTP_DESERIALIZE_FIELD("responseCode", m_responseCode),
    V8_CRDTP_DESERIALIZE_FIELD("responseHeaders", m_responseHeaders),
    V8_CRDTP_DESERIALIZE_FIELD("signatures", m_signatures),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(SignedExchangeHeader)
    V8_CRDTP_SERIALIZE_FIELD("requestUrl", m_requestUrl);
    V8_CRDTP_SERIALIZE_FIELD("responseCode", m_responseCode);
    V8_CRDTP_SERIALIZE_FIELD("responseHeaders", m_responseHeaders);
    V8_CRDTP_SERIALIZE_FIELD("signatures", m_signatures);
V8_CRDTP_END_SERIALIZER();


namespace SignedExchangeErrorFieldEnum {
const char SignatureSig[] = "signatureSig";
const char SignatureIntegrity[] = "signatureIntegrity";
const char SignatureCertUrl[] = "signatureCertUrl";
const char SignatureCertSha256[] = "signatureCertSha256";
const char SignatureValidityUrl[] = "signatureValidityUrl";
const char SignatureTimestamps[] = "signatureTimestamps";
} // namespace SignedExchangeErrorFieldEnum


V8_CRDTP_BEGIN_DESERIALIZER(SignedExchangeError)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("errorField", m_errorField),
    V8_CRDTP_DESERIALIZE_FIELD("message", m_message),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("signatureIndex", m_signatureIndex),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(SignedExchangeError)
    V8_CRDTP_SERIALIZE_FIELD("message", m_message);
    V8_CRDTP_SERIALIZE_FIELD("signatureIndex", m_signatureIndex);
    V8_CRDTP_SERIALIZE_FIELD("errorField", m_errorField);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(SignedExchangeInfo)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("errors", m_errors),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("header", m_header),
    V8_CRDTP_DESERIALIZE_FIELD("outerResponse", m_outerResponse),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("securityDetails", m_securityDetails),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(SignedExchangeInfo)
    V8_CRDTP_SERIALIZE_FIELD("outerResponse", m_outerResponse);
    V8_CRDTP_SERIALIZE_FIELD("header", m_header);
    V8_CRDTP_SERIALIZE_FIELD("securityDetails", m_securityDetails);
    V8_CRDTP_SERIALIZE_FIELD("errors", m_errors);
V8_CRDTP_END_SERIALIZER();


// ------------- Enum values from params.


// ------------- Frontend notifications.

void Frontend::dataReceived(const String& requestId, double timestamp, int dataLength, int encodedDataLength)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("requestId"), requestId);
    serializer.AddField(v8_crdtp::MakeSpan("timestamp"), timestamp);
    serializer.AddField(v8_crdtp::MakeSpan("dataLength"), dataLength);
    serializer.AddField(v8_crdtp::MakeSpan("encodedDataLength"), encodedDataLength);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Network.dataReceived", serializer.Finish()));
}

void Frontend::eventSourceMessageReceived(const String& requestId, double timestamp, const String& eventName, const String& eventId, const String& data)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("requestId"), requestId);
    serializer.AddField(v8_crdtp::MakeSpan("timestamp"), timestamp);
    serializer.AddField(v8_crdtp::MakeSpan("eventName"), eventName);
    serializer.AddField(v8_crdtp::MakeSpan("eventId"), eventId);
    serializer.AddField(v8_crdtp::MakeSpan("data"), data);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Network.eventSourceMessageReceived", serializer.Finish()));
}

void Frontend::loadingFailed(const String& requestId, double timestamp, const String& type, const String& errorText, Maybe<bool> canceled, Maybe<String> blockedReason)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("requestId"), requestId);
    serializer.AddField(v8_crdtp::MakeSpan("timestamp"), timestamp);
    serializer.AddField(v8_crdtp::MakeSpan("type"), type);
    serializer.AddField(v8_crdtp::MakeSpan("errorText"), errorText);
    serializer.AddField(v8_crdtp::MakeSpan("canceled"), canceled);
    serializer.AddField(v8_crdtp::MakeSpan("blockedReason"), blockedReason);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Network.loadingFailed", serializer.Finish()));
}

void Frontend::loadingFinished(const String& requestId, double timestamp, double encodedDataLength, Maybe<bool> shouldReportCorbBlocking)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("requestId"), requestId);
    serializer.AddField(v8_crdtp::MakeSpan("timestamp"), timestamp);
    serializer.AddField(v8_crdtp::MakeSpan("encodedDataLength"), encodedDataLength);
    serializer.AddField(v8_crdtp::MakeSpan("shouldReportCorbBlocking"), shouldReportCorbBlocking);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Network.loadingFinished", serializer.Finish()));
}

void Frontend::requestIntercepted(const String& interceptionId, std::unique_ptr<protocol::Network::Request> request, const String& frameId, const String& resourceType, bool isNavigationRequest, Maybe<bool> isDownload, Maybe<String> redirectUrl, Maybe<protocol::Network::AuthChallenge> authChallenge, Maybe<String> responseErrorReason, Maybe<int> responseStatusCode, Maybe<protocol::Network::Headers> responseHeaders)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("interceptionId"), interceptionId);
    serializer.AddField(v8_crdtp::MakeSpan("request"), request);
    serializer.AddField(v8_crdtp::MakeSpan("frameId"), frameId);
    serializer.AddField(v8_crdtp::MakeSpan("resourceType"), resourceType);
    serializer.AddField(v8_crdtp::MakeSpan("isNavigationRequest"), isNavigationRequest);
    serializer.AddField(v8_crdtp::MakeSpan("isDownload"), isDownload);
    serializer.AddField(v8_crdtp::MakeSpan("redirectUrl"), redirectUrl);
    serializer.AddField(v8_crdtp::MakeSpan("authChallenge"), authChallenge);
    serializer.AddField(v8_crdtp::MakeSpan("responseErrorReason"), responseErrorReason);
    serializer.AddField(v8_crdtp::MakeSpan("responseStatusCode"), responseStatusCode);
    serializer.AddField(v8_crdtp::MakeSpan("responseHeaders"), responseHeaders);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Network.requestIntercepted", serializer.Finish()));
}

void Frontend::requestServedFromCache(const String& requestId)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("requestId"), requestId);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Network.requestServedFromCache", serializer.Finish()));
}

void Frontend::requestWillBeSent(const String& requestId, const String& loaderId, const String& documentURL, std::unique_ptr<protocol::Network::Request> request, double timestamp, double wallTime, std::unique_ptr<protocol::Network::Initiator> initiator, Maybe<protocol::Network::Response> redirectResponse, Maybe<String> type, Maybe<String> frameId, Maybe<bool> hasUserGesture)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("requestId"), requestId);
    serializer.AddField(v8_crdtp::MakeSpan("loaderId"), loaderId);
    serializer.AddField(v8_crdtp::MakeSpan("documentURL"), documentURL);
    serializer.AddField(v8_crdtp::MakeSpan("request"), request);
    serializer.AddField(v8_crdtp::MakeSpan("timestamp"), timestamp);
    serializer.AddField(v8_crdtp::MakeSpan("wallTime"), wallTime);
    serializer.AddField(v8_crdtp::MakeSpan("initiator"), initiator);
    serializer.AddField(v8_crdtp::MakeSpan("redirectResponse"), redirectResponse);
    serializer.AddField(v8_crdtp::MakeSpan("type"), type);
    serializer.AddField(v8_crdtp::MakeSpan("frameId"), frameId);
    serializer.AddField(v8_crdtp::MakeSpan("hasUserGesture"), hasUserGesture);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Network.requestWillBeSent", serializer.Finish()));
}

void Frontend::resourceChangedPriority(const String& requestId, const String& newPriority, double timestamp)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("requestId"), requestId);
    serializer.AddField(v8_crdtp::MakeSpan("newPriority"), newPriority);
    serializer.AddField(v8_crdtp::MakeSpan("timestamp"), timestamp);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Network.resourceChangedPriority", serializer.Finish()));
}

void Frontend::signedExchangeReceived(const String& requestId, std::unique_ptr<protocol::Network::SignedExchangeInfo> info)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("requestId"), requestId);
    serializer.AddField(v8_crdtp::MakeSpan("info"), info);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Network.signedExchangeReceived", serializer.Finish()));
}

void Frontend::responseReceived(const String& requestId, const String& loaderId, double timestamp, const String& type, std::unique_ptr<protocol::Network::Response> response, Maybe<String> frameId)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("requestId"), requestId);
    serializer.AddField(v8_crdtp::MakeSpan("loaderId"), loaderId);
    serializer.AddField(v8_crdtp::MakeSpan("timestamp"), timestamp);
    serializer.AddField(v8_crdtp::MakeSpan("type"), type);
    serializer.AddField(v8_crdtp::MakeSpan("response"), response);
    serializer.AddField(v8_crdtp::MakeSpan("frameId"), frameId);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Network.responseReceived", serializer.Finish()));
}

void Frontend::webSocketClosed(const String& requestId, double timestamp)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("requestId"), requestId);
    serializer.AddField(v8_crdtp::MakeSpan("timestamp"), timestamp);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Network.webSocketClosed", serializer.Finish()));
}

void Frontend::webSocketCreated(const String& requestId, const String& url, Maybe<protocol::Network::Initiator> initiator)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("requestId"), requestId);
    serializer.AddField(v8_crdtp::MakeSpan("url"), url);
    serializer.AddField(v8_crdtp::MakeSpan("initiator"), initiator);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Network.webSocketCreated", serializer.Finish()));
}

void Frontend::webSocketFrameError(const String& requestId, double timestamp, const String& errorMessage)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("requestId"), requestId);
    serializer.AddField(v8_crdtp::MakeSpan("timestamp"), timestamp);
    serializer.AddField(v8_crdtp::MakeSpan("errorMessage"), errorMessage);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Network.webSocketFrameError", serializer.Finish()));
}

void Frontend::webSocketFrameReceived(const String& requestId, double timestamp, std::unique_ptr<protocol::Network::WebSocketFrame> response)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("requestId"), requestId);
    serializer.AddField(v8_crdtp::MakeSpan("timestamp"), timestamp);
    serializer.AddField(v8_crdtp::MakeSpan("response"), response);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Network.webSocketFrameReceived", serializer.Finish()));
}

void Frontend::webSocketFrameSent(const String& requestId, double timestamp, std::unique_ptr<protocol::Network::WebSocketFrame> response)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("requestId"), requestId);
    serializer.AddField(v8_crdtp::MakeSpan("timestamp"), timestamp);
    serializer.AddField(v8_crdtp::MakeSpan("response"), response);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Network.webSocketFrameSent", serializer.Finish()));
}

void Frontend::webSocketHandshakeResponseReceived(const String& requestId, double timestamp, std::unique_ptr<protocol::Network::WebSocketResponse> response)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("requestId"), requestId);
    serializer.AddField(v8_crdtp::MakeSpan("timestamp"), timestamp);
    serializer.AddField(v8_crdtp::MakeSpan("response"), response);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Network.webSocketHandshakeResponseReceived", serializer.Finish()));
}

void Frontend::webSocketWillSendHandshakeRequest(const String& requestId, double timestamp, double wallTime, std::unique_ptr<protocol::Network::WebSocketRequest> request)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("requestId"), requestId);
    serializer.AddField(v8_crdtp::MakeSpan("timestamp"), timestamp);
    serializer.AddField(v8_crdtp::MakeSpan("wallTime"), wallTime);
    serializer.AddField(v8_crdtp::MakeSpan("request"), request);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Network.webSocketWillSendHandshakeRequest", serializer.Finish()));
}

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const v8_crdtp::Dispatchable& dispatchable);

    std::function<void(const v8_crdtp::Dispatchable&)> Dispatch(v8_crdtp::span<uint8_t> command_name) override;

    void canClearBrowserCache(const v8_crdtp::Dispatchable& dispatchable);
    void canClearBrowserCookies(const v8_crdtp::Dispatchable& dispatchable);
    void disable(const v8_crdtp::Dispatchable& dispatchable);
    void emulateNetworkConditions(const v8_crdtp::Dispatchable& dispatchable);
    void enable(const v8_crdtp::Dispatchable& dispatchable);
    void getCertificate(const v8_crdtp::Dispatchable& dispatchable);
    void getResponseBody(const v8_crdtp::Dispatchable& dispatchable);
    void getRequestPostData(const v8_crdtp::Dispatchable& dispatchable);
    void replayXHR(const v8_crdtp::Dispatchable& dispatchable);
    void searchInResponseBody(const v8_crdtp::Dispatchable& dispatchable);
    void setBlockedURLs(const v8_crdtp::Dispatchable& dispatchable);
    void setBypassServiceWorker(const v8_crdtp::Dispatchable& dispatchable);
    void setCacheDisabled(const v8_crdtp::Dispatchable& dispatchable);
    void setDataSizeLimitsForTest(const v8_crdtp::Dispatchable& dispatchable);
    void setExtraHTTPHeaders(const v8_crdtp::Dispatchable& dispatchable);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(v8_crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<v8_crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          v8_crdtp::SpanFrom("canClearBrowserCache"),
          &DomainDispatcherImpl::canClearBrowserCache
    },
    {
          v8_crdtp::SpanFrom("canClearBrowserCookies"),
          &DomainDispatcherImpl::canClearBrowserCookies
    },
    {
          v8_crdtp::SpanFrom("disable"),
          &DomainDispatcherImpl::disable
    },
    {
          v8_crdtp::SpanFrom("emulateNetworkConditions"),
          &DomainDispatcherImpl::emulateNetworkConditions
    },
    {
          v8_crdtp::SpanFrom("enable"),
          &DomainDispatcherImpl::enable
    },
    {
          v8_crdtp::SpanFrom("getCertificate"),
          &DomainDispatcherImpl::getCertificate
    },
    {
          v8_crdtp::SpanFrom("getRequestPostData"),
          &DomainDispatcherImpl::getRequestPostData
    },
    {
          v8_crdtp::SpanFrom("getResponseBody"),
          &DomainDispatcherImpl::getResponseBody
    },
    {
          v8_crdtp::SpanFrom("replayXHR"),
          &DomainDispatcherImpl::replayXHR
    },
    {
          v8_crdtp::SpanFrom("searchInResponseBody"),
          &DomainDispatcherImpl::searchInResponseBody
    },
    {
          v8_crdtp::SpanFrom("setBlockedURLs"),
          &DomainDispatcherImpl::setBlockedURLs
    },
    {
          v8_crdtp::SpanFrom("setBypassServiceWorker"),
          &DomainDispatcherImpl::setBypassServiceWorker
    },
    {
          v8_crdtp::SpanFrom("setCacheDisabled"),
          &DomainDispatcherImpl::setCacheDisabled
    },
    {
          v8_crdtp::SpanFrom("setDataSizeLimitsForTest"),
          &DomainDispatcherImpl::setDataSizeLimitsForTest
    },
    {
          v8_crdtp::SpanFrom("setExtraHTTPHeaders"),
          &DomainDispatcherImpl::setExtraHTTPHeaders
    },
    };
    return commands;
  }();
  return v8_crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const v8_crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(v8_crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;

  return [this, handler](const v8_crdtp::Dispatchable& dispatchable) {
    (this->*handler)(dispatchable);
  };
}


namespace {


}  // namespace

void DomainDispatcherImpl::canClearBrowserCache(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    // Declare output parameters.
    bool out_result;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->canClearBrowserCache(&out_result);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Network.canClearBrowserCache"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("result"), out_result);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::canClearBrowserCookies(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    // Declare output parameters.
    bool out_result;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->canClearBrowserCookies(&out_result);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Network.canClearBrowserCookies"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("result"), out_result);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::disable(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->disable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Network.disable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct emulateNetworkConditionsParams : public v8_crdtp::DeserializableProtocolObject<emulateNetworkConditionsParams> {
    bool offline;
    double latency;
    double downloadThroughput;
    double uploadThroughput;
    Maybe<String> connectionType;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(emulateNetworkConditionsParams)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("connectionType", connectionType),
    V8_CRDTP_DESERIALIZE_FIELD("downloadThroughput", downloadThroughput),
    V8_CRDTP_DESERIALIZE_FIELD("latency", latency),
    V8_CRDTP_DESERIALIZE_FIELD("offline", offline),
    V8_CRDTP_DESERIALIZE_FIELD("uploadThroughput", uploadThroughput),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::emulateNetworkConditions(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    emulateNetworkConditionsParams params;
    emulateNetworkConditionsParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->emulateNetworkConditions(params.offline, params.latency, params.downloadThroughput, params.uploadThroughput, std::move(params.connectionType));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Network.emulateNetworkConditions"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct enableParams : public v8_crdtp::DeserializableProtocolObject<enableParams> {
    Maybe<int> maxTotalBufferSize;
    Maybe<int> maxResourceBufferSize;
    Maybe<int> maxPostDataSize;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(enableParams)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("maxPostDataSize", maxPostDataSize),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("maxResourceBufferSize", maxResourceBufferSize),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("maxTotalBufferSize", maxTotalBufferSize),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::enable(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    enableParams params;
    enableParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->enable(std::move(params.maxTotalBufferSize), std::move(params.maxResourceBufferSize), std::move(params.maxPostDataSize));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Network.enable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct getCertificateParams : public v8_crdtp::DeserializableProtocolObject<getCertificateParams> {
    String origin;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(getCertificateParams)
    V8_CRDTP_DESERIALIZE_FIELD("origin", origin),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getCertificate(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getCertificateParams params;
    getCertificateParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    std::unique_ptr<protocol::Array<String>> out_tableNames;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getCertificate(params.origin, &out_tableNames);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Network.getCertificate"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("tableNames"), out_tableNames);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

class GetResponseBodyCallbackImpl : public Backend::GetResponseBodyCallback, public DomainDispatcher::Callback {
public:
    GetResponseBodyCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, v8_crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
v8_crdtp::SpanFrom("Network.getResponseBody"), message) { }

    void sendSuccess(const String& body, bool base64Encoded) override
    {
        v8_crdtp::ObjectSerializer serializer;
        serializer.AddField(v8_crdtp::MakeSpan("body"), body);
        serializer.AddField(v8_crdtp::MakeSpan("base64Encoded"), base64Encoded);
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {

struct getResponseBodyParams : public v8_crdtp::DeserializableProtocolObject<getResponseBodyParams> {
    String requestId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(getResponseBodyParams)
    V8_CRDTP_DESERIALIZE_FIELD("requestId", requestId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getResponseBody(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getResponseBodyParams params;
    getResponseBodyParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    m_backend->getResponseBody(params.requestId, std::make_unique<GetResponseBodyCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class GetRequestPostDataCallbackImpl : public Backend::GetRequestPostDataCallback, public DomainDispatcher::Callback {
public:
    GetRequestPostDataCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, v8_crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
v8_crdtp::SpanFrom("Network.getRequestPostData"), message) { }

    void sendSuccess(const String& postData) override
    {
        v8_crdtp::ObjectSerializer serializer;
        serializer.AddField(v8_crdtp::MakeSpan("postData"), postData);
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {

struct getRequestPostDataParams : public v8_crdtp::DeserializableProtocolObject<getRequestPostDataParams> {
    String requestId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(getRequestPostDataParams)
    V8_CRDTP_DESERIALIZE_FIELD("requestId", requestId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getRequestPostData(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getRequestPostDataParams params;
    getRequestPostDataParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    m_backend->getRequestPostData(params.requestId, std::make_unique<GetRequestPostDataCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

namespace {

struct replayXHRParams : public v8_crdtp::DeserializableProtocolObject<replayXHRParams> {
    String requestId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(replayXHRParams)
    V8_CRDTP_DESERIALIZE_FIELD("requestId", requestId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::replayXHR(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    replayXHRParams params;
    replayXHRParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->replayXHR(params.requestId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Network.replayXHR"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct searchInResponseBodyParams : public v8_crdtp::DeserializableProtocolObject<searchInResponseBodyParams> {
    String requestId;
    String query;
    Maybe<bool> caseSensitive;
    Maybe<bool> isRegex;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(searchInResponseBodyParams)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("caseSensitive", caseSensitive),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("isRegex", isRegex),
    V8_CRDTP_DESERIALIZE_FIELD("query", query),
    V8_CRDTP_DESERIALIZE_FIELD("requestId", requestId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::searchInResponseBody(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    searchInResponseBodyParams params;
    searchInResponseBodyParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::Debugger::SearchMatch>> out_result;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->searchInResponseBody(params.requestId, params.query, std::move(params.caseSensitive), std::move(params.isRegex), &out_result);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Network.searchInResponseBody"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("result"), out_result);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct setBlockedURLsParams : public v8_crdtp::DeserializableProtocolObject<setBlockedURLsParams> {
    std::unique_ptr<protocol::Array<String>> urls;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setBlockedURLsParams)
    V8_CRDTP_DESERIALIZE_FIELD("urls", urls),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setBlockedURLs(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setBlockedURLsParams params;
    setBlockedURLsParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setBlockedURLs(std::move(params.urls));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Network.setBlockedURLs"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setBypassServiceWorkerParams : public v8_crdtp::DeserializableProtocolObject<setBypassServiceWorkerParams> {
    bool bypass;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setBypassServiceWorkerParams)
    V8_CRDTP_DESERIALIZE_FIELD("bypass", bypass),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setBypassServiceWorker(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setBypassServiceWorkerParams params;
    setBypassServiceWorkerParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setBypassServiceWorker(params.bypass);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Network.setBypassServiceWorker"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setCacheDisabledParams : public v8_crdtp::DeserializableProtocolObject<setCacheDisabledParams> {
    bool cacheDisabled;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setCacheDisabledParams)
    V8_CRDTP_DESERIALIZE_FIELD("cacheDisabled", cacheDisabled),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setCacheDisabled(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setCacheDisabledParams params;
    setCacheDisabledParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setCacheDisabled(params.cacheDisabled);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Network.setCacheDisabled"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setDataSizeLimitsForTestParams : public v8_crdtp::DeserializableProtocolObject<setDataSizeLimitsForTestParams> {
    int maxTotalSize;
    int maxResourceSize;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setDataSizeLimitsForTestParams)
    V8_CRDTP_DESERIALIZE_FIELD("maxResourceSize", maxResourceSize),
    V8_CRDTP_DESERIALIZE_FIELD("maxTotalSize", maxTotalSize),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setDataSizeLimitsForTest(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setDataSizeLimitsForTestParams params;
    setDataSizeLimitsForTestParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setDataSizeLimitsForTest(params.maxTotalSize, params.maxResourceSize);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Network.setDataSizeLimitsForTest"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setExtraHTTPHeadersParams : public v8_crdtp::DeserializableProtocolObject<setExtraHTTPHeadersParams> {
    std::unique_ptr<protocol::Network::Headers> headers;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setExtraHTTPHeadersParams)
    V8_CRDTP_DESERIALIZE_FIELD("headers", headers),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setExtraHTTPHeaders(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setExtraHTTPHeadersParams params;
    setExtraHTTPHeadersParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setExtraHTTPHeaders(std::move(params.headers));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Network.setExtraHTTPHeaders"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<v8_crdtp::span<uint8_t>, v8_crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<v8_crdtp::span<uint8_t>, v8_crdtp::span<uint8_t>>>{
          { v8_crdtp::SpanFrom("Network.setUserAgentOverride"), v8_crdtp::SpanFrom("Emulation.setUserAgentOverride") },
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(v8_crdtp::SpanFrom("Network"), SortedRedirects(), std::move(dispatcher));
}

} // Network
} // namespace v8_inspector
} // namespace protocol
