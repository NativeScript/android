// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/inspector/protocol/DOM.h"

#include "src/inspector/protocol/Protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/find_by_first.h"
#include "third_party/inspector_protocol/crdtp/span.h"

namespace v8_inspector {
namespace protocol {
namespace DOM {

using v8_crdtp::DeserializerState;
using v8_crdtp::ProtocolTypeTraits;

// ------------- Enum values from types.

const char Metainfo::domainName[] = "DOM";
const char Metainfo::commandPrefix[] = "DOM.";
const char Metainfo::version[] = "1.3";



V8_CRDTP_BEGIN_DESERIALIZER(BackendNode)
    V8_CRDTP_DESERIALIZE_FIELD("backendNodeId", m_backendNodeId),
    V8_CRDTP_DESERIALIZE_FIELD("nodeName", m_nodeName),
    V8_CRDTP_DESERIALIZE_FIELD("nodeType", m_nodeType),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(BackendNode)
    V8_CRDTP_SERIALIZE_FIELD("nodeType", m_nodeType);
    V8_CRDTP_SERIALIZE_FIELD("nodeName", m_nodeName);
    V8_CRDTP_SERIALIZE_FIELD("backendNodeId", m_backendNodeId);
V8_CRDTP_END_SERIALIZER();


namespace PseudoTypeEnum {
const char FirstLine[] = "first-line";
const char FirstLetter[] = "first-letter";
const char Before[] = "before";
const char After[] = "after";
const char Backdrop[] = "backdrop";
const char Selection[] = "selection";
const char FirstLineInherited[] = "first-line-inherited";
const char Scrollbar[] = "scrollbar";
const char ScrollbarThumb[] = "scrollbar-thumb";
const char ScrollbarButton[] = "scrollbar-button";
const char ScrollbarTrack[] = "scrollbar-track";
const char ScrollbarTrackPiece[] = "scrollbar-track-piece";
const char ScrollbarCorner[] = "scrollbar-corner";
const char Resizer[] = "resizer";
const char InputListButton[] = "input-list-button";
} // namespace PseudoTypeEnum


namespace ShadowRootTypeEnum {
const char UserAgent[] = "user-agent";
const char Open[] = "open";
const char Closed[] = "closed";
} // namespace ShadowRootTypeEnum


V8_CRDTP_BEGIN_DESERIALIZER(Node)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("attributes", m_attributes),
    V8_CRDTP_DESERIALIZE_FIELD("backendNodeId", m_backendNodeId),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("baseURL", m_baseURL),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("childNodeCount", m_childNodeCount),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("children", m_children),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("contentDocument", m_contentDocument),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("distributedNodes", m_distributedNodes),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("documentURL", m_documentURL),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("frameId", m_frameId),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("importedDocument", m_importedDocument),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("internalSubset", m_internalSubset),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("isSVG", m_isSVG),
    V8_CRDTP_DESERIALIZE_FIELD("localName", m_localName),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("name", m_name),
    V8_CRDTP_DESERIALIZE_FIELD("nodeId", m_nodeId),
    V8_CRDTP_DESERIALIZE_FIELD("nodeName", m_nodeName),
    V8_CRDTP_DESERIALIZE_FIELD("nodeType", m_nodeType),
    V8_CRDTP_DESERIALIZE_FIELD("nodeValue", m_nodeValue),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("parentId", m_parentId),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("pseudoElements", m_pseudoElements),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("pseudoType", m_pseudoType),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("publicId", m_publicId),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("shadowRootType", m_shadowRootType),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("shadowRoots", m_shadowRoots),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("systemId", m_systemId),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("templateContent", m_templateContent),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("value", m_value),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("xmlVersion", m_xmlVersion),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(Node)
    V8_CRDTP_SERIALIZE_FIELD("nodeId", m_nodeId);
    V8_CRDTP_SERIALIZE_FIELD("parentId", m_parentId);
    V8_CRDTP_SERIALIZE_FIELD("backendNodeId", m_backendNodeId);
    V8_CRDTP_SERIALIZE_FIELD("nodeType", m_nodeType);
    V8_CRDTP_SERIALIZE_FIELD("nodeName", m_nodeName);
    V8_CRDTP_SERIALIZE_FIELD("localName", m_localName);
    V8_CRDTP_SERIALIZE_FIELD("nodeValue", m_nodeValue);
    V8_CRDTP_SERIALIZE_FIELD("childNodeCount", m_childNodeCount);
    V8_CRDTP_SERIALIZE_FIELD("children", m_children);
    V8_CRDTP_SERIALIZE_FIELD("attributes", m_attributes);
    V8_CRDTP_SERIALIZE_FIELD("documentURL", m_documentURL);
    V8_CRDTP_SERIALIZE_FIELD("baseURL", m_baseURL);
    V8_CRDTP_SERIALIZE_FIELD("publicId", m_publicId);
    V8_CRDTP_SERIALIZE_FIELD("systemId", m_systemId);
    V8_CRDTP_SERIALIZE_FIELD("internalSubset", m_internalSubset);
    V8_CRDTP_SERIALIZE_FIELD("xmlVersion", m_xmlVersion);
    V8_CRDTP_SERIALIZE_FIELD("name", m_name);
    V8_CRDTP_SERIALIZE_FIELD("value", m_value);
    V8_CRDTP_SERIALIZE_FIELD("pseudoType", m_pseudoType);
    V8_CRDTP_SERIALIZE_FIELD("shadowRootType", m_shadowRootType);
    V8_CRDTP_SERIALIZE_FIELD("frameId", m_frameId);
    V8_CRDTP_SERIALIZE_FIELD("contentDocument", m_contentDocument);
    V8_CRDTP_SERIALIZE_FIELD("shadowRoots", m_shadowRoots);
    V8_CRDTP_SERIALIZE_FIELD("templateContent", m_templateContent);
    V8_CRDTP_SERIALIZE_FIELD("pseudoElements", m_pseudoElements);
    V8_CRDTP_SERIALIZE_FIELD("importedDocument", m_importedDocument);
    V8_CRDTP_SERIALIZE_FIELD("distributedNodes", m_distributedNodes);
    V8_CRDTP_SERIALIZE_FIELD("isSVG", m_isSVG);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(RGBA)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("a", m_a),
    V8_CRDTP_DESERIALIZE_FIELD("b", m_b),
    V8_CRDTP_DESERIALIZE_FIELD("g", m_g),
    V8_CRDTP_DESERIALIZE_FIELD("r", m_r),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(RGBA)
    V8_CRDTP_SERIALIZE_FIELD("r", m_r);
    V8_CRDTP_SERIALIZE_FIELD("g", m_g);
    V8_CRDTP_SERIALIZE_FIELD("b", m_b);
    V8_CRDTP_SERIALIZE_FIELD("a", m_a);
V8_CRDTP_END_SERIALIZER();



V8_CRDTP_BEGIN_DESERIALIZER(BoxModel)
    V8_CRDTP_DESERIALIZE_FIELD("border", m_border),
    V8_CRDTP_DESERIALIZE_FIELD("content", m_content),
    V8_CRDTP_DESERIALIZE_FIELD("height", m_height),
    V8_CRDTP_DESERIALIZE_FIELD("margin", m_margin),
    V8_CRDTP_DESERIALIZE_FIELD("padding", m_padding),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("shapeOutside", m_shapeOutside),
    V8_CRDTP_DESERIALIZE_FIELD("width", m_width),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(BoxModel)
    V8_CRDTP_SERIALIZE_FIELD("content", m_content);
    V8_CRDTP_SERIALIZE_FIELD("padding", m_padding);
    V8_CRDTP_SERIALIZE_FIELD("border", m_border);
    V8_CRDTP_SERIALIZE_FIELD("margin", m_margin);
    V8_CRDTP_SERIALIZE_FIELD("width", m_width);
    V8_CRDTP_SERIALIZE_FIELD("height", m_height);
    V8_CRDTP_SERIALIZE_FIELD("shapeOutside", m_shapeOutside);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(ShapeOutsideInfo)
    V8_CRDTP_DESERIALIZE_FIELD("bounds", m_bounds),
    V8_CRDTP_DESERIALIZE_FIELD("marginShape", m_marginShape),
    V8_CRDTP_DESERIALIZE_FIELD("shape", m_shape),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(ShapeOutsideInfo)
    V8_CRDTP_SERIALIZE_FIELD("bounds", m_bounds);
    V8_CRDTP_SERIALIZE_FIELD("shape", m_shape);
    V8_CRDTP_SERIALIZE_FIELD("marginShape", m_marginShape);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(Rect)
    V8_CRDTP_DESERIALIZE_FIELD("height", m_height),
    V8_CRDTP_DESERIALIZE_FIELD("width", m_width),
    V8_CRDTP_DESERIALIZE_FIELD("x", m_x),
    V8_CRDTP_DESERIALIZE_FIELD("y", m_y),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(Rect)
    V8_CRDTP_SERIALIZE_FIELD("x", m_x);
    V8_CRDTP_SERIALIZE_FIELD("y", m_y);
    V8_CRDTP_SERIALIZE_FIELD("width", m_width);
    V8_CRDTP_SERIALIZE_FIELD("height", m_height);
V8_CRDTP_END_SERIALIZER();


// ------------- Enum values from params.


// ------------- Frontend notifications.

void Frontend::attributeModified(int nodeId, const String& name, const String& value)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("nodeId"), nodeId);
    serializer.AddField(v8_crdtp::MakeSpan("name"), name);
    serializer.AddField(v8_crdtp::MakeSpan("value"), value);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("DOM.attributeModified", serializer.Finish()));
}

void Frontend::attributeRemoved(int nodeId, const String& name)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("nodeId"), nodeId);
    serializer.AddField(v8_crdtp::MakeSpan("name"), name);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("DOM.attributeRemoved", serializer.Finish()));
}

void Frontend::characterDataModified(int nodeId, const String& characterData)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("nodeId"), nodeId);
    serializer.AddField(v8_crdtp::MakeSpan("characterData"), characterData);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("DOM.characterDataModified", serializer.Finish()));
}

void Frontend::childNodeCountUpdated(int nodeId, int childNodeCount)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("nodeId"), nodeId);
    serializer.AddField(v8_crdtp::MakeSpan("childNodeCount"), childNodeCount);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("DOM.childNodeCountUpdated", serializer.Finish()));
}

void Frontend::childNodeInserted(int parentNodeId, int previousNodeId, std::unique_ptr<protocol::DOM::Node> node)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("parentNodeId"), parentNodeId);
    serializer.AddField(v8_crdtp::MakeSpan("previousNodeId"), previousNodeId);
    serializer.AddField(v8_crdtp::MakeSpan("node"), node);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("DOM.childNodeInserted", serializer.Finish()));
}

void Frontend::childNodeRemoved(int parentNodeId, int nodeId)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("parentNodeId"), parentNodeId);
    serializer.AddField(v8_crdtp::MakeSpan("nodeId"), nodeId);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("DOM.childNodeRemoved", serializer.Finish()));
}

void Frontend::distributedNodesUpdated(int insertionPointId, std::unique_ptr<protocol::Array<protocol::DOM::BackendNode>> distributedNodes)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("insertionPointId"), insertionPointId);
    serializer.AddField(v8_crdtp::MakeSpan("distributedNodes"), distributedNodes);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("DOM.distributedNodesUpdated", serializer.Finish()));
}

void Frontend::documentUpdated()
{
    if (!frontend_channel_)
        return;
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("DOM.documentUpdated"));
}

void Frontend::inlineStyleInvalidated(std::unique_ptr<protocol::Array<int>> nodeIds)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("nodeIds"), nodeIds);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("DOM.inlineStyleInvalidated", serializer.Finish()));
}

void Frontend::pseudoElementAdded(int parentId, std::unique_ptr<protocol::DOM::Node> pseudoElement)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("parentId"), parentId);
    serializer.AddField(v8_crdtp::MakeSpan("pseudoElement"), pseudoElement);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("DOM.pseudoElementAdded", serializer.Finish()));
}

void Frontend::pseudoElementRemoved(int parentId, int pseudoElementId)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("parentId"), parentId);
    serializer.AddField(v8_crdtp::MakeSpan("pseudoElementId"), pseudoElementId);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("DOM.pseudoElementRemoved", serializer.Finish()));
}

void Frontend::setChildNodes(int parentId, std::unique_ptr<protocol::Array<protocol::DOM::Node>> nodes)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("parentId"), parentId);
    serializer.AddField(v8_crdtp::MakeSpan("nodes"), nodes);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("DOM.setChildNodes", serializer.Finish()));
}

void Frontend::shadowRootPopped(int hostId, int rootId)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("hostId"), hostId);
    serializer.AddField(v8_crdtp::MakeSpan("rootId"), rootId);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("DOM.shadowRootPopped", serializer.Finish()));
}

void Frontend::shadowRootPushed(int hostId, std::unique_ptr<protocol::DOM::Node> root)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("hostId"), hostId);
    serializer.AddField(v8_crdtp::MakeSpan("root"), root);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("DOM.shadowRootPushed", serializer.Finish()));
}

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const v8_crdtp::Dispatchable& dispatchable);

    std::function<void(const v8_crdtp::Dispatchable&)> Dispatch(v8_crdtp::span<uint8_t> command_name) override;

    void collectClassNamesFromSubtree(const v8_crdtp::Dispatchable& dispatchable);
    void copyTo(const v8_crdtp::Dispatchable& dispatchable);
    void describeNode(const v8_crdtp::Dispatchable& dispatchable);
    void disable(const v8_crdtp::Dispatchable& dispatchable);
    void discardSearchResults(const v8_crdtp::Dispatchable& dispatchable);
    void enable(const v8_crdtp::Dispatchable& dispatchable);
    void focus(const v8_crdtp::Dispatchable& dispatchable);
    void getAttributes(const v8_crdtp::Dispatchable& dispatchable);
    void getBoxModel(const v8_crdtp::Dispatchable& dispatchable);
    void getContentQuads(const v8_crdtp::Dispatchable& dispatchable);
    void getDocument(const v8_crdtp::Dispatchable& dispatchable);
    void getFlattenedDocument(const v8_crdtp::Dispatchable& dispatchable);
    void getNodeForLocation(const v8_crdtp::Dispatchable& dispatchable);
    void getOuterHTML(const v8_crdtp::Dispatchable& dispatchable);
    void getRelayoutBoundary(const v8_crdtp::Dispatchable& dispatchable);
    void getSearchResults(const v8_crdtp::Dispatchable& dispatchable);
    void markUndoableState(const v8_crdtp::Dispatchable& dispatchable);
    void moveTo(const v8_crdtp::Dispatchable& dispatchable);
    void performSearch(const v8_crdtp::Dispatchable& dispatchable);
    void pushNodeByPathToFrontend(const v8_crdtp::Dispatchable& dispatchable);
    void pushNodesByBackendIdsToFrontend(const v8_crdtp::Dispatchable& dispatchable);
    void querySelector(const v8_crdtp::Dispatchable& dispatchable);
    void querySelectorAll(const v8_crdtp::Dispatchable& dispatchable);
    void redo(const v8_crdtp::Dispatchable& dispatchable);
    void removeAttribute(const v8_crdtp::Dispatchable& dispatchable);
    void removeNode(const v8_crdtp::Dispatchable& dispatchable);
    void requestChildNodes(const v8_crdtp::Dispatchable& dispatchable);
    void requestNode(const v8_crdtp::Dispatchable& dispatchable);
    void resolveNode(const v8_crdtp::Dispatchable& dispatchable);
    void setAttributeValue(const v8_crdtp::Dispatchable& dispatchable);
    void setAttributesAsText(const v8_crdtp::Dispatchable& dispatchable);
    void setFileInputFiles(const v8_crdtp::Dispatchable& dispatchable);
    void getFileInfo(const v8_crdtp::Dispatchable& dispatchable);
    void setInspectedNode(const v8_crdtp::Dispatchable& dispatchable);
    void setNodeName(const v8_crdtp::Dispatchable& dispatchable);
    void setNodeValue(const v8_crdtp::Dispatchable& dispatchable);
    void setOuterHTML(const v8_crdtp::Dispatchable& dispatchable);
    void undo(const v8_crdtp::Dispatchable& dispatchable);
    void getFrameOwner(const v8_crdtp::Dispatchable& dispatchable);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(v8_crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<v8_crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          v8_crdtp::SpanFrom("collectClassNamesFromSubtree"),
          &DomainDispatcherImpl::collectClassNamesFromSubtree
    },
    {
          v8_crdtp::SpanFrom("copyTo"),
          &DomainDispatcherImpl::copyTo
    },
    {
          v8_crdtp::SpanFrom("describeNode"),
          &DomainDispatcherImpl::describeNode
    },
    {
          v8_crdtp::SpanFrom("disable"),
          &DomainDispatcherImpl::disable
    },
    {
          v8_crdtp::SpanFrom("discardSearchResults"),
          &DomainDispatcherImpl::discardSearchResults
    },
    {
          v8_crdtp::SpanFrom("enable"),
          &DomainDispatcherImpl::enable
    },
    {
          v8_crdtp::SpanFrom("focus"),
          &DomainDispatcherImpl::focus
    },
    {
          v8_crdtp::SpanFrom("getAttributes"),
          &DomainDispatcherImpl::getAttributes
    },
    {
          v8_crdtp::SpanFrom("getBoxModel"),
          &DomainDispatcherImpl::getBoxModel
    },
    {
          v8_crdtp::SpanFrom("getContentQuads"),
          &DomainDispatcherImpl::getContentQuads
    },
    {
          v8_crdtp::SpanFrom("getDocument"),
          &DomainDispatcherImpl::getDocument
    },
    {
          v8_crdtp::SpanFrom("getFileInfo"),
          &DomainDispatcherImpl::getFileInfo
    },
    {
          v8_crdtp::SpanFrom("getFlattenedDocument"),
          &DomainDispatcherImpl::getFlattenedDocument
    },
    {
          v8_crdtp::SpanFrom("getFrameOwner"),
          &DomainDispatcherImpl::getFrameOwner
    },
    {
          v8_crdtp::SpanFrom("getNodeForLocation"),
          &DomainDispatcherImpl::getNodeForLocation
    },
    {
          v8_crdtp::SpanFrom("getOuterHTML"),
          &DomainDispatcherImpl::getOuterHTML
    },
    {
          v8_crdtp::SpanFrom("getRelayoutBoundary"),
          &DomainDispatcherImpl::getRelayoutBoundary
    },
    {
          v8_crdtp::SpanFrom("getSearchResults"),
          &DomainDispatcherImpl::getSearchResults
    },
    {
          v8_crdtp::SpanFrom("markUndoableState"),
          &DomainDispatcherImpl::markUndoableState
    },
    {
          v8_crdtp::SpanFrom("moveTo"),
          &DomainDispatcherImpl::moveTo
    },
    {
          v8_crdtp::SpanFrom("performSearch"),
          &DomainDispatcherImpl::performSearch
    },
    {
          v8_crdtp::SpanFrom("pushNodeByPathToFrontend"),
          &DomainDispatcherImpl::pushNodeByPathToFrontend
    },
    {
          v8_crdtp::SpanFrom("pushNodesByBackendIdsToFrontend"),
          &DomainDispatcherImpl::pushNodesByBackendIdsToFrontend
    },
    {
          v8_crdtp::SpanFrom("querySelector"),
          &DomainDispatcherImpl::querySelector
    },
    {
          v8_crdtp::SpanFrom("querySelectorAll"),
          &DomainDispatcherImpl::querySelectorAll
    },
    {
          v8_crdtp::SpanFrom("redo"),
          &DomainDispatcherImpl::redo
    },
    {
          v8_crdtp::SpanFrom("removeAttribute"),
          &DomainDispatcherImpl::removeAttribute
    },
    {
          v8_crdtp::SpanFrom("removeNode"),
          &DomainDispatcherImpl::removeNode
    },
    {
          v8_crdtp::SpanFrom("requestChildNodes"),
          &DomainDispatcherImpl::requestChildNodes
    },
    {
          v8_crdtp::SpanFrom("requestNode"),
          &DomainDispatcherImpl::requestNode
    },
    {
          v8_crdtp::SpanFrom("resolveNode"),
          &DomainDispatcherImpl::resolveNode
    },
    {
          v8_crdtp::SpanFrom("setAttributeValue"),
          &DomainDispatcherImpl::setAttributeValue
    },
    {
          v8_crdtp::SpanFrom("setAttributesAsText"),
          &DomainDispatcherImpl::setAttributesAsText
    },
    {
          v8_crdtp::SpanFrom("setFileInputFiles"),
          &DomainDispatcherImpl::setFileInputFiles
    },
    {
          v8_crdtp::SpanFrom("setInspectedNode"),
          &DomainDispatcherImpl::setInspectedNode
    },
    {
          v8_crdtp::SpanFrom("setNodeName"),
          &DomainDispatcherImpl::setNodeName
    },
    {
          v8_crdtp::SpanFrom("setNodeValue"),
          &DomainDispatcherImpl::setNodeValue
    },
    {
          v8_crdtp::SpanFrom("setOuterHTML"),
          &DomainDispatcherImpl::setOuterHTML
    },
    {
          v8_crdtp::SpanFrom("undo"),
          &DomainDispatcherImpl::undo
    },
    };
    return commands;
  }();
  return v8_crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const v8_crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(v8_crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;

  return [this, handler](const v8_crdtp::Dispatchable& dispatchable) {
    (this->*handler)(dispatchable);
  };
}


namespace {

struct collectClassNamesFromSubtreeParams : public v8_crdtp::DeserializableProtocolObject<collectClassNamesFromSubtreeParams> {
    int nodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(collectClassNamesFromSubtreeParams)
    V8_CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::collectClassNamesFromSubtree(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    collectClassNamesFromSubtreeParams params;
    collectClassNamesFromSubtreeParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    std::unique_ptr<protocol::Array<String>> out_classNames;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->collectClassNamesFromSubtree(params.nodeId, &out_classNames);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.collectClassNamesFromSubtree"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("classNames"), out_classNames);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct copyToParams : public v8_crdtp::DeserializableProtocolObject<copyToParams> {
    int nodeId;
    int targetNodeId;
    Maybe<int> insertBeforeNodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(copyToParams)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("insertBeforeNodeId", insertBeforeNodeId),
    V8_CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
    V8_CRDTP_DESERIALIZE_FIELD("targetNodeId", targetNodeId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::copyTo(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    copyToParams params;
    copyToParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    int out_nodeId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->copyTo(params.nodeId, params.targetNodeId, std::move(params.insertBeforeNodeId), &out_nodeId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.copyTo"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("nodeId"), out_nodeId);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct describeNodeParams : public v8_crdtp::DeserializableProtocolObject<describeNodeParams> {
    Maybe<int> nodeId;
    Maybe<int> backendNodeId;
    Maybe<String> objectId;
    Maybe<int> depth;
    Maybe<bool> pierce;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(describeNodeParams)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("backendNodeId", backendNodeId),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("depth", depth),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("nodeId", nodeId),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("objectId", objectId),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("pierce", pierce),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::describeNode(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    describeNodeParams params;
    describeNodeParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    std::unique_ptr<protocol::DOM::Node> out_node;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->describeNode(std::move(params.nodeId), std::move(params.backendNodeId), std::move(params.objectId), std::move(params.depth), std::move(params.pierce), &out_node);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.describeNode"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("node"), out_node);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::disable(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->disable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.disable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct discardSearchResultsParams : public v8_crdtp::DeserializableProtocolObject<discardSearchResultsParams> {
    String searchId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(discardSearchResultsParams)
    V8_CRDTP_DESERIALIZE_FIELD("searchId", searchId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::discardSearchResults(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    discardSearchResultsParams params;
    discardSearchResultsParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->discardSearchResults(params.searchId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.discardSearchResults"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::enable(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->enable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.enable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct focusParams : public v8_crdtp::DeserializableProtocolObject<focusParams> {
    Maybe<int> nodeId;
    Maybe<int> backendNodeId;
    Maybe<String> objectId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(focusParams)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("backendNodeId", backendNodeId),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("nodeId", nodeId),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("objectId", objectId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::focus(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    focusParams params;
    focusParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->focus(std::move(params.nodeId), std::move(params.backendNodeId), std::move(params.objectId));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.focus"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct getAttributesParams : public v8_crdtp::DeserializableProtocolObject<getAttributesParams> {
    int nodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(getAttributesParams)
    V8_CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getAttributes(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getAttributesParams params;
    getAttributesParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    std::unique_ptr<protocol::Array<String>> out_attributes;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getAttributes(params.nodeId, &out_attributes);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.getAttributes"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("attributes"), out_attributes);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getBoxModelParams : public v8_crdtp::DeserializableProtocolObject<getBoxModelParams> {
    Maybe<int> nodeId;
    Maybe<int> backendNodeId;
    Maybe<String> objectId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(getBoxModelParams)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("backendNodeId", backendNodeId),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("nodeId", nodeId),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("objectId", objectId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getBoxModel(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getBoxModelParams params;
    getBoxModelParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    std::unique_ptr<protocol::DOM::BoxModel> out_model;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getBoxModel(std::move(params.nodeId), std::move(params.backendNodeId), std::move(params.objectId), &out_model);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.getBoxModel"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("model"), out_model);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getContentQuadsParams : public v8_crdtp::DeserializableProtocolObject<getContentQuadsParams> {
    Maybe<int> nodeId;
    Maybe<int> backendNodeId;
    Maybe<String> objectId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(getContentQuadsParams)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("backendNodeId", backendNodeId),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("nodeId", nodeId),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("objectId", objectId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getContentQuads(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getContentQuadsParams params;
    getContentQuadsParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::Array<double>>> out_quads;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getContentQuads(std::move(params.nodeId), std::move(params.backendNodeId), std::move(params.objectId), &out_quads);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.getContentQuads"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("quads"), out_quads);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getDocumentParams : public v8_crdtp::DeserializableProtocolObject<getDocumentParams> {
    Maybe<int> depth;
    Maybe<bool> pierce;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(getDocumentParams)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("depth", depth),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("pierce", pierce),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getDocument(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getDocumentParams params;
    getDocumentParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    std::unique_ptr<protocol::DOM::Node> out_root;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getDocument(std::move(params.depth), std::move(params.pierce), &out_root);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.getDocument"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("root"), out_root);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getFlattenedDocumentParams : public v8_crdtp::DeserializableProtocolObject<getFlattenedDocumentParams> {
    Maybe<int> depth;
    Maybe<bool> pierce;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(getFlattenedDocumentParams)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("depth", depth),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("pierce", pierce),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getFlattenedDocument(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getFlattenedDocumentParams params;
    getFlattenedDocumentParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::DOM::Node>> out_nodes;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getFlattenedDocument(std::move(params.depth), std::move(params.pierce), &out_nodes);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.getFlattenedDocument"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("nodes"), out_nodes);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getNodeForLocationParams : public v8_crdtp::DeserializableProtocolObject<getNodeForLocationParams> {
    int x;
    int y;
    Maybe<bool> includeUserAgentShadowDOM;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(getNodeForLocationParams)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("includeUserAgentShadowDOM", includeUserAgentShadowDOM),
    V8_CRDTP_DESERIALIZE_FIELD("x", x),
    V8_CRDTP_DESERIALIZE_FIELD("y", y),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getNodeForLocation(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getNodeForLocationParams params;
    getNodeForLocationParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    int out_backendNodeId;
    Maybe<int> out_nodeId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getNodeForLocation(params.x, params.y, std::move(params.includeUserAgentShadowDOM), &out_backendNodeId, &out_nodeId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.getNodeForLocation"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("backendNodeId"), out_backendNodeId);
          serializer.AddField(v8_crdtp::MakeSpan("nodeId"), out_nodeId);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getOuterHTMLParams : public v8_crdtp::DeserializableProtocolObject<getOuterHTMLParams> {
    Maybe<int> nodeId;
    Maybe<int> backendNodeId;
    Maybe<String> objectId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(getOuterHTMLParams)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("backendNodeId", backendNodeId),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("nodeId", nodeId),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("objectId", objectId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getOuterHTML(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getOuterHTMLParams params;
    getOuterHTMLParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    String out_outerHTML;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getOuterHTML(std::move(params.nodeId), std::move(params.backendNodeId), std::move(params.objectId), &out_outerHTML);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.getOuterHTML"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("outerHTML"), out_outerHTML);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getRelayoutBoundaryParams : public v8_crdtp::DeserializableProtocolObject<getRelayoutBoundaryParams> {
    int nodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(getRelayoutBoundaryParams)
    V8_CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getRelayoutBoundary(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getRelayoutBoundaryParams params;
    getRelayoutBoundaryParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    int out_nodeId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getRelayoutBoundary(params.nodeId, &out_nodeId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.getRelayoutBoundary"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("nodeId"), out_nodeId);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getSearchResultsParams : public v8_crdtp::DeserializableProtocolObject<getSearchResultsParams> {
    String searchId;
    int fromIndex;
    int toIndex;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(getSearchResultsParams)
    V8_CRDTP_DESERIALIZE_FIELD("fromIndex", fromIndex),
    V8_CRDTP_DESERIALIZE_FIELD("searchId", searchId),
    V8_CRDTP_DESERIALIZE_FIELD("toIndex", toIndex),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getSearchResults(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getSearchResultsParams params;
    getSearchResultsParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    std::unique_ptr<protocol::Array<int>> out_nodeIds;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getSearchResults(params.searchId, params.fromIndex, params.toIndex, &out_nodeIds);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.getSearchResults"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("nodeIds"), out_nodeIds);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::markUndoableState(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->markUndoableState();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.markUndoableState"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct moveToParams : public v8_crdtp::DeserializableProtocolObject<moveToParams> {
    int nodeId;
    int targetNodeId;
    Maybe<int> insertBeforeNodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(moveToParams)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("insertBeforeNodeId", insertBeforeNodeId),
    V8_CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
    V8_CRDTP_DESERIALIZE_FIELD("targetNodeId", targetNodeId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::moveTo(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    moveToParams params;
    moveToParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    int out_nodeId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->moveTo(params.nodeId, params.targetNodeId, std::move(params.insertBeforeNodeId), &out_nodeId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.moveTo"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("nodeId"), out_nodeId);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct performSearchParams : public v8_crdtp::DeserializableProtocolObject<performSearchParams> {
    String query;
    Maybe<bool> includeUserAgentShadowDOM;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(performSearchParams)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("includeUserAgentShadowDOM", includeUserAgentShadowDOM),
    V8_CRDTP_DESERIALIZE_FIELD("query", query),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::performSearch(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    performSearchParams params;
    performSearchParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    String out_searchId;
    int out_resultCount;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->performSearch(params.query, std::move(params.includeUserAgentShadowDOM), &out_searchId, &out_resultCount);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.performSearch"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("searchId"), out_searchId);
          serializer.AddField(v8_crdtp::MakeSpan("resultCount"), out_resultCount);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct pushNodeByPathToFrontendParams : public v8_crdtp::DeserializableProtocolObject<pushNodeByPathToFrontendParams> {
    String path;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(pushNodeByPathToFrontendParams)
    V8_CRDTP_DESERIALIZE_FIELD("path", path),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::pushNodeByPathToFrontend(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    pushNodeByPathToFrontendParams params;
    pushNodeByPathToFrontendParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    int out_nodeId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->pushNodeByPathToFrontend(params.path, &out_nodeId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.pushNodeByPathToFrontend"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("nodeId"), out_nodeId);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct pushNodesByBackendIdsToFrontendParams : public v8_crdtp::DeserializableProtocolObject<pushNodesByBackendIdsToFrontendParams> {
    std::unique_ptr<protocol::Array<int>> backendNodeIds;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(pushNodesByBackendIdsToFrontendParams)
    V8_CRDTP_DESERIALIZE_FIELD("backendNodeIds", backendNodeIds),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::pushNodesByBackendIdsToFrontend(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    pushNodesByBackendIdsToFrontendParams params;
    pushNodesByBackendIdsToFrontendParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    std::unique_ptr<protocol::Array<int>> out_nodeIds;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->pushNodesByBackendIdsToFrontend(std::move(params.backendNodeIds), &out_nodeIds);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.pushNodesByBackendIdsToFrontend"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("nodeIds"), out_nodeIds);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct querySelectorParams : public v8_crdtp::DeserializableProtocolObject<querySelectorParams> {
    int nodeId;
    String selector;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(querySelectorParams)
    V8_CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
    V8_CRDTP_DESERIALIZE_FIELD("selector", selector),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::querySelector(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    querySelectorParams params;
    querySelectorParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    int out_nodeId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->querySelector(params.nodeId, params.selector, &out_nodeId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.querySelector"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("nodeId"), out_nodeId);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct querySelectorAllParams : public v8_crdtp::DeserializableProtocolObject<querySelectorAllParams> {
    int nodeId;
    String selector;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(querySelectorAllParams)
    V8_CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
    V8_CRDTP_DESERIALIZE_FIELD("selector", selector),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::querySelectorAll(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    querySelectorAllParams params;
    querySelectorAllParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    std::unique_ptr<protocol::Array<int>> out_nodeIds;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->querySelectorAll(params.nodeId, params.selector, &out_nodeIds);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.querySelectorAll"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("nodeIds"), out_nodeIds);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::redo(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->redo();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.redo"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct removeAttributeParams : public v8_crdtp::DeserializableProtocolObject<removeAttributeParams> {
    int nodeId;
    String name;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(removeAttributeParams)
    V8_CRDTP_DESERIALIZE_FIELD("name", name),
    V8_CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::removeAttribute(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    removeAttributeParams params;
    removeAttributeParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->removeAttribute(params.nodeId, params.name);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.removeAttribute"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct removeNodeParams : public v8_crdtp::DeserializableProtocolObject<removeNodeParams> {
    int nodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(removeNodeParams)
    V8_CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::removeNode(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    removeNodeParams params;
    removeNodeParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->removeNode(params.nodeId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.removeNode"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct requestChildNodesParams : public v8_crdtp::DeserializableProtocolObject<requestChildNodesParams> {
    int nodeId;
    Maybe<int> depth;
    Maybe<bool> pierce;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(requestChildNodesParams)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("depth", depth),
    V8_CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("pierce", pierce),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::requestChildNodes(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    requestChildNodesParams params;
    requestChildNodesParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->requestChildNodes(params.nodeId, std::move(params.depth), std::move(params.pierce));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.requestChildNodes"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct requestNodeParams : public v8_crdtp::DeserializableProtocolObject<requestNodeParams> {
    String objectId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(requestNodeParams)
    V8_CRDTP_DESERIALIZE_FIELD("objectId", objectId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::requestNode(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    requestNodeParams params;
    requestNodeParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    int out_nodeId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->requestNode(params.objectId, &out_nodeId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.requestNode"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("nodeId"), out_nodeId);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct resolveNodeParams : public v8_crdtp::DeserializableProtocolObject<resolveNodeParams> {
    Maybe<int> nodeId;
    Maybe<int> backendNodeId;
    Maybe<String> objectGroup;
    Maybe<int> executionContextId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(resolveNodeParams)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("backendNodeId", backendNodeId),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("executionContextId", executionContextId),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("nodeId", nodeId),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("objectGroup", objectGroup),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::resolveNode(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    resolveNodeParams params;
    resolveNodeParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    std::unique_ptr<protocol::Runtime::RemoteObject> out_object;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->resolveNode(std::move(params.nodeId), std::move(params.backendNodeId), std::move(params.objectGroup), std::move(params.executionContextId), &out_object);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.resolveNode"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("object"), out_object);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct setAttributeValueParams : public v8_crdtp::DeserializableProtocolObject<setAttributeValueParams> {
    int nodeId;
    String name;
    String value;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setAttributeValueParams)
    V8_CRDTP_DESERIALIZE_FIELD("name", name),
    V8_CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
    V8_CRDTP_DESERIALIZE_FIELD("value", value),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setAttributeValue(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setAttributeValueParams params;
    setAttributeValueParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setAttributeValue(params.nodeId, params.name, params.value);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.setAttributeValue"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setAttributesAsTextParams : public v8_crdtp::DeserializableProtocolObject<setAttributesAsTextParams> {
    int nodeId;
    String text;
    Maybe<String> name;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setAttributesAsTextParams)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("name", name),
    V8_CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
    V8_CRDTP_DESERIALIZE_FIELD("text", text),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setAttributesAsText(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setAttributesAsTextParams params;
    setAttributesAsTextParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setAttributesAsText(params.nodeId, params.text, std::move(params.name));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.setAttributesAsText"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setFileInputFilesParams : public v8_crdtp::DeserializableProtocolObject<setFileInputFilesParams> {
    std::unique_ptr<protocol::Array<String>> files;
    Maybe<int> nodeId;
    Maybe<int> backendNodeId;
    Maybe<String> objectId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setFileInputFilesParams)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("backendNodeId", backendNodeId),
    V8_CRDTP_DESERIALIZE_FIELD("files", files),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("nodeId", nodeId),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("objectId", objectId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setFileInputFiles(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setFileInputFilesParams params;
    setFileInputFilesParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setFileInputFiles(std::move(params.files), std::move(params.nodeId), std::move(params.backendNodeId), std::move(params.objectId));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.setFileInputFiles"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct getFileInfoParams : public v8_crdtp::DeserializableProtocolObject<getFileInfoParams> {
    String objectId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(getFileInfoParams)
    V8_CRDTP_DESERIALIZE_FIELD("objectId", objectId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getFileInfo(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getFileInfoParams params;
    getFileInfoParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    String out_path;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getFileInfo(params.objectId, &out_path);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.getFileInfo"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("path"), out_path);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct setInspectedNodeParams : public v8_crdtp::DeserializableProtocolObject<setInspectedNodeParams> {
    int nodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setInspectedNodeParams)
    V8_CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setInspectedNode(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setInspectedNodeParams params;
    setInspectedNodeParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setInspectedNode(params.nodeId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.setInspectedNode"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setNodeNameParams : public v8_crdtp::DeserializableProtocolObject<setNodeNameParams> {
    int nodeId;
    String name;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setNodeNameParams)
    V8_CRDTP_DESERIALIZE_FIELD("name", name),
    V8_CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setNodeName(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setNodeNameParams params;
    setNodeNameParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    int out_nodeId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setNodeName(params.nodeId, params.name, &out_nodeId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.setNodeName"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("nodeId"), out_nodeId);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct setNodeValueParams : public v8_crdtp::DeserializableProtocolObject<setNodeValueParams> {
    int nodeId;
    String value;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setNodeValueParams)
    V8_CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
    V8_CRDTP_DESERIALIZE_FIELD("value", value),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setNodeValue(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setNodeValueParams params;
    setNodeValueParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setNodeValue(params.nodeId, params.value);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.setNodeValue"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setOuterHTMLParams : public v8_crdtp::DeserializableProtocolObject<setOuterHTMLParams> {
    int nodeId;
    String outerHTML;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setOuterHTMLParams)
    V8_CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
    V8_CRDTP_DESERIALIZE_FIELD("outerHTML", outerHTML),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setOuterHTML(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setOuterHTMLParams params;
    setOuterHTMLParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setOuterHTML(params.nodeId, params.outerHTML);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.setOuterHTML"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::undo(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->undo();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.undo"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct getFrameOwnerParams : public v8_crdtp::DeserializableProtocolObject<getFrameOwnerParams> {
    String frameId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(getFrameOwnerParams)
    V8_CRDTP_DESERIALIZE_FIELD("frameId", frameId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getFrameOwner(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getFrameOwnerParams params;
    getFrameOwnerParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    int out_backendNodeId;
    Maybe<int> out_nodeId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getFrameOwner(params.frameId, &out_backendNodeId, &out_nodeId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("DOM.getFrameOwner"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("backendNodeId"), out_backendNodeId);
          serializer.AddField(v8_crdtp::MakeSpan("nodeId"), out_nodeId);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<v8_crdtp::span<uint8_t>, v8_crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<v8_crdtp::span<uint8_t>, v8_crdtp::span<uint8_t>>>{
          { v8_crdtp::SpanFrom("DOM.hideHighlight"), v8_crdtp::SpanFrom("Overlay.hideHighlight") },
          { v8_crdtp::SpanFrom("DOM.highlightNode"), v8_crdtp::SpanFrom("Overlay.highlightNode") },
          { v8_crdtp::SpanFrom("DOM.highlightRect"), v8_crdtp::SpanFrom("Overlay.highlightRect") },
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(v8_crdtp::SpanFrom("DOM"), SortedRedirects(), std::move(dispatcher));
}

} // DOM
} // namespace v8_inspector
} // namespace protocol
