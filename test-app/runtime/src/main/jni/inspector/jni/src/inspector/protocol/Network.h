// This file is generated by TypeBuilder_h.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef v8_inspector_protocol_Network_h
#define v8_inspector_protocol_Network_h

#include "src/inspector/protocol/Protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.
#include "src/inspector/protocol/Debugger.h"
#include "src/inspector/protocol/Runtime.h"
#include "src/inspector/protocol/Security.h"

namespace v8_inspector {
namespace protocol {
namespace Network {
using ResourceType = String;
using LoaderId = String;
using RequestId = String;
using InterceptionId = String;
using ErrorReason = String;
using TimeSinceEpoch = double;
using MonotonicTime = double;
using Headers = Object;
using ConnectionType = String;
using CookieSameSite = String;
class ResourceTiming;
using ResourcePriority = String;
class Request;
class SignedCertificateTimestamp;
class SecurityDetails;
using CertificateTransparencyCompliance = String;
using BlockedReason = String;
class Response;
class WebSocketRequest;
class WebSocketResponse;
class WebSocketFrame;
class Initiator;
class Cookie;
class AuthChallenge;
class SignedExchangeSignature;
class SignedExchangeHeader;
using SignedExchangeErrorField = String;
class SignedExchangeError;
class SignedExchangeInfo;

// ------------- Forward and enum declarations.

namespace ResourceTypeEnum {
 extern const char Document[];
 extern const char Stylesheet[];
 extern const char Image[];
 extern const char Media[];
 extern const char Font[];
 extern const char Script[];
 extern const char TextTrack[];
 extern const char XHR[];
 extern const char Fetch[];
 extern const char EventSource[];
 extern const char WebSocket[];
 extern const char Manifest[];
 extern const char SignedExchange[];
 extern const char Ping[];
 extern const char CSPViolationReport[];
 extern const char Other[];
} // namespace ResourceTypeEnum

namespace ErrorReasonEnum {
 extern const char Failed[];
 extern const char Aborted[];
 extern const char TimedOut[];
 extern const char AccessDenied[];
 extern const char ConnectionClosed[];
 extern const char ConnectionReset[];
 extern const char ConnectionRefused[];
 extern const char ConnectionAborted[];
 extern const char ConnectionFailed[];
 extern const char NameNotResolved[];
 extern const char InternetDisconnected[];
 extern const char AddressUnreachable[];
 extern const char BlockedByClient[];
 extern const char BlockedByResponse[];
} // namespace ErrorReasonEnum

namespace ConnectionTypeEnum {
 extern const char None[];
 extern const char Cellular2g[];
 extern const char Cellular3g[];
 extern const char Cellular4g[];
 extern const char Bluetooth[];
 extern const char Ethernet[];
 extern const char Wifi[];
 extern const char Wimax[];
 extern const char Other[];
} // namespace ConnectionTypeEnum

namespace CookieSameSiteEnum {
 extern const char Strict[];
 extern const char Lax[];
} // namespace CookieSameSiteEnum

namespace ResourcePriorityEnum {
 extern const char VeryLow[];
 extern const char Low[];
 extern const char Medium[];
 extern const char High[];
 extern const char VeryHigh[];
} // namespace ResourcePriorityEnum

namespace CertificateTransparencyComplianceEnum {
 extern const char Unknown[];
 extern const char NotCompliant[];
 extern const char Compliant[];
} // namespace CertificateTransparencyComplianceEnum

namespace BlockedReasonEnum {
 extern const char Other[];
 extern const char Csp[];
 extern const char MixedContent[];
 extern const char Origin[];
 extern const char Inspector[];
 extern const char SubresourceFilter[];
 extern const char ContentType[];
 extern const char CollapsedByClient[];
} // namespace BlockedReasonEnum

namespace SignedExchangeErrorFieldEnum {
 extern const char SignatureSig[];
 extern const char SignatureIntegrity[];
 extern const char SignatureCertUrl[];
 extern const char SignatureCertSha256[];
 extern const char SignatureValidityUrl[];
 extern const char SignatureTimestamps[];
} // namespace SignedExchangeErrorFieldEnum

// ------------- Type and builder declarations.

class  ResourceTiming : public ::v8_crdtp::ProtocolObject<ResourceTiming> {
public:
    ~ResourceTiming() override { }

    double getRequestTime() { return m_requestTime; }
    void setRequestTime(double value) { m_requestTime = value; }

    double getProxyStart() { return m_proxyStart; }
    void setProxyStart(double value) { m_proxyStart = value; }

    double getProxyEnd() { return m_proxyEnd; }
    void setProxyEnd(double value) { m_proxyEnd = value; }

    double getDnsStart() { return m_dnsStart; }
    void setDnsStart(double value) { m_dnsStart = value; }

    double getDnsEnd() { return m_dnsEnd; }
    void setDnsEnd(double value) { m_dnsEnd = value; }

    double getConnectStart() { return m_connectStart; }
    void setConnectStart(double value) { m_connectStart = value; }

    double getConnectEnd() { return m_connectEnd; }
    void setConnectEnd(double value) { m_connectEnd = value; }

    double getSslStart() { return m_sslStart; }
    void setSslStart(double value) { m_sslStart = value; }

    double getSslEnd() { return m_sslEnd; }
    void setSslEnd(double value) { m_sslEnd = value; }

    double getWorkerStart() { return m_workerStart; }
    void setWorkerStart(double value) { m_workerStart = value; }

    double getWorkerReady() { return m_workerReady; }
    void setWorkerReady(double value) { m_workerReady = value; }

    double getSendStart() { return m_sendStart; }
    void setSendStart(double value) { m_sendStart = value; }

    double getSendEnd() { return m_sendEnd; }
    void setSendEnd(double value) { m_sendEnd = value; }

    double getPushStart() { return m_pushStart; }
    void setPushStart(double value) { m_pushStart = value; }

    double getPushEnd() { return m_pushEnd; }
    void setPushEnd(double value) { m_pushEnd = value; }

    double getReceiveHeadersEnd() { return m_receiveHeadersEnd; }
    void setReceiveHeadersEnd(double value) { m_receiveHeadersEnd = value; }

    template<int STATE>
    class ResourceTimingBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            RequestTimeSet = 1 << 1,
            ProxyStartSet = 1 << 2,
            ProxyEndSet = 1 << 3,
            DnsStartSet = 1 << 4,
            DnsEndSet = 1 << 5,
            ConnectStartSet = 1 << 6,
            ConnectEndSet = 1 << 7,
            SslStartSet = 1 << 8,
            SslEndSet = 1 << 9,
            WorkerStartSet = 1 << 10,
            WorkerReadySet = 1 << 11,
            SendStartSet = 1 << 12,
            SendEndSet = 1 << 13,
            PushStartSet = 1 << 14,
            PushEndSet = 1 << 15,
            ReceiveHeadersEndSet = 1 << 16,
            AllFieldsSet = (RequestTimeSet | ProxyStartSet | ProxyEndSet | DnsStartSet | DnsEndSet | ConnectStartSet | ConnectEndSet | SslStartSet | SslEndSet | WorkerStartSet | WorkerReadySet | SendStartSet | SendEndSet | PushStartSet | PushEndSet | ReceiveHeadersEndSet | 0)};


        ResourceTimingBuilder<STATE | RequestTimeSet>& setRequestTime(double value)
        {
            static_assert(!(STATE & RequestTimeSet), "property requestTime should not be set yet");
            m_result->setRequestTime(value);
            return castState<RequestTimeSet>();
        }

        ResourceTimingBuilder<STATE | ProxyStartSet>& setProxyStart(double value)
        {
            static_assert(!(STATE & ProxyStartSet), "property proxyStart should not be set yet");
            m_result->setProxyStart(value);
            return castState<ProxyStartSet>();
        }

        ResourceTimingBuilder<STATE | ProxyEndSet>& setProxyEnd(double value)
        {
            static_assert(!(STATE & ProxyEndSet), "property proxyEnd should not be set yet");
            m_result->setProxyEnd(value);
            return castState<ProxyEndSet>();
        }

        ResourceTimingBuilder<STATE | DnsStartSet>& setDnsStart(double value)
        {
            static_assert(!(STATE & DnsStartSet), "property dnsStart should not be set yet");
            m_result->setDnsStart(value);
            return castState<DnsStartSet>();
        }

        ResourceTimingBuilder<STATE | DnsEndSet>& setDnsEnd(double value)
        {
            static_assert(!(STATE & DnsEndSet), "property dnsEnd should not be set yet");
            m_result->setDnsEnd(value);
            return castState<DnsEndSet>();
        }

        ResourceTimingBuilder<STATE | ConnectStartSet>& setConnectStart(double value)
        {
            static_assert(!(STATE & ConnectStartSet), "property connectStart should not be set yet");
            m_result->setConnectStart(value);
            return castState<ConnectStartSet>();
        }

        ResourceTimingBuilder<STATE | ConnectEndSet>& setConnectEnd(double value)
        {
            static_assert(!(STATE & ConnectEndSet), "property connectEnd should not be set yet");
            m_result->setConnectEnd(value);
            return castState<ConnectEndSet>();
        }

        ResourceTimingBuilder<STATE | SslStartSet>& setSslStart(double value)
        {
            static_assert(!(STATE & SslStartSet), "property sslStart should not be set yet");
            m_result->setSslStart(value);
            return castState<SslStartSet>();
        }

        ResourceTimingBuilder<STATE | SslEndSet>& setSslEnd(double value)
        {
            static_assert(!(STATE & SslEndSet), "property sslEnd should not be set yet");
            m_result->setSslEnd(value);
            return castState<SslEndSet>();
        }

        ResourceTimingBuilder<STATE | WorkerStartSet>& setWorkerStart(double value)
        {
            static_assert(!(STATE & WorkerStartSet), "property workerStart should not be set yet");
            m_result->setWorkerStart(value);
            return castState<WorkerStartSet>();
        }

        ResourceTimingBuilder<STATE | WorkerReadySet>& setWorkerReady(double value)
        {
            static_assert(!(STATE & WorkerReadySet), "property workerReady should not be set yet");
            m_result->setWorkerReady(value);
            return castState<WorkerReadySet>();
        }

        ResourceTimingBuilder<STATE | SendStartSet>& setSendStart(double value)
        {
            static_assert(!(STATE & SendStartSet), "property sendStart should not be set yet");
            m_result->setSendStart(value);
            return castState<SendStartSet>();
        }

        ResourceTimingBuilder<STATE | SendEndSet>& setSendEnd(double value)
        {
            static_assert(!(STATE & SendEndSet), "property sendEnd should not be set yet");
            m_result->setSendEnd(value);
            return castState<SendEndSet>();
        }

        ResourceTimingBuilder<STATE | PushStartSet>& setPushStart(double value)
        {
            static_assert(!(STATE & PushStartSet), "property pushStart should not be set yet");
            m_result->setPushStart(value);
            return castState<PushStartSet>();
        }

        ResourceTimingBuilder<STATE | PushEndSet>& setPushEnd(double value)
        {
            static_assert(!(STATE & PushEndSet), "property pushEnd should not be set yet");
            m_result->setPushEnd(value);
            return castState<PushEndSet>();
        }

        ResourceTimingBuilder<STATE | ReceiveHeadersEndSet>& setReceiveHeadersEnd(double value)
        {
            static_assert(!(STATE & ReceiveHeadersEndSet), "property receiveHeadersEnd should not be set yet");
            m_result->setReceiveHeadersEnd(value);
            return castState<ReceiveHeadersEndSet>();
        }

        std::unique_ptr<ResourceTiming> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ResourceTiming;
        ResourceTimingBuilder() : m_result(new ResourceTiming()) { }

        template<int STEP> ResourceTimingBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ResourceTimingBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::ResourceTiming> m_result;
    };

    static ResourceTimingBuilder<0> create()
    {
        return ResourceTimingBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    ResourceTiming()
    {
          m_requestTime = 0;
          m_proxyStart = 0;
          m_proxyEnd = 0;
          m_dnsStart = 0;
          m_dnsEnd = 0;
          m_connectStart = 0;
          m_connectEnd = 0;
          m_sslStart = 0;
          m_sslEnd = 0;
          m_workerStart = 0;
          m_workerReady = 0;
          m_sendStart = 0;
          m_sendEnd = 0;
          m_pushStart = 0;
          m_pushEnd = 0;
          m_receiveHeadersEnd = 0;
    }

    double m_requestTime;
    double m_proxyStart;
    double m_proxyEnd;
    double m_dnsStart;
    double m_dnsEnd;
    double m_connectStart;
    double m_connectEnd;
    double m_sslStart;
    double m_sslEnd;
    double m_workerStart;
    double m_workerReady;
    double m_sendStart;
    double m_sendEnd;
    double m_pushStart;
    double m_pushEnd;
    double m_receiveHeadersEnd;
};


class  Request : public ::v8_crdtp::ProtocolObject<Request> {
public:
    ~Request() override { }

    String getUrl() { return m_url; }
    void setUrl(const String& value) { m_url = value; }

    bool hasUrlFragment() { return m_urlFragment.isJust(); }
    String getUrlFragment(const String& defaultValue) { return m_urlFragment.isJust() ? m_urlFragment.fromJust() : defaultValue; }
    void setUrlFragment(const String& value) { m_urlFragment = value; }

    String getMethod() { return m_method; }
    void setMethod(const String& value) { m_method = value; }

    protocol::Network::Headers* getHeaders() { return m_headers.get(); }
    void setHeaders(std::unique_ptr<protocol::Network::Headers> value) { m_headers = std::move(value); }

    bool hasPostData() { return m_postData.isJust(); }
    String getPostData(const String& defaultValue) { return m_postData.isJust() ? m_postData.fromJust() : defaultValue; }
    void setPostData(const String& value) { m_postData = value; }

    bool hasHasPostData() { return m_hasPostData.isJust(); }
    bool getHasPostData(bool defaultValue) { return m_hasPostData.isJust() ? m_hasPostData.fromJust() : defaultValue; }
    void setHasPostData(bool value) { m_hasPostData = value; }

    bool hasMixedContentType() { return m_mixedContentType.isJust(); }
    String getMixedContentType(const String& defaultValue) { return m_mixedContentType.isJust() ? m_mixedContentType.fromJust() : defaultValue; }
    void setMixedContentType(const String& value) { m_mixedContentType = value; }

    String getInitialPriority() { return m_initialPriority; }
    void setInitialPriority(const String& value) { m_initialPriority = value; }

    struct  ReferrerPolicyEnum {
        static const char* UnsafeUrl;
        static const char* NoReferrerWhenDowngrade;
        static const char* NoReferrer;
        static const char* Origin;
        static const char* OriginWhenCrossOrigin;
        static const char* SameOrigin;
        static const char* StrictOrigin;
        static const char* StrictOriginWhenCrossOrigin;
    }; // ReferrerPolicyEnum

    String getReferrerPolicy() { return m_referrerPolicy; }
    void setReferrerPolicy(const String& value) { m_referrerPolicy = value; }

    bool hasIsLinkPreload() { return m_isLinkPreload.isJust(); }
    bool getIsLinkPreload(bool defaultValue) { return m_isLinkPreload.isJust() ? m_isLinkPreload.fromJust() : defaultValue; }
    void setIsLinkPreload(bool value) { m_isLinkPreload = value; }

    template<int STATE>
    class RequestBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            UrlSet = 1 << 1,
            MethodSet = 1 << 2,
            HeadersSet = 1 << 3,
            InitialPrioritySet = 1 << 4,
            ReferrerPolicySet = 1 << 5,
            AllFieldsSet = (UrlSet | MethodSet | HeadersSet | InitialPrioritySet | ReferrerPolicySet | 0)};


        RequestBuilder<STATE | UrlSet>& setUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->setUrl(value);
            return castState<UrlSet>();
        }

        RequestBuilder<STATE>& setUrlFragment(const String& value)
        {
            m_result->setUrlFragment(value);
            return *this;
        }

        RequestBuilder<STATE | MethodSet>& setMethod(const String& value)
        {
            static_assert(!(STATE & MethodSet), "property method should not be set yet");
            m_result->setMethod(value);
            return castState<MethodSet>();
        }

        RequestBuilder<STATE | HeadersSet>& setHeaders(std::unique_ptr<protocol::Network::Headers> value)
        {
            static_assert(!(STATE & HeadersSet), "property headers should not be set yet");
            m_result->setHeaders(std::move(value));
            return castState<HeadersSet>();
        }

        RequestBuilder<STATE>& setPostData(const String& value)
        {
            m_result->setPostData(value);
            return *this;
        }

        RequestBuilder<STATE>& setHasPostData(bool value)
        {
            m_result->setHasPostData(value);
            return *this;
        }

        RequestBuilder<STATE>& setMixedContentType(const String& value)
        {
            m_result->setMixedContentType(value);
            return *this;
        }

        RequestBuilder<STATE | InitialPrioritySet>& setInitialPriority(const String& value)
        {
            static_assert(!(STATE & InitialPrioritySet), "property initialPriority should not be set yet");
            m_result->setInitialPriority(value);
            return castState<InitialPrioritySet>();
        }

        RequestBuilder<STATE | ReferrerPolicySet>& setReferrerPolicy(const String& value)
        {
            static_assert(!(STATE & ReferrerPolicySet), "property referrerPolicy should not be set yet");
            m_result->setReferrerPolicy(value);
            return castState<ReferrerPolicySet>();
        }

        RequestBuilder<STATE>& setIsLinkPreload(bool value)
        {
            m_result->setIsLinkPreload(value);
            return *this;
        }

        std::unique_ptr<Request> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class Request;
        RequestBuilder() : m_result(new Request()) { }

        template<int STEP> RequestBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<RequestBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::Request> m_result;
    };

    static RequestBuilder<0> create()
    {
        return RequestBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    Request()
    {
    }

    String m_url;
    Maybe<String> m_urlFragment;
    String m_method;
    std::unique_ptr<protocol::Network::Headers> m_headers;
    Maybe<String> m_postData;
    Maybe<bool> m_hasPostData;
    Maybe<String> m_mixedContentType;
    String m_initialPriority;
    String m_referrerPolicy;
    Maybe<bool> m_isLinkPreload;
};


class  SignedCertificateTimestamp : public ::v8_crdtp::ProtocolObject<SignedCertificateTimestamp> {
public:
    ~SignedCertificateTimestamp() override { }

    String getStatus() { return m_status; }
    void setStatus(const String& value) { m_status = value; }

    String getOrigin() { return m_origin; }
    void setOrigin(const String& value) { m_origin = value; }

    String getLogDescription() { return m_logDescription; }
    void setLogDescription(const String& value) { m_logDescription = value; }

    String getLogId() { return m_logId; }
    void setLogId(const String& value) { m_logId = value; }

    double getTimestamp() { return m_timestamp; }
    void setTimestamp(double value) { m_timestamp = value; }

    String getHashAlgorithm() { return m_hashAlgorithm; }
    void setHashAlgorithm(const String& value) { m_hashAlgorithm = value; }

    String getSignatureAlgorithm() { return m_signatureAlgorithm; }
    void setSignatureAlgorithm(const String& value) { m_signatureAlgorithm = value; }

    String getSignatureData() { return m_signatureData; }
    void setSignatureData(const String& value) { m_signatureData = value; }

    template<int STATE>
    class SignedCertificateTimestampBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            StatusSet = 1 << 1,
            OriginSet = 1 << 2,
            LogDescriptionSet = 1 << 3,
            LogIdSet = 1 << 4,
            TimestampSet = 1 << 5,
            HashAlgorithmSet = 1 << 6,
            SignatureAlgorithmSet = 1 << 7,
            SignatureDataSet = 1 << 8,
            AllFieldsSet = (StatusSet | OriginSet | LogDescriptionSet | LogIdSet | TimestampSet | HashAlgorithmSet | SignatureAlgorithmSet | SignatureDataSet | 0)};


        SignedCertificateTimestampBuilder<STATE | StatusSet>& setStatus(const String& value)
        {
            static_assert(!(STATE & StatusSet), "property status should not be set yet");
            m_result->setStatus(value);
            return castState<StatusSet>();
        }

        SignedCertificateTimestampBuilder<STATE | OriginSet>& setOrigin(const String& value)
        {
            static_assert(!(STATE & OriginSet), "property origin should not be set yet");
            m_result->setOrigin(value);
            return castState<OriginSet>();
        }

        SignedCertificateTimestampBuilder<STATE | LogDescriptionSet>& setLogDescription(const String& value)
        {
            static_assert(!(STATE & LogDescriptionSet), "property logDescription should not be set yet");
            m_result->setLogDescription(value);
            return castState<LogDescriptionSet>();
        }

        SignedCertificateTimestampBuilder<STATE | LogIdSet>& setLogId(const String& value)
        {
            static_assert(!(STATE & LogIdSet), "property logId should not be set yet");
            m_result->setLogId(value);
            return castState<LogIdSet>();
        }

        SignedCertificateTimestampBuilder<STATE | TimestampSet>& setTimestamp(double value)
        {
            static_assert(!(STATE & TimestampSet), "property timestamp should not be set yet");
            m_result->setTimestamp(value);
            return castState<TimestampSet>();
        }

        SignedCertificateTimestampBuilder<STATE | HashAlgorithmSet>& setHashAlgorithm(const String& value)
        {
            static_assert(!(STATE & HashAlgorithmSet), "property hashAlgorithm should not be set yet");
            m_result->setHashAlgorithm(value);
            return castState<HashAlgorithmSet>();
        }

        SignedCertificateTimestampBuilder<STATE | SignatureAlgorithmSet>& setSignatureAlgorithm(const String& value)
        {
            static_assert(!(STATE & SignatureAlgorithmSet), "property signatureAlgorithm should not be set yet");
            m_result->setSignatureAlgorithm(value);
            return castState<SignatureAlgorithmSet>();
        }

        SignedCertificateTimestampBuilder<STATE | SignatureDataSet>& setSignatureData(const String& value)
        {
            static_assert(!(STATE & SignatureDataSet), "property signatureData should not be set yet");
            m_result->setSignatureData(value);
            return castState<SignatureDataSet>();
        }

        std::unique_ptr<SignedCertificateTimestamp> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SignedCertificateTimestamp;
        SignedCertificateTimestampBuilder() : m_result(new SignedCertificateTimestamp()) { }

        template<int STEP> SignedCertificateTimestampBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SignedCertificateTimestampBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::SignedCertificateTimestamp> m_result;
    };

    static SignedCertificateTimestampBuilder<0> create()
    {
        return SignedCertificateTimestampBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    SignedCertificateTimestamp()
    {
          m_timestamp = 0;
    }

    String m_status;
    String m_origin;
    String m_logDescription;
    String m_logId;
    double m_timestamp;
    String m_hashAlgorithm;
    String m_signatureAlgorithm;
    String m_signatureData;
};


class  SecurityDetails : public ::v8_crdtp::ProtocolObject<SecurityDetails> {
public:
    ~SecurityDetails() override { }

    String getProtocol() { return m_protocol; }
    void setProtocol(const String& value) { m_protocol = value; }

    String getKeyExchange() { return m_keyExchange; }
    void setKeyExchange(const String& value) { m_keyExchange = value; }

    bool hasKeyExchangeGroup() { return m_keyExchangeGroup.isJust(); }
    String getKeyExchangeGroup(const String& defaultValue) { return m_keyExchangeGroup.isJust() ? m_keyExchangeGroup.fromJust() : defaultValue; }
    void setKeyExchangeGroup(const String& value) { m_keyExchangeGroup = value; }

    String getCipher() { return m_cipher; }
    void setCipher(const String& value) { m_cipher = value; }

    bool hasMac() { return m_mac.isJust(); }
    String getMac(const String& defaultValue) { return m_mac.isJust() ? m_mac.fromJust() : defaultValue; }
    void setMac(const String& value) { m_mac = value; }

    int getCertificateId() { return m_certificateId; }
    void setCertificateId(int value) { m_certificateId = value; }

    String getSubjectName() { return m_subjectName; }
    void setSubjectName(const String& value) { m_subjectName = value; }

    protocol::Array<String>* getSanList() { return m_sanList.get(); }
    void setSanList(std::unique_ptr<protocol::Array<String>> value) { m_sanList = std::move(value); }

    String getIssuer() { return m_issuer; }
    void setIssuer(const String& value) { m_issuer = value; }

    double getValidFrom() { return m_validFrom; }
    void setValidFrom(double value) { m_validFrom = value; }

    double getValidTo() { return m_validTo; }
    void setValidTo(double value) { m_validTo = value; }

    protocol::Array<protocol::Network::SignedCertificateTimestamp>* getSignedCertificateTimestampList() { return m_signedCertificateTimestampList.get(); }
    void setSignedCertificateTimestampList(std::unique_ptr<protocol::Array<protocol::Network::SignedCertificateTimestamp>> value) { m_signedCertificateTimestampList = std::move(value); }

    String getCertificateTransparencyCompliance() { return m_certificateTransparencyCompliance; }
    void setCertificateTransparencyCompliance(const String& value) { m_certificateTransparencyCompliance = value; }

    template<int STATE>
    class SecurityDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ProtocolSet = 1 << 1,
            KeyExchangeSet = 1 << 2,
            CipherSet = 1 << 3,
            CertificateIdSet = 1 << 4,
            SubjectNameSet = 1 << 5,
            SanListSet = 1 << 6,
            IssuerSet = 1 << 7,
            ValidFromSet = 1 << 8,
            ValidToSet = 1 << 9,
            SignedCertificateTimestampListSet = 1 << 10,
            CertificateTransparencyComplianceSet = 1 << 11,
            AllFieldsSet = (ProtocolSet | KeyExchangeSet | CipherSet | CertificateIdSet | SubjectNameSet | SanListSet | IssuerSet | ValidFromSet | ValidToSet | SignedCertificateTimestampListSet | CertificateTransparencyComplianceSet | 0)};


        SecurityDetailsBuilder<STATE | ProtocolSet>& setProtocol(const String& value)
        {
            static_assert(!(STATE & ProtocolSet), "property protocol should not be set yet");
            m_result->setProtocol(value);
            return castState<ProtocolSet>();
        }

        SecurityDetailsBuilder<STATE | KeyExchangeSet>& setKeyExchange(const String& value)
        {
            static_assert(!(STATE & KeyExchangeSet), "property keyExchange should not be set yet");
            m_result->setKeyExchange(value);
            return castState<KeyExchangeSet>();
        }

        SecurityDetailsBuilder<STATE>& setKeyExchangeGroup(const String& value)
        {
            m_result->setKeyExchangeGroup(value);
            return *this;
        }

        SecurityDetailsBuilder<STATE | CipherSet>& setCipher(const String& value)
        {
            static_assert(!(STATE & CipherSet), "property cipher should not be set yet");
            m_result->setCipher(value);
            return castState<CipherSet>();
        }

        SecurityDetailsBuilder<STATE>& setMac(const String& value)
        {
            m_result->setMac(value);
            return *this;
        }

        SecurityDetailsBuilder<STATE | CertificateIdSet>& setCertificateId(int value)
        {
            static_assert(!(STATE & CertificateIdSet), "property certificateId should not be set yet");
            m_result->setCertificateId(value);
            return castState<CertificateIdSet>();
        }

        SecurityDetailsBuilder<STATE | SubjectNameSet>& setSubjectName(const String& value)
        {
            static_assert(!(STATE & SubjectNameSet), "property subjectName should not be set yet");
            m_result->setSubjectName(value);
            return castState<SubjectNameSet>();
        }

        SecurityDetailsBuilder<STATE | SanListSet>& setSanList(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & SanListSet), "property sanList should not be set yet");
            m_result->setSanList(std::move(value));
            return castState<SanListSet>();
        }

        SecurityDetailsBuilder<STATE | IssuerSet>& setIssuer(const String& value)
        {
            static_assert(!(STATE & IssuerSet), "property issuer should not be set yet");
            m_result->setIssuer(value);
            return castState<IssuerSet>();
        }

        SecurityDetailsBuilder<STATE | ValidFromSet>& setValidFrom(double value)
        {
            static_assert(!(STATE & ValidFromSet), "property validFrom should not be set yet");
            m_result->setValidFrom(value);
            return castState<ValidFromSet>();
        }

        SecurityDetailsBuilder<STATE | ValidToSet>& setValidTo(double value)
        {
            static_assert(!(STATE & ValidToSet), "property validTo should not be set yet");
            m_result->setValidTo(value);
            return castState<ValidToSet>();
        }

        SecurityDetailsBuilder<STATE | SignedCertificateTimestampListSet>& setSignedCertificateTimestampList(std::unique_ptr<protocol::Array<protocol::Network::SignedCertificateTimestamp>> value)
        {
            static_assert(!(STATE & SignedCertificateTimestampListSet), "property signedCertificateTimestampList should not be set yet");
            m_result->setSignedCertificateTimestampList(std::move(value));
            return castState<SignedCertificateTimestampListSet>();
        }

        SecurityDetailsBuilder<STATE | CertificateTransparencyComplianceSet>& setCertificateTransparencyCompliance(const String& value)
        {
            static_assert(!(STATE & CertificateTransparencyComplianceSet), "property certificateTransparencyCompliance should not be set yet");
            m_result->setCertificateTransparencyCompliance(value);
            return castState<CertificateTransparencyComplianceSet>();
        }

        std::unique_ptr<SecurityDetails> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SecurityDetails;
        SecurityDetailsBuilder() : m_result(new SecurityDetails()) { }

        template<int STEP> SecurityDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SecurityDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::SecurityDetails> m_result;
    };

    static SecurityDetailsBuilder<0> create()
    {
        return SecurityDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    SecurityDetails()
    {
          m_certificateId = 0;
          m_validFrom = 0;
          m_validTo = 0;
    }

    String m_protocol;
    String m_keyExchange;
    Maybe<String> m_keyExchangeGroup;
    String m_cipher;
    Maybe<String> m_mac;
    int m_certificateId;
    String m_subjectName;
    std::unique_ptr<protocol::Array<String>> m_sanList;
    String m_issuer;
    double m_validFrom;
    double m_validTo;
    std::unique_ptr<protocol::Array<protocol::Network::SignedCertificateTimestamp>> m_signedCertificateTimestampList;
    String m_certificateTransparencyCompliance;
};


class  Response : public ::v8_crdtp::ProtocolObject<Response> {
public:
    ~Response() override { }

    String getUrl() { return m_url; }
    void setUrl(const String& value) { m_url = value; }

    int getStatus() { return m_status; }
    void setStatus(int value) { m_status = value; }

    String getStatusText() { return m_statusText; }
    void setStatusText(const String& value) { m_statusText = value; }

    protocol::Network::Headers* getHeaders() { return m_headers.get(); }
    void setHeaders(std::unique_ptr<protocol::Network::Headers> value) { m_headers = std::move(value); }

    bool hasHeadersText() { return m_headersText.isJust(); }
    String getHeadersText(const String& defaultValue) { return m_headersText.isJust() ? m_headersText.fromJust() : defaultValue; }
    void setHeadersText(const String& value) { m_headersText = value; }

    String getMimeType() { return m_mimeType; }
    void setMimeType(const String& value) { m_mimeType = value; }

    bool hasRequestHeaders() { return m_requestHeaders.isJust(); }
    protocol::Network::Headers* getRequestHeaders(protocol::Network::Headers* defaultValue) { return m_requestHeaders.isJust() ? m_requestHeaders.fromJust() : defaultValue; }
    void setRequestHeaders(std::unique_ptr<protocol::Network::Headers> value) { m_requestHeaders = std::move(value); }

    bool hasRequestHeadersText() { return m_requestHeadersText.isJust(); }
    String getRequestHeadersText(const String& defaultValue) { return m_requestHeadersText.isJust() ? m_requestHeadersText.fromJust() : defaultValue; }
    void setRequestHeadersText(const String& value) { m_requestHeadersText = value; }

    bool getConnectionReused() { return m_connectionReused; }
    void setConnectionReused(bool value) { m_connectionReused = value; }

    double getConnectionId() { return m_connectionId; }
    void setConnectionId(double value) { m_connectionId = value; }

    bool hasRemoteIPAddress() { return m_remoteIPAddress.isJust(); }
    String getRemoteIPAddress(const String& defaultValue) { return m_remoteIPAddress.isJust() ? m_remoteIPAddress.fromJust() : defaultValue; }
    void setRemoteIPAddress(const String& value) { m_remoteIPAddress = value; }

    bool hasRemotePort() { return m_remotePort.isJust(); }
    int getRemotePort(int defaultValue) { return m_remotePort.isJust() ? m_remotePort.fromJust() : defaultValue; }
    void setRemotePort(int value) { m_remotePort = value; }

    bool hasFromDiskCache() { return m_fromDiskCache.isJust(); }
    bool getFromDiskCache(bool defaultValue) { return m_fromDiskCache.isJust() ? m_fromDiskCache.fromJust() : defaultValue; }
    void setFromDiskCache(bool value) { m_fromDiskCache = value; }

    bool hasFromServiceWorker() { return m_fromServiceWorker.isJust(); }
    bool getFromServiceWorker(bool defaultValue) { return m_fromServiceWorker.isJust() ? m_fromServiceWorker.fromJust() : defaultValue; }
    void setFromServiceWorker(bool value) { m_fromServiceWorker = value; }

    double getEncodedDataLength() { return m_encodedDataLength; }
    void setEncodedDataLength(double value) { m_encodedDataLength = value; }

    bool hasTiming() { return m_timing.isJust(); }
    protocol::Network::ResourceTiming* getTiming(protocol::Network::ResourceTiming* defaultValue) { return m_timing.isJust() ? m_timing.fromJust() : defaultValue; }
    void setTiming(std::unique_ptr<protocol::Network::ResourceTiming> value) { m_timing = std::move(value); }

    bool hasProtocol() { return m_protocol.isJust(); }
    String getProtocol(const String& defaultValue) { return m_protocol.isJust() ? m_protocol.fromJust() : defaultValue; }
    void setProtocol(const String& value) { m_protocol = value; }

    String getSecurityState() { return m_securityState; }
    void setSecurityState(const String& value) { m_securityState = value; }

    bool hasSecurityDetails() { return m_securityDetails.isJust(); }
    protocol::Network::SecurityDetails* getSecurityDetails(protocol::Network::SecurityDetails* defaultValue) { return m_securityDetails.isJust() ? m_securityDetails.fromJust() : defaultValue; }
    void setSecurityDetails(std::unique_ptr<protocol::Network::SecurityDetails> value) { m_securityDetails = std::move(value); }

    template<int STATE>
    class ResponseBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            UrlSet = 1 << 1,
            StatusSet = 1 << 2,
            StatusTextSet = 1 << 3,
            HeadersSet = 1 << 4,
            MimeTypeSet = 1 << 5,
            ConnectionReusedSet = 1 << 6,
            ConnectionIdSet = 1 << 7,
            EncodedDataLengthSet = 1 << 8,
            SecurityStateSet = 1 << 9,
            AllFieldsSet = (UrlSet | StatusSet | StatusTextSet | HeadersSet | MimeTypeSet | ConnectionReusedSet | ConnectionIdSet | EncodedDataLengthSet | SecurityStateSet | 0)};


        ResponseBuilder<STATE | UrlSet>& setUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->setUrl(value);
            return castState<UrlSet>();
        }

        ResponseBuilder<STATE | StatusSet>& setStatus(int value)
        {
            static_assert(!(STATE & StatusSet), "property status should not be set yet");
            m_result->setStatus(value);
            return castState<StatusSet>();
        }

        ResponseBuilder<STATE | StatusTextSet>& setStatusText(const String& value)
        {
            static_assert(!(STATE & StatusTextSet), "property statusText should not be set yet");
            m_result->setStatusText(value);
            return castState<StatusTextSet>();
        }

        ResponseBuilder<STATE | HeadersSet>& setHeaders(std::unique_ptr<protocol::Network::Headers> value)
        {
            static_assert(!(STATE & HeadersSet), "property headers should not be set yet");
            m_result->setHeaders(std::move(value));
            return castState<HeadersSet>();
        }

        ResponseBuilder<STATE>& setHeadersText(const String& value)
        {
            m_result->setHeadersText(value);
            return *this;
        }

        ResponseBuilder<STATE | MimeTypeSet>& setMimeType(const String& value)
        {
            static_assert(!(STATE & MimeTypeSet), "property mimeType should not be set yet");
            m_result->setMimeType(value);
            return castState<MimeTypeSet>();
        }

        ResponseBuilder<STATE>& setRequestHeaders(std::unique_ptr<protocol::Network::Headers> value)
        {
            m_result->setRequestHeaders(std::move(value));
            return *this;
        }

        ResponseBuilder<STATE>& setRequestHeadersText(const String& value)
        {
            m_result->setRequestHeadersText(value);
            return *this;
        }

        ResponseBuilder<STATE | ConnectionReusedSet>& setConnectionReused(bool value)
        {
            static_assert(!(STATE & ConnectionReusedSet), "property connectionReused should not be set yet");
            m_result->setConnectionReused(value);
            return castState<ConnectionReusedSet>();
        }

        ResponseBuilder<STATE | ConnectionIdSet>& setConnectionId(double value)
        {
            static_assert(!(STATE & ConnectionIdSet), "property connectionId should not be set yet");
            m_result->setConnectionId(value);
            return castState<ConnectionIdSet>();
        }

        ResponseBuilder<STATE>& setRemoteIPAddress(const String& value)
        {
            m_result->setRemoteIPAddress(value);
            return *this;
        }

        ResponseBuilder<STATE>& setRemotePort(int value)
        {
            m_result->setRemotePort(value);
            return *this;
        }

        ResponseBuilder<STATE>& setFromDiskCache(bool value)
        {
            m_result->setFromDiskCache(value);
            return *this;
        }

        ResponseBuilder<STATE>& setFromServiceWorker(bool value)
        {
            m_result->setFromServiceWorker(value);
            return *this;
        }

        ResponseBuilder<STATE | EncodedDataLengthSet>& setEncodedDataLength(double value)
        {
            static_assert(!(STATE & EncodedDataLengthSet), "property encodedDataLength should not be set yet");
            m_result->setEncodedDataLength(value);
            return castState<EncodedDataLengthSet>();
        }

        ResponseBuilder<STATE>& setTiming(std::unique_ptr<protocol::Network::ResourceTiming> value)
        {
            m_result->setTiming(std::move(value));
            return *this;
        }

        ResponseBuilder<STATE>& setProtocol(const String& value)
        {
            m_result->setProtocol(value);
            return *this;
        }

        ResponseBuilder<STATE | SecurityStateSet>& setSecurityState(const String& value)
        {
            static_assert(!(STATE & SecurityStateSet), "property securityState should not be set yet");
            m_result->setSecurityState(value);
            return castState<SecurityStateSet>();
        }

        ResponseBuilder<STATE>& setSecurityDetails(std::unique_ptr<protocol::Network::SecurityDetails> value)
        {
            m_result->setSecurityDetails(std::move(value));
            return *this;
        }

        std::unique_ptr<Response> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class Response;
        ResponseBuilder() : m_result(new Response()) { }

        template<int STEP> ResponseBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ResponseBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::Response> m_result;
    };

    static ResponseBuilder<0> create()
    {
        return ResponseBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    Response()
    {
          m_status = 0;
          m_connectionReused = false;
          m_connectionId = 0;
          m_encodedDataLength = 0;
    }

    String m_url;
    int m_status;
    String m_statusText;
    std::unique_ptr<protocol::Network::Headers> m_headers;
    Maybe<String> m_headersText;
    String m_mimeType;
    Maybe<protocol::Network::Headers> m_requestHeaders;
    Maybe<String> m_requestHeadersText;
    bool m_connectionReused;
    double m_connectionId;
    Maybe<String> m_remoteIPAddress;
    Maybe<int> m_remotePort;
    Maybe<bool> m_fromDiskCache;
    Maybe<bool> m_fromServiceWorker;
    double m_encodedDataLength;
    Maybe<protocol::Network::ResourceTiming> m_timing;
    Maybe<String> m_protocol;
    String m_securityState;
    Maybe<protocol::Network::SecurityDetails> m_securityDetails;
};


class  WebSocketRequest : public ::v8_crdtp::ProtocolObject<WebSocketRequest> {
public:
    ~WebSocketRequest() override { }

    protocol::Network::Headers* getHeaders() { return m_headers.get(); }
    void setHeaders(std::unique_ptr<protocol::Network::Headers> value) { m_headers = std::move(value); }

    template<int STATE>
    class WebSocketRequestBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            HeadersSet = 1 << 1,
            AllFieldsSet = (HeadersSet | 0)};


        WebSocketRequestBuilder<STATE | HeadersSet>& setHeaders(std::unique_ptr<protocol::Network::Headers> value)
        {
            static_assert(!(STATE & HeadersSet), "property headers should not be set yet");
            m_result->setHeaders(std::move(value));
            return castState<HeadersSet>();
        }

        std::unique_ptr<WebSocketRequest> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class WebSocketRequest;
        WebSocketRequestBuilder() : m_result(new WebSocketRequest()) { }

        template<int STEP> WebSocketRequestBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<WebSocketRequestBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::WebSocketRequest> m_result;
    };

    static WebSocketRequestBuilder<0> create()
    {
        return WebSocketRequestBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    WebSocketRequest()
    {
    }

    std::unique_ptr<protocol::Network::Headers> m_headers;
};


class  WebSocketResponse : public ::v8_crdtp::ProtocolObject<WebSocketResponse> {
public:
    ~WebSocketResponse() override { }

    int getStatus() { return m_status; }
    void setStatus(int value) { m_status = value; }

    String getStatusText() { return m_statusText; }
    void setStatusText(const String& value) { m_statusText = value; }

    protocol::Network::Headers* getHeaders() { return m_headers.get(); }
    void setHeaders(std::unique_ptr<protocol::Network::Headers> value) { m_headers = std::move(value); }

    bool hasHeadersText() { return m_headersText.isJust(); }
    String getHeadersText(const String& defaultValue) { return m_headersText.isJust() ? m_headersText.fromJust() : defaultValue; }
    void setHeadersText(const String& value) { m_headersText = value; }

    bool hasRequestHeaders() { return m_requestHeaders.isJust(); }
    protocol::Network::Headers* getRequestHeaders(protocol::Network::Headers* defaultValue) { return m_requestHeaders.isJust() ? m_requestHeaders.fromJust() : defaultValue; }
    void setRequestHeaders(std::unique_ptr<protocol::Network::Headers> value) { m_requestHeaders = std::move(value); }

    bool hasRequestHeadersText() { return m_requestHeadersText.isJust(); }
    String getRequestHeadersText(const String& defaultValue) { return m_requestHeadersText.isJust() ? m_requestHeadersText.fromJust() : defaultValue; }
    void setRequestHeadersText(const String& value) { m_requestHeadersText = value; }

    template<int STATE>
    class WebSocketResponseBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            StatusSet = 1 << 1,
            StatusTextSet = 1 << 2,
            HeadersSet = 1 << 3,
            AllFieldsSet = (StatusSet | StatusTextSet | HeadersSet | 0)};


        WebSocketResponseBuilder<STATE | StatusSet>& setStatus(int value)
        {
            static_assert(!(STATE & StatusSet), "property status should not be set yet");
            m_result->setStatus(value);
            return castState<StatusSet>();
        }

        WebSocketResponseBuilder<STATE | StatusTextSet>& setStatusText(const String& value)
        {
            static_assert(!(STATE & StatusTextSet), "property statusText should not be set yet");
            m_result->setStatusText(value);
            return castState<StatusTextSet>();
        }

        WebSocketResponseBuilder<STATE | HeadersSet>& setHeaders(std::unique_ptr<protocol::Network::Headers> value)
        {
            static_assert(!(STATE & HeadersSet), "property headers should not be set yet");
            m_result->setHeaders(std::move(value));
            return castState<HeadersSet>();
        }

        WebSocketResponseBuilder<STATE>& setHeadersText(const String& value)
        {
            m_result->setHeadersText(value);
            return *this;
        }

        WebSocketResponseBuilder<STATE>& setRequestHeaders(std::unique_ptr<protocol::Network::Headers> value)
        {
            m_result->setRequestHeaders(std::move(value));
            return *this;
        }

        WebSocketResponseBuilder<STATE>& setRequestHeadersText(const String& value)
        {
            m_result->setRequestHeadersText(value);
            return *this;
        }

        std::unique_ptr<WebSocketResponse> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class WebSocketResponse;
        WebSocketResponseBuilder() : m_result(new WebSocketResponse()) { }

        template<int STEP> WebSocketResponseBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<WebSocketResponseBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::WebSocketResponse> m_result;
    };

    static WebSocketResponseBuilder<0> create()
    {
        return WebSocketResponseBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    WebSocketResponse()
    {
          m_status = 0;
    }

    int m_status;
    String m_statusText;
    std::unique_ptr<protocol::Network::Headers> m_headers;
    Maybe<String> m_headersText;
    Maybe<protocol::Network::Headers> m_requestHeaders;
    Maybe<String> m_requestHeadersText;
};


class  WebSocketFrame : public ::v8_crdtp::ProtocolObject<WebSocketFrame> {
public:
    ~WebSocketFrame() override { }

    double getOpcode() { return m_opcode; }
    void setOpcode(double value) { m_opcode = value; }

    bool getMask() { return m_mask; }
    void setMask(bool value) { m_mask = value; }

    String getPayloadData() { return m_payloadData; }
    void setPayloadData(const String& value) { m_payloadData = value; }

    template<int STATE>
    class WebSocketFrameBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            OpcodeSet = 1 << 1,
            MaskSet = 1 << 2,
            PayloadDataSet = 1 << 3,
            AllFieldsSet = (OpcodeSet | MaskSet | PayloadDataSet | 0)};


        WebSocketFrameBuilder<STATE | OpcodeSet>& setOpcode(double value)
        {
            static_assert(!(STATE & OpcodeSet), "property opcode should not be set yet");
            m_result->setOpcode(value);
            return castState<OpcodeSet>();
        }

        WebSocketFrameBuilder<STATE | MaskSet>& setMask(bool value)
        {
            static_assert(!(STATE & MaskSet), "property mask should not be set yet");
            m_result->setMask(value);
            return castState<MaskSet>();
        }

        WebSocketFrameBuilder<STATE | PayloadDataSet>& setPayloadData(const String& value)
        {
            static_assert(!(STATE & PayloadDataSet), "property payloadData should not be set yet");
            m_result->setPayloadData(value);
            return castState<PayloadDataSet>();
        }

        std::unique_ptr<WebSocketFrame> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class WebSocketFrame;
        WebSocketFrameBuilder() : m_result(new WebSocketFrame()) { }

        template<int STEP> WebSocketFrameBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<WebSocketFrameBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::WebSocketFrame> m_result;
    };

    static WebSocketFrameBuilder<0> create()
    {
        return WebSocketFrameBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    WebSocketFrame()
    {
          m_opcode = 0;
          m_mask = false;
    }

    double m_opcode;
    bool m_mask;
    String m_payloadData;
};


class  Initiator : public ::v8_crdtp::ProtocolObject<Initiator> {
public:
    ~Initiator() override { }

    struct  TypeEnum {
        static const char* Parser;
        static const char* Script;
        static const char* Preload;
        static const char* SignedExchange;
        static const char* Other;
    }; // TypeEnum

    String getType() { return m_type; }
    void setType(const String& value) { m_type = value; }

    bool hasStack() { return m_stack.isJust(); }
    protocol::Runtime::StackTrace* getStack(protocol::Runtime::StackTrace* defaultValue) { return m_stack.isJust() ? m_stack.fromJust() : defaultValue; }
    void setStack(std::unique_ptr<protocol::Runtime::StackTrace> value) { m_stack = std::move(value); }

    bool hasUrl() { return m_url.isJust(); }
    String getUrl(const String& defaultValue) { return m_url.isJust() ? m_url.fromJust() : defaultValue; }
    void setUrl(const String& value) { m_url = value; }

    bool hasLineNumber() { return m_lineNumber.isJust(); }
    double getLineNumber(double defaultValue) { return m_lineNumber.isJust() ? m_lineNumber.fromJust() : defaultValue; }
    void setLineNumber(double value) { m_lineNumber = value; }

    template<int STATE>
    class InitiatorBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            TypeSet = 1 << 1,
            AllFieldsSet = (TypeSet | 0)};


        InitiatorBuilder<STATE | TypeSet>& setType(const String& value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setType(value);
            return castState<TypeSet>();
        }

        InitiatorBuilder<STATE>& setStack(std::unique_ptr<protocol::Runtime::StackTrace> value)
        {
            m_result->setStack(std::move(value));
            return *this;
        }

        InitiatorBuilder<STATE>& setUrl(const String& value)
        {
            m_result->setUrl(value);
            return *this;
        }

        InitiatorBuilder<STATE>& setLineNumber(double value)
        {
            m_result->setLineNumber(value);
            return *this;
        }

        std::unique_ptr<Initiator> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class Initiator;
        InitiatorBuilder() : m_result(new Initiator()) { }

        template<int STEP> InitiatorBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<InitiatorBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::Initiator> m_result;
    };

    static InitiatorBuilder<0> create()
    {
        return InitiatorBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    Initiator()
    {
    }

    String m_type;
    Maybe<protocol::Runtime::StackTrace> m_stack;
    Maybe<String> m_url;
    Maybe<double> m_lineNumber;
};


class  Cookie : public ::v8_crdtp::ProtocolObject<Cookie> {
public:
    ~Cookie() override { }

    String getName() { return m_name; }
    void setName(const String& value) { m_name = value; }

    String getValue() { return m_value; }
    void setValue(const String& value) { m_value = value; }

    String getDomain() { return m_domain; }
    void setDomain(const String& value) { m_domain = value; }

    String getPath() { return m_path; }
    void setPath(const String& value) { m_path = value; }

    double getExpires() { return m_expires; }
    void setExpires(double value) { m_expires = value; }

    int getSize() { return m_size; }
    void setSize(int value) { m_size = value; }

    bool getHttpOnly() { return m_httpOnly; }
    void setHttpOnly(bool value) { m_httpOnly = value; }

    bool getSecure() { return m_secure; }
    void setSecure(bool value) { m_secure = value; }

    bool getSession() { return m_session; }
    void setSession(bool value) { m_session = value; }

    bool hasSameSite() { return m_sameSite.isJust(); }
    String getSameSite(const String& defaultValue) { return m_sameSite.isJust() ? m_sameSite.fromJust() : defaultValue; }
    void setSameSite(const String& value) { m_sameSite = value; }

    template<int STATE>
    class CookieBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            NameSet = 1 << 1,
            ValueSet = 1 << 2,
            DomainSet = 1 << 3,
            PathSet = 1 << 4,
            ExpiresSet = 1 << 5,
            SizeSet = 1 << 6,
            HttpOnlySet = 1 << 7,
            SecureSet = 1 << 8,
            SessionSet = 1 << 9,
            AllFieldsSet = (NameSet | ValueSet | DomainSet | PathSet | ExpiresSet | SizeSet | HttpOnlySet | SecureSet | SessionSet | 0)};


        CookieBuilder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setName(value);
            return castState<NameSet>();
        }

        CookieBuilder<STATE | ValueSet>& setValue(const String& value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setValue(value);
            return castState<ValueSet>();
        }

        CookieBuilder<STATE | DomainSet>& setDomain(const String& value)
        {
            static_assert(!(STATE & DomainSet), "property domain should not be set yet");
            m_result->setDomain(value);
            return castState<DomainSet>();
        }

        CookieBuilder<STATE | PathSet>& setPath(const String& value)
        {
            static_assert(!(STATE & PathSet), "property path should not be set yet");
            m_result->setPath(value);
            return castState<PathSet>();
        }

        CookieBuilder<STATE | ExpiresSet>& setExpires(double value)
        {
            static_assert(!(STATE & ExpiresSet), "property expires should not be set yet");
            m_result->setExpires(value);
            return castState<ExpiresSet>();
        }

        CookieBuilder<STATE | SizeSet>& setSize(int value)
        {
            static_assert(!(STATE & SizeSet), "property size should not be set yet");
            m_result->setSize(value);
            return castState<SizeSet>();
        }

        CookieBuilder<STATE | HttpOnlySet>& setHttpOnly(bool value)
        {
            static_assert(!(STATE & HttpOnlySet), "property httpOnly should not be set yet");
            m_result->setHttpOnly(value);
            return castState<HttpOnlySet>();
        }

        CookieBuilder<STATE | SecureSet>& setSecure(bool value)
        {
            static_assert(!(STATE & SecureSet), "property secure should not be set yet");
            m_result->setSecure(value);
            return castState<SecureSet>();
        }

        CookieBuilder<STATE | SessionSet>& setSession(bool value)
        {
            static_assert(!(STATE & SessionSet), "property session should not be set yet");
            m_result->setSession(value);
            return castState<SessionSet>();
        }

        CookieBuilder<STATE>& setSameSite(const String& value)
        {
            m_result->setSameSite(value);
            return *this;
        }

        std::unique_ptr<Cookie> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class Cookie;
        CookieBuilder() : m_result(new Cookie()) { }

        template<int STEP> CookieBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<CookieBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::Cookie> m_result;
    };

    static CookieBuilder<0> create()
    {
        return CookieBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    Cookie()
    {
          m_expires = 0;
          m_size = 0;
          m_httpOnly = false;
          m_secure = false;
          m_session = false;
    }

    String m_name;
    String m_value;
    String m_domain;
    String m_path;
    double m_expires;
    int m_size;
    bool m_httpOnly;
    bool m_secure;
    bool m_session;
    Maybe<String> m_sameSite;
};


class  AuthChallenge : public ::v8_crdtp::ProtocolObject<AuthChallenge> {
public:
    ~AuthChallenge() override { }

    struct  SourceEnum {
        static const char* Server;
        static const char* Proxy;
    }; // SourceEnum

    bool hasSource() { return m_source.isJust(); }
    String getSource(const String& defaultValue) { return m_source.isJust() ? m_source.fromJust() : defaultValue; }
    void setSource(const String& value) { m_source = value; }

    String getOrigin() { return m_origin; }
    void setOrigin(const String& value) { m_origin = value; }

    String getScheme() { return m_scheme; }
    void setScheme(const String& value) { m_scheme = value; }

    String getRealm() { return m_realm; }
    void setRealm(const String& value) { m_realm = value; }

    template<int STATE>
    class AuthChallengeBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            OriginSet = 1 << 1,
            SchemeSet = 1 << 2,
            RealmSet = 1 << 3,
            AllFieldsSet = (OriginSet | SchemeSet | RealmSet | 0)};


        AuthChallengeBuilder<STATE>& setSource(const String& value)
        {
            m_result->setSource(value);
            return *this;
        }

        AuthChallengeBuilder<STATE | OriginSet>& setOrigin(const String& value)
        {
            static_assert(!(STATE & OriginSet), "property origin should not be set yet");
            m_result->setOrigin(value);
            return castState<OriginSet>();
        }

        AuthChallengeBuilder<STATE | SchemeSet>& setScheme(const String& value)
        {
            static_assert(!(STATE & SchemeSet), "property scheme should not be set yet");
            m_result->setScheme(value);
            return castState<SchemeSet>();
        }

        AuthChallengeBuilder<STATE | RealmSet>& setRealm(const String& value)
        {
            static_assert(!(STATE & RealmSet), "property realm should not be set yet");
            m_result->setRealm(value);
            return castState<RealmSet>();
        }

        std::unique_ptr<AuthChallenge> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AuthChallenge;
        AuthChallengeBuilder() : m_result(new AuthChallenge()) { }

        template<int STEP> AuthChallengeBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AuthChallengeBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::AuthChallenge> m_result;
    };

    static AuthChallengeBuilder<0> create()
    {
        return AuthChallengeBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AuthChallenge()
    {
    }

    Maybe<String> m_source;
    String m_origin;
    String m_scheme;
    String m_realm;
};


class  SignedExchangeSignature : public ::v8_crdtp::ProtocolObject<SignedExchangeSignature> {
public:
    ~SignedExchangeSignature() override { }

    String getLabel() { return m_label; }
    void setLabel(const String& value) { m_label = value; }

    String getSignature() { return m_signature; }
    void setSignature(const String& value) { m_signature = value; }

    String getIntegrity() { return m_integrity; }
    void setIntegrity(const String& value) { m_integrity = value; }

    bool hasCertUrl() { return m_certUrl.isJust(); }
    String getCertUrl(const String& defaultValue) { return m_certUrl.isJust() ? m_certUrl.fromJust() : defaultValue; }
    void setCertUrl(const String& value) { m_certUrl = value; }

    bool hasCertSha256() { return m_certSha256.isJust(); }
    String getCertSha256(const String& defaultValue) { return m_certSha256.isJust() ? m_certSha256.fromJust() : defaultValue; }
    void setCertSha256(const String& value) { m_certSha256 = value; }

    String getValidityUrl() { return m_validityUrl; }
    void setValidityUrl(const String& value) { m_validityUrl = value; }

    int getDate() { return m_date; }
    void setDate(int value) { m_date = value; }

    int getExpires() { return m_expires; }
    void setExpires(int value) { m_expires = value; }

    bool hasCertificates() { return m_certificates.isJust(); }
    protocol::Array<String>* getCertificates(protocol::Array<String>* defaultValue) { return m_certificates.isJust() ? m_certificates.fromJust() : defaultValue; }
    void setCertificates(std::unique_ptr<protocol::Array<String>> value) { m_certificates = std::move(value); }

    template<int STATE>
    class SignedExchangeSignatureBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            LabelSet = 1 << 1,
            SignatureSet = 1 << 2,
            IntegritySet = 1 << 3,
            ValidityUrlSet = 1 << 4,
            DateSet = 1 << 5,
            ExpiresSet = 1 << 6,
            AllFieldsSet = (LabelSet | SignatureSet | IntegritySet | ValidityUrlSet | DateSet | ExpiresSet | 0)};


        SignedExchangeSignatureBuilder<STATE | LabelSet>& setLabel(const String& value)
        {
            static_assert(!(STATE & LabelSet), "property label should not be set yet");
            m_result->setLabel(value);
            return castState<LabelSet>();
        }

        SignedExchangeSignatureBuilder<STATE | SignatureSet>& setSignature(const String& value)
        {
            static_assert(!(STATE & SignatureSet), "property signature should not be set yet");
            m_result->setSignature(value);
            return castState<SignatureSet>();
        }

        SignedExchangeSignatureBuilder<STATE | IntegritySet>& setIntegrity(const String& value)
        {
            static_assert(!(STATE & IntegritySet), "property integrity should not be set yet");
            m_result->setIntegrity(value);
            return castState<IntegritySet>();
        }

        SignedExchangeSignatureBuilder<STATE>& setCertUrl(const String& value)
        {
            m_result->setCertUrl(value);
            return *this;
        }

        SignedExchangeSignatureBuilder<STATE>& setCertSha256(const String& value)
        {
            m_result->setCertSha256(value);
            return *this;
        }

        SignedExchangeSignatureBuilder<STATE | ValidityUrlSet>& setValidityUrl(const String& value)
        {
            static_assert(!(STATE & ValidityUrlSet), "property validityUrl should not be set yet");
            m_result->setValidityUrl(value);
            return castState<ValidityUrlSet>();
        }

        SignedExchangeSignatureBuilder<STATE | DateSet>& setDate(int value)
        {
            static_assert(!(STATE & DateSet), "property date should not be set yet");
            m_result->setDate(value);
            return castState<DateSet>();
        }

        SignedExchangeSignatureBuilder<STATE | ExpiresSet>& setExpires(int value)
        {
            static_assert(!(STATE & ExpiresSet), "property expires should not be set yet");
            m_result->setExpires(value);
            return castState<ExpiresSet>();
        }

        SignedExchangeSignatureBuilder<STATE>& setCertificates(std::unique_ptr<protocol::Array<String>> value)
        {
            m_result->setCertificates(std::move(value));
            return *this;
        }

        std::unique_ptr<SignedExchangeSignature> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SignedExchangeSignature;
        SignedExchangeSignatureBuilder() : m_result(new SignedExchangeSignature()) { }

        template<int STEP> SignedExchangeSignatureBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SignedExchangeSignatureBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::SignedExchangeSignature> m_result;
    };

    static SignedExchangeSignatureBuilder<0> create()
    {
        return SignedExchangeSignatureBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    SignedExchangeSignature()
    {
          m_date = 0;
          m_expires = 0;
    }

    String m_label;
    String m_signature;
    String m_integrity;
    Maybe<String> m_certUrl;
    Maybe<String> m_certSha256;
    String m_validityUrl;
    int m_date;
    int m_expires;
    Maybe<protocol::Array<String>> m_certificates;
};


class  SignedExchangeHeader : public ::v8_crdtp::ProtocolObject<SignedExchangeHeader> {
public:
    ~SignedExchangeHeader() override { }

    String getRequestUrl() { return m_requestUrl; }
    void setRequestUrl(const String& value) { m_requestUrl = value; }

    int getResponseCode() { return m_responseCode; }
    void setResponseCode(int value) { m_responseCode = value; }

    protocol::Network::Headers* getResponseHeaders() { return m_responseHeaders.get(); }
    void setResponseHeaders(std::unique_ptr<protocol::Network::Headers> value) { m_responseHeaders = std::move(value); }

    protocol::Array<protocol::Network::SignedExchangeSignature>* getSignatures() { return m_signatures.get(); }
    void setSignatures(std::unique_ptr<protocol::Array<protocol::Network::SignedExchangeSignature>> value) { m_signatures = std::move(value); }

    template<int STATE>
    class SignedExchangeHeaderBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            RequestUrlSet = 1 << 1,
            ResponseCodeSet = 1 << 2,
            ResponseHeadersSet = 1 << 3,
            SignaturesSet = 1 << 4,
            AllFieldsSet = (RequestUrlSet | ResponseCodeSet | ResponseHeadersSet | SignaturesSet | 0)};


        SignedExchangeHeaderBuilder<STATE | RequestUrlSet>& setRequestUrl(const String& value)
        {
            static_assert(!(STATE & RequestUrlSet), "property requestUrl should not be set yet");
            m_result->setRequestUrl(value);
            return castState<RequestUrlSet>();
        }

        SignedExchangeHeaderBuilder<STATE | ResponseCodeSet>& setResponseCode(int value)
        {
            static_assert(!(STATE & ResponseCodeSet), "property responseCode should not be set yet");
            m_result->setResponseCode(value);
            return castState<ResponseCodeSet>();
        }

        SignedExchangeHeaderBuilder<STATE | ResponseHeadersSet>& setResponseHeaders(std::unique_ptr<protocol::Network::Headers> value)
        {
            static_assert(!(STATE & ResponseHeadersSet), "property responseHeaders should not be set yet");
            m_result->setResponseHeaders(std::move(value));
            return castState<ResponseHeadersSet>();
        }

        SignedExchangeHeaderBuilder<STATE | SignaturesSet>& setSignatures(std::unique_ptr<protocol::Array<protocol::Network::SignedExchangeSignature>> value)
        {
            static_assert(!(STATE & SignaturesSet), "property signatures should not be set yet");
            m_result->setSignatures(std::move(value));
            return castState<SignaturesSet>();
        }

        std::unique_ptr<SignedExchangeHeader> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SignedExchangeHeader;
        SignedExchangeHeaderBuilder() : m_result(new SignedExchangeHeader()) { }

        template<int STEP> SignedExchangeHeaderBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SignedExchangeHeaderBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::SignedExchangeHeader> m_result;
    };

    static SignedExchangeHeaderBuilder<0> create()
    {
        return SignedExchangeHeaderBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    SignedExchangeHeader()
    {
          m_responseCode = 0;
    }

    String m_requestUrl;
    int m_responseCode;
    std::unique_ptr<protocol::Network::Headers> m_responseHeaders;
    std::unique_ptr<protocol::Array<protocol::Network::SignedExchangeSignature>> m_signatures;
};


class  SignedExchangeError : public ::v8_crdtp::ProtocolObject<SignedExchangeError> {
public:
    ~SignedExchangeError() override { }

    String getMessage() { return m_message; }
    void setMessage(const String& value) { m_message = value; }

    bool hasSignatureIndex() { return m_signatureIndex.isJust(); }
    int getSignatureIndex(int defaultValue) { return m_signatureIndex.isJust() ? m_signatureIndex.fromJust() : defaultValue; }
    void setSignatureIndex(int value) { m_signatureIndex = value; }

    bool hasErrorField() { return m_errorField.isJust(); }
    String getErrorField(const String& defaultValue) { return m_errorField.isJust() ? m_errorField.fromJust() : defaultValue; }
    void setErrorField(const String& value) { m_errorField = value; }

    template<int STATE>
    class SignedExchangeErrorBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            MessageSet = 1 << 1,
            AllFieldsSet = (MessageSet | 0)};


        SignedExchangeErrorBuilder<STATE | MessageSet>& setMessage(const String& value)
        {
            static_assert(!(STATE & MessageSet), "property message should not be set yet");
            m_result->setMessage(value);
            return castState<MessageSet>();
        }

        SignedExchangeErrorBuilder<STATE>& setSignatureIndex(int value)
        {
            m_result->setSignatureIndex(value);
            return *this;
        }

        SignedExchangeErrorBuilder<STATE>& setErrorField(const String& value)
        {
            m_result->setErrorField(value);
            return *this;
        }

        std::unique_ptr<SignedExchangeError> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SignedExchangeError;
        SignedExchangeErrorBuilder() : m_result(new SignedExchangeError()) { }

        template<int STEP> SignedExchangeErrorBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SignedExchangeErrorBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::SignedExchangeError> m_result;
    };

    static SignedExchangeErrorBuilder<0> create()
    {
        return SignedExchangeErrorBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    SignedExchangeError()
    {
    }

    String m_message;
    Maybe<int> m_signatureIndex;
    Maybe<String> m_errorField;
};


class  SignedExchangeInfo : public ::v8_crdtp::ProtocolObject<SignedExchangeInfo> {
public:
    ~SignedExchangeInfo() override { }

    protocol::Network::Response* getOuterResponse() { return m_outerResponse.get(); }
    void setOuterResponse(std::unique_ptr<protocol::Network::Response> value) { m_outerResponse = std::move(value); }

    bool hasHeader() { return m_header.isJust(); }
    protocol::Network::SignedExchangeHeader* getHeader(protocol::Network::SignedExchangeHeader* defaultValue) { return m_header.isJust() ? m_header.fromJust() : defaultValue; }
    void setHeader(std::unique_ptr<protocol::Network::SignedExchangeHeader> value) { m_header = std::move(value); }

    bool hasSecurityDetails() { return m_securityDetails.isJust(); }
    protocol::Network::SecurityDetails* getSecurityDetails(protocol::Network::SecurityDetails* defaultValue) { return m_securityDetails.isJust() ? m_securityDetails.fromJust() : defaultValue; }
    void setSecurityDetails(std::unique_ptr<protocol::Network::SecurityDetails> value) { m_securityDetails = std::move(value); }

    bool hasErrors() { return m_errors.isJust(); }
    protocol::Array<protocol::Network::SignedExchangeError>* getErrors(protocol::Array<protocol::Network::SignedExchangeError>* defaultValue) { return m_errors.isJust() ? m_errors.fromJust() : defaultValue; }
    void setErrors(std::unique_ptr<protocol::Array<protocol::Network::SignedExchangeError>> value) { m_errors = std::move(value); }

    template<int STATE>
    class SignedExchangeInfoBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            OuterResponseSet = 1 << 1,
            AllFieldsSet = (OuterResponseSet | 0)};


        SignedExchangeInfoBuilder<STATE | OuterResponseSet>& setOuterResponse(std::unique_ptr<protocol::Network::Response> value)
        {
            static_assert(!(STATE & OuterResponseSet), "property outerResponse should not be set yet");
            m_result->setOuterResponse(std::move(value));
            return castState<OuterResponseSet>();
        }

        SignedExchangeInfoBuilder<STATE>& setHeader(std::unique_ptr<protocol::Network::SignedExchangeHeader> value)
        {
            m_result->setHeader(std::move(value));
            return *this;
        }

        SignedExchangeInfoBuilder<STATE>& setSecurityDetails(std::unique_ptr<protocol::Network::SecurityDetails> value)
        {
            m_result->setSecurityDetails(std::move(value));
            return *this;
        }

        SignedExchangeInfoBuilder<STATE>& setErrors(std::unique_ptr<protocol::Array<protocol::Network::SignedExchangeError>> value)
        {
            m_result->setErrors(std::move(value));
            return *this;
        }

        std::unique_ptr<SignedExchangeInfo> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SignedExchangeInfo;
        SignedExchangeInfoBuilder() : m_result(new SignedExchangeInfo()) { }

        template<int STEP> SignedExchangeInfoBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SignedExchangeInfoBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::SignedExchangeInfo> m_result;
    };

    static SignedExchangeInfoBuilder<0> create()
    {
        return SignedExchangeInfoBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    SignedExchangeInfo()
    {
    }

    std::unique_ptr<protocol::Network::Response> m_outerResponse;
    Maybe<protocol::Network::SignedExchangeHeader> m_header;
    Maybe<protocol::Network::SecurityDetails> m_securityDetails;
    Maybe<protocol::Array<protocol::Network::SignedExchangeError>> m_errors;
};


// ------------- Backend interface.

class  Backend {
public:
    virtual ~Backend() { }

    virtual DispatchResponse canClearBrowserCache(bool* out_result) = 0;
    virtual DispatchResponse canClearBrowserCookies(bool* out_result) = 0;
    virtual DispatchResponse disable() = 0;
    virtual DispatchResponse emulateNetworkConditions(bool in_offline, double in_latency, double in_downloadThroughput, double in_uploadThroughput, Maybe<String> in_connectionType) = 0;
    virtual DispatchResponse enable(Maybe<int> in_maxTotalBufferSize, Maybe<int> in_maxResourceBufferSize, Maybe<int> in_maxPostDataSize) = 0;
    virtual DispatchResponse getCertificate(const String& in_origin, std::unique_ptr<protocol::Array<String>>* out_tableNames) = 0;
    class  GetResponseBodyCallback {
    public:
        virtual void sendSuccess(const String& body, bool base64Encoded) = 0;
        virtual void sendFailure(const DispatchResponse&) = 0;
        virtual void fallThrough() = 0;
        virtual ~GetResponseBodyCallback() { }
    };
    virtual void getResponseBody(const String& in_requestId, std::unique_ptr<GetResponseBodyCallback> callback) = 0;
    class  GetRequestPostDataCallback {
    public:
        virtual void sendSuccess(const String& postData) = 0;
        virtual void sendFailure(const DispatchResponse&) = 0;
        virtual void fallThrough() = 0;
        virtual ~GetRequestPostDataCallback() { }
    };
    virtual void getRequestPostData(const String& in_requestId, std::unique_ptr<GetRequestPostDataCallback> callback) = 0;
    virtual DispatchResponse replayXHR(const String& in_requestId) = 0;
    virtual DispatchResponse searchInResponseBody(const String& in_requestId, const String& in_query, Maybe<bool> in_caseSensitive, Maybe<bool> in_isRegex, std::unique_ptr<protocol::Array<protocol::Debugger::SearchMatch>>* out_result) = 0;
    virtual DispatchResponse setBlockedURLs(std::unique_ptr<protocol::Array<String>> in_urls) = 0;
    virtual DispatchResponse setBypassServiceWorker(bool in_bypass) = 0;
    virtual DispatchResponse setCacheDisabled(bool in_cacheDisabled) = 0;
    virtual DispatchResponse setDataSizeLimitsForTest(int in_maxTotalSize, int in_maxResourceSize) = 0;
    virtual DispatchResponse setExtraHTTPHeaders(std::unique_ptr<protocol::Network::Headers> in_headers) = 0;

};

// ------------- Frontend interface.

class  Frontend {
public:
  explicit Frontend(FrontendChannel* frontend_channel) : frontend_channel_(frontend_channel) {}
    void dataReceived(const String& requestId, double timestamp, int dataLength, int encodedDataLength);
    void eventSourceMessageReceived(const String& requestId, double timestamp, const String& eventName, const String& eventId, const String& data);
    void loadingFailed(const String& requestId, double timestamp, const String& type, const String& errorText, Maybe<bool> canceled = Maybe<bool>(), Maybe<String> blockedReason = Maybe<String>());
    void loadingFinished(const String& requestId, double timestamp, double encodedDataLength, Maybe<bool> shouldReportCorbBlocking = Maybe<bool>());
    void requestIntercepted(const String& interceptionId, std::unique_ptr<protocol::Network::Request> request, const String& frameId, const String& resourceType, bool isNavigationRequest, Maybe<bool> isDownload = Maybe<bool>(), Maybe<String> redirectUrl = Maybe<String>(), Maybe<protocol::Network::AuthChallenge> authChallenge = Maybe<protocol::Network::AuthChallenge>(), Maybe<String> responseErrorReason = Maybe<String>(), Maybe<int> responseStatusCode = Maybe<int>(), Maybe<protocol::Network::Headers> responseHeaders = Maybe<protocol::Network::Headers>());
    void requestServedFromCache(const String& requestId);
    void requestWillBeSent(const String& requestId, const String& loaderId, const String& documentURL, std::unique_ptr<protocol::Network::Request> request, double timestamp, double wallTime, std::unique_ptr<protocol::Network::Initiator> initiator, Maybe<protocol::Network::Response> redirectResponse = Maybe<protocol::Network::Response>(), Maybe<String> type = Maybe<String>(), Maybe<String> frameId = Maybe<String>(), Maybe<bool> hasUserGesture = Maybe<bool>());
    void resourceChangedPriority(const String& requestId, const String& newPriority, double timestamp);
    void signedExchangeReceived(const String& requestId, std::unique_ptr<protocol::Network::SignedExchangeInfo> info);
    void responseReceived(const String& requestId, const String& loaderId, double timestamp, const String& type, std::unique_ptr<protocol::Network::Response> response, Maybe<String> frameId = Maybe<String>());
    void webSocketClosed(const String& requestId, double timestamp);
    void webSocketCreated(const String& requestId, const String& url, Maybe<protocol::Network::Initiator> initiator = Maybe<protocol::Network::Initiator>());
    void webSocketFrameError(const String& requestId, double timestamp, const String& errorMessage);
    void webSocketFrameReceived(const String& requestId, double timestamp, std::unique_ptr<protocol::Network::WebSocketFrame> response);
    void webSocketFrameSent(const String& requestId, double timestamp, std::unique_ptr<protocol::Network::WebSocketFrame> response);
    void webSocketHandshakeResponseReceived(const String& requestId, double timestamp, std::unique_ptr<protocol::Network::WebSocketResponse> response);
    void webSocketWillSendHandshakeRequest(const String& requestId, double timestamp, double wallTime, std::unique_ptr<protocol::Network::WebSocketRequest> request);

  void flush();
  void sendRawNotification(std::unique_ptr<Serializable>);
 private:
  FrontendChannel* frontend_channel_;
};

// ------------- Dispatcher.

class  Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher() { }
};

// ------------- Metainfo.

class  Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace Network
} // namespace v8_inspector
} // namespace protocol

#endif // !defined(v8_inspector_protocol_Network_h)
