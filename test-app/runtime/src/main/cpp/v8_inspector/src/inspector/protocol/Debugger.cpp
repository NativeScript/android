// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/inspector/protocol/Debugger.h"

#include "src/inspector/protocol/Protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/find_by_first.h"
#include "third_party/inspector_protocol/crdtp/serializer_traits.h"
#include "third_party/inspector_protocol/crdtp/span.h"

namespace v8_inspector {
namespace protocol {
namespace Debugger {

// ------------- Enum values from types.

const char Metainfo::domainName[] = "Debugger";
const char Metainfo::commandPrefix[] = "Debugger.";
const char Metainfo::version[] = "1.3";

std::unique_ptr<Location> Location::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<Location> result(new Location());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* scriptIdValue = object->get("scriptId");
    errors->SetName("scriptId");
    result->m_scriptId = ValueConversions<String>::fromValue(scriptIdValue, errors);
    protocol::Value* lineNumberValue = object->get("lineNumber");
    errors->SetName("lineNumber");
    result->m_lineNumber = ValueConversions<int>::fromValue(lineNumberValue, errors);
    protocol::Value* columnNumberValue = object->get("columnNumber");
    if (columnNumberValue) {
        errors->SetName("columnNumber");
        result->m_columnNumber = ValueConversions<int>::fromValue(columnNumberValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> Location::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("scriptId", ValueConversions<String>::toValue(m_scriptId));
    result->setValue("lineNumber", ValueConversions<int>::toValue(m_lineNumber));
    if (m_columnNumber.isJust())
        result->setValue("columnNumber", ValueConversions<int>::toValue(m_columnNumber.fromJust()));
    return result;
}

void Location::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("scriptId"), m_scriptId, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("lineNumber"), m_lineNumber, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("columnNumber"), m_columnNumber, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<Location> Location::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<ScriptPosition> ScriptPosition::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ScriptPosition> result(new ScriptPosition());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* lineNumberValue = object->get("lineNumber");
    errors->SetName("lineNumber");
    result->m_lineNumber = ValueConversions<int>::fromValue(lineNumberValue, errors);
    protocol::Value* columnNumberValue = object->get("columnNumber");
    errors->SetName("columnNumber");
    result->m_columnNumber = ValueConversions<int>::fromValue(columnNumberValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ScriptPosition::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("lineNumber", ValueConversions<int>::toValue(m_lineNumber));
    result->setValue("columnNumber", ValueConversions<int>::toValue(m_columnNumber));
    return result;
}

void ScriptPosition::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("lineNumber"), m_lineNumber, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("columnNumber"), m_columnNumber, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ScriptPosition> ScriptPosition::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<CallFrame> CallFrame::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<CallFrame> result(new CallFrame());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* callFrameIdValue = object->get("callFrameId");
    errors->SetName("callFrameId");
    result->m_callFrameId = ValueConversions<String>::fromValue(callFrameIdValue, errors);
    protocol::Value* functionNameValue = object->get("functionName");
    errors->SetName("functionName");
    result->m_functionName = ValueConversions<String>::fromValue(functionNameValue, errors);
    protocol::Value* functionLocationValue = object->get("functionLocation");
    if (functionLocationValue) {
        errors->SetName("functionLocation");
        result->m_functionLocation = ValueConversions<protocol::Debugger::Location>::fromValue(functionLocationValue, errors);
    }
    protocol::Value* locationValue = object->get("location");
    errors->SetName("location");
    result->m_location = ValueConversions<protocol::Debugger::Location>::fromValue(locationValue, errors);
    protocol::Value* urlValue = object->get("url");
    errors->SetName("url");
    result->m_url = ValueConversions<String>::fromValue(urlValue, errors);
    protocol::Value* scopeChainValue = object->get("scopeChain");
    errors->SetName("scopeChain");
    result->m_scopeChain = ValueConversions<protocol::Array<protocol::Debugger::Scope>>::fromValue(scopeChainValue, errors);
    protocol::Value* thisValue = object->get("this");
    errors->SetName("this");
    result->m_this = ValueConversions<protocol::Runtime::RemoteObject>::fromValue(thisValue, errors);
    protocol::Value* returnValueValue = object->get("returnValue");
    if (returnValueValue) {
        errors->SetName("returnValue");
        result->m_returnValue = ValueConversions<protocol::Runtime::RemoteObject>::fromValue(returnValueValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> CallFrame::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("callFrameId", ValueConversions<String>::toValue(m_callFrameId));
    result->setValue("functionName", ValueConversions<String>::toValue(m_functionName));
    if (m_functionLocation.isJust())
        result->setValue("functionLocation", ValueConversions<protocol::Debugger::Location>::toValue(m_functionLocation.fromJust()));
    result->setValue("location", ValueConversions<protocol::Debugger::Location>::toValue(m_location.get()));
    result->setValue("url", ValueConversions<String>::toValue(m_url));
    result->setValue("scopeChain", ValueConversions<protocol::Array<protocol::Debugger::Scope>>::toValue(m_scopeChain.get()));
    result->setValue("this", ValueConversions<protocol::Runtime::RemoteObject>::toValue(m_this.get()));
    if (m_returnValue.isJust())
        result->setValue("returnValue", ValueConversions<protocol::Runtime::RemoteObject>::toValue(m_returnValue.fromJust()));
    return result;
}

void CallFrame::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("callFrameId"), m_callFrameId, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("functionName"), m_functionName, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("functionLocation"), m_functionLocation, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("location"), m_location, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("url"), m_url, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("scopeChain"), m_scopeChain, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("this"), m_this, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("returnValue"), m_returnValue, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<CallFrame> CallFrame::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

const char* Scope::TypeEnum::Global = "global";
const char* Scope::TypeEnum::Local = "local";
const char* Scope::TypeEnum::With = "with";
const char* Scope::TypeEnum::Closure = "closure";
const char* Scope::TypeEnum::Catch = "catch";
const char* Scope::TypeEnum::Block = "block";
const char* Scope::TypeEnum::Script = "script";
const char* Scope::TypeEnum::Eval = "eval";
const char* Scope::TypeEnum::Module = "module";
const char* Scope::TypeEnum::WasmExpressionStack = "wasm-expression-stack";

std::unique_ptr<Scope> Scope::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<Scope> result(new Scope());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* typeValue = object->get("type");
    errors->SetName("type");
    result->m_type = ValueConversions<String>::fromValue(typeValue, errors);
    protocol::Value* objectValue = object->get("object");
    errors->SetName("object");
    result->m_object = ValueConversions<protocol::Runtime::RemoteObject>::fromValue(objectValue, errors);
    protocol::Value* nameValue = object->get("name");
    if (nameValue) {
        errors->SetName("name");
        result->m_name = ValueConversions<String>::fromValue(nameValue, errors);
    }
    protocol::Value* startLocationValue = object->get("startLocation");
    if (startLocationValue) {
        errors->SetName("startLocation");
        result->m_startLocation = ValueConversions<protocol::Debugger::Location>::fromValue(startLocationValue, errors);
    }
    protocol::Value* endLocationValue = object->get("endLocation");
    if (endLocationValue) {
        errors->SetName("endLocation");
        result->m_endLocation = ValueConversions<protocol::Debugger::Location>::fromValue(endLocationValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> Scope::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("type", ValueConversions<String>::toValue(m_type));
    result->setValue("object", ValueConversions<protocol::Runtime::RemoteObject>::toValue(m_object.get()));
    if (m_name.isJust())
        result->setValue("name", ValueConversions<String>::toValue(m_name.fromJust()));
    if (m_startLocation.isJust())
        result->setValue("startLocation", ValueConversions<protocol::Debugger::Location>::toValue(m_startLocation.fromJust()));
    if (m_endLocation.isJust())
        result->setValue("endLocation", ValueConversions<protocol::Debugger::Location>::toValue(m_endLocation.fromJust()));
    return result;
}

void Scope::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("type"), m_type, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("object"), m_object, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("name"), m_name, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("startLocation"), m_startLocation, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("endLocation"), m_endLocation, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<Scope> Scope::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<SearchMatch> SearchMatch::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<SearchMatch> result(new SearchMatch());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* lineNumberValue = object->get("lineNumber");
    errors->SetName("lineNumber");
    result->m_lineNumber = ValueConversions<double>::fromValue(lineNumberValue, errors);
    protocol::Value* lineContentValue = object->get("lineContent");
    errors->SetName("lineContent");
    result->m_lineContent = ValueConversions<String>::fromValue(lineContentValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> SearchMatch::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("lineNumber", ValueConversions<double>::toValue(m_lineNumber));
    result->setValue("lineContent", ValueConversions<String>::toValue(m_lineContent));
    return result;
}

void SearchMatch::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("lineNumber"), m_lineNumber, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("lineContent"), m_lineContent, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<SearchMatch> SearchMatch::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

// static
std::unique_ptr<API::SearchMatch> API::SearchMatch::fromBinary(const uint8_t* data, size_t length)
{
    ErrorSupport errors;
    std::unique_ptr<Value> value = Value::parseBinary(data, length);
    if (!value)
        return nullptr;
    return protocol::Debugger::SearchMatch::fromValue(value.get(), &errors);
}


const char* BreakLocation::TypeEnum::DebuggerStatement = "debuggerStatement";
const char* BreakLocation::TypeEnum::Call = "call";
const char* BreakLocation::TypeEnum::Return = "return";

std::unique_ptr<BreakLocation> BreakLocation::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<BreakLocation> result(new BreakLocation());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* scriptIdValue = object->get("scriptId");
    errors->SetName("scriptId");
    result->m_scriptId = ValueConversions<String>::fromValue(scriptIdValue, errors);
    protocol::Value* lineNumberValue = object->get("lineNumber");
    errors->SetName("lineNumber");
    result->m_lineNumber = ValueConversions<int>::fromValue(lineNumberValue, errors);
    protocol::Value* columnNumberValue = object->get("columnNumber");
    if (columnNumberValue) {
        errors->SetName("columnNumber");
        result->m_columnNumber = ValueConversions<int>::fromValue(columnNumberValue, errors);
    }
    protocol::Value* typeValue = object->get("type");
    if (typeValue) {
        errors->SetName("type");
        result->m_type = ValueConversions<String>::fromValue(typeValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> BreakLocation::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("scriptId", ValueConversions<String>::toValue(m_scriptId));
    result->setValue("lineNumber", ValueConversions<int>::toValue(m_lineNumber));
    if (m_columnNumber.isJust())
        result->setValue("columnNumber", ValueConversions<int>::toValue(m_columnNumber.fromJust()));
    if (m_type.isJust())
        result->setValue("type", ValueConversions<String>::toValue(m_type.fromJust()));
    return result;
}

void BreakLocation::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("scriptId"), m_scriptId, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("lineNumber"), m_lineNumber, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("columnNumber"), m_columnNumber, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("type"), m_type, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<BreakLocation> BreakLocation::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

namespace ScriptLanguageEnum {
const char JavaScript[] = "JavaScript";
const char WebAssembly[] = "WebAssembly";
} // namespace ScriptLanguageEnum

std::unique_ptr<BreakpointResolvedNotification> BreakpointResolvedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<BreakpointResolvedNotification> result(new BreakpointResolvedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* breakpointIdValue = object->get("breakpointId");
    errors->SetName("breakpointId");
    result->m_breakpointId = ValueConversions<String>::fromValue(breakpointIdValue, errors);
    protocol::Value* locationValue = object->get("location");
    errors->SetName("location");
    result->m_location = ValueConversions<protocol::Debugger::Location>::fromValue(locationValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> BreakpointResolvedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("breakpointId", ValueConversions<String>::toValue(m_breakpointId));
    result->setValue("location", ValueConversions<protocol::Debugger::Location>::toValue(m_location.get()));
    return result;
}

void BreakpointResolvedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("breakpointId"), m_breakpointId, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("location"), m_location, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<BreakpointResolvedNotification> BreakpointResolvedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

const char* PausedNotification::ReasonEnum::Ambiguous = "ambiguous";
const char* PausedNotification::ReasonEnum::Assert = "assert";
const char* PausedNotification::ReasonEnum::DebugCommand = "debugCommand";
const char* PausedNotification::ReasonEnum::DOM = "DOM";
const char* PausedNotification::ReasonEnum::EventListener = "EventListener";
const char* PausedNotification::ReasonEnum::Exception = "exception";
const char* PausedNotification::ReasonEnum::Instrumentation = "instrumentation";
const char* PausedNotification::ReasonEnum::OOM = "OOM";
const char* PausedNotification::ReasonEnum::Other = "other";
const char* PausedNotification::ReasonEnum::PromiseRejection = "promiseRejection";
const char* PausedNotification::ReasonEnum::XHR = "XHR";

std::unique_ptr<PausedNotification> PausedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<PausedNotification> result(new PausedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* callFramesValue = object->get("callFrames");
    errors->SetName("callFrames");
    result->m_callFrames = ValueConversions<protocol::Array<protocol::Debugger::CallFrame>>::fromValue(callFramesValue, errors);
    protocol::Value* reasonValue = object->get("reason");
    errors->SetName("reason");
    result->m_reason = ValueConversions<String>::fromValue(reasonValue, errors);
    protocol::Value* dataValue = object->get("data");
    if (dataValue) {
        errors->SetName("data");
        result->m_data = ValueConversions<protocol::DictionaryValue>::fromValue(dataValue, errors);
    }
    protocol::Value* hitBreakpointsValue = object->get("hitBreakpoints");
    if (hitBreakpointsValue) {
        errors->SetName("hitBreakpoints");
        result->m_hitBreakpoints = ValueConversions<protocol::Array<String>>::fromValue(hitBreakpointsValue, errors);
    }
    protocol::Value* asyncStackTraceValue = object->get("asyncStackTrace");
    if (asyncStackTraceValue) {
        errors->SetName("asyncStackTrace");
        result->m_asyncStackTrace = ValueConversions<protocol::Runtime::StackTrace>::fromValue(asyncStackTraceValue, errors);
    }
    protocol::Value* asyncStackTraceIdValue = object->get("asyncStackTraceId");
    if (asyncStackTraceIdValue) {
        errors->SetName("asyncStackTraceId");
        result->m_asyncStackTraceId = ValueConversions<protocol::Runtime::StackTraceId>::fromValue(asyncStackTraceIdValue, errors);
    }
    protocol::Value* asyncCallStackTraceIdValue = object->get("asyncCallStackTraceId");
    if (asyncCallStackTraceIdValue) {
        errors->SetName("asyncCallStackTraceId");
        result->m_asyncCallStackTraceId = ValueConversions<protocol::Runtime::StackTraceId>::fromValue(asyncCallStackTraceIdValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> PausedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("callFrames", ValueConversions<protocol::Array<protocol::Debugger::CallFrame>>::toValue(m_callFrames.get()));
    result->setValue("reason", ValueConversions<String>::toValue(m_reason));
    if (m_data.isJust())
        result->setValue("data", ValueConversions<protocol::DictionaryValue>::toValue(m_data.fromJust()));
    if (m_hitBreakpoints.isJust())
        result->setValue("hitBreakpoints", ValueConversions<protocol::Array<String>>::toValue(m_hitBreakpoints.fromJust()));
    if (m_asyncStackTrace.isJust())
        result->setValue("asyncStackTrace", ValueConversions<protocol::Runtime::StackTrace>::toValue(m_asyncStackTrace.fromJust()));
    if (m_asyncStackTraceId.isJust())
        result->setValue("asyncStackTraceId", ValueConversions<protocol::Runtime::StackTraceId>::toValue(m_asyncStackTraceId.fromJust()));
    if (m_asyncCallStackTraceId.isJust())
        result->setValue("asyncCallStackTraceId", ValueConversions<protocol::Runtime::StackTraceId>::toValue(m_asyncCallStackTraceId.fromJust()));
    return result;
}

void PausedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("callFrames"), m_callFrames, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("reason"), m_reason, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("data"), m_data, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("hitBreakpoints"), m_hitBreakpoints, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("asyncStackTrace"), m_asyncStackTrace, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("asyncStackTraceId"), m_asyncStackTraceId, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("asyncCallStackTraceId"), m_asyncCallStackTraceId, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<PausedNotification> PausedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<ScriptFailedToParseNotification> ScriptFailedToParseNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ScriptFailedToParseNotification> result(new ScriptFailedToParseNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* scriptIdValue = object->get("scriptId");
    errors->SetName("scriptId");
    result->m_scriptId = ValueConversions<String>::fromValue(scriptIdValue, errors);
    protocol::Value* urlValue = object->get("url");
    errors->SetName("url");
    result->m_url = ValueConversions<String>::fromValue(urlValue, errors);
    protocol::Value* startLineValue = object->get("startLine");
    errors->SetName("startLine");
    result->m_startLine = ValueConversions<int>::fromValue(startLineValue, errors);
    protocol::Value* startColumnValue = object->get("startColumn");
    errors->SetName("startColumn");
    result->m_startColumn = ValueConversions<int>::fromValue(startColumnValue, errors);
    protocol::Value* endLineValue = object->get("endLine");
    errors->SetName("endLine");
    result->m_endLine = ValueConversions<int>::fromValue(endLineValue, errors);
    protocol::Value* endColumnValue = object->get("endColumn");
    errors->SetName("endColumn");
    result->m_endColumn = ValueConversions<int>::fromValue(endColumnValue, errors);
    protocol::Value* executionContextIdValue = object->get("executionContextId");
    errors->SetName("executionContextId");
    result->m_executionContextId = ValueConversions<int>::fromValue(executionContextIdValue, errors);
    protocol::Value* hashValue = object->get("hash");
    errors->SetName("hash");
    result->m_hash = ValueConversions<String>::fromValue(hashValue, errors);
    protocol::Value* executionContextAuxDataValue = object->get("executionContextAuxData");
    if (executionContextAuxDataValue) {
        errors->SetName("executionContextAuxData");
        result->m_executionContextAuxData = ValueConversions<protocol::DictionaryValue>::fromValue(executionContextAuxDataValue, errors);
    }
    protocol::Value* sourceMapURLValue = object->get("sourceMapURL");
    if (sourceMapURLValue) {
        errors->SetName("sourceMapURL");
        result->m_sourceMapURL = ValueConversions<String>::fromValue(sourceMapURLValue, errors);
    }
    protocol::Value* hasSourceURLValue = object->get("hasSourceURL");
    if (hasSourceURLValue) {
        errors->SetName("hasSourceURL");
        result->m_hasSourceURL = ValueConversions<bool>::fromValue(hasSourceURLValue, errors);
    }
    protocol::Value* isModuleValue = object->get("isModule");
    if (isModuleValue) {
        errors->SetName("isModule");
        result->m_isModule = ValueConversions<bool>::fromValue(isModuleValue, errors);
    }
    protocol::Value* lengthValue = object->get("length");
    if (lengthValue) {
        errors->SetName("length");
        result->m_length = ValueConversions<int>::fromValue(lengthValue, errors);
    }
    protocol::Value* stackTraceValue = object->get("stackTrace");
    if (stackTraceValue) {
        errors->SetName("stackTrace");
        result->m_stackTrace = ValueConversions<protocol::Runtime::StackTrace>::fromValue(stackTraceValue, errors);
    }
    protocol::Value* codeOffsetValue = object->get("codeOffset");
    if (codeOffsetValue) {
        errors->SetName("codeOffset");
        result->m_codeOffset = ValueConversions<int>::fromValue(codeOffsetValue, errors);
    }
    protocol::Value* scriptLanguageValue = object->get("scriptLanguage");
    if (scriptLanguageValue) {
        errors->SetName("scriptLanguage");
        result->m_scriptLanguage = ValueConversions<String>::fromValue(scriptLanguageValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ScriptFailedToParseNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("scriptId", ValueConversions<String>::toValue(m_scriptId));
    result->setValue("url", ValueConversions<String>::toValue(m_url));
    result->setValue("startLine", ValueConversions<int>::toValue(m_startLine));
    result->setValue("startColumn", ValueConversions<int>::toValue(m_startColumn));
    result->setValue("endLine", ValueConversions<int>::toValue(m_endLine));
    result->setValue("endColumn", ValueConversions<int>::toValue(m_endColumn));
    result->setValue("executionContextId", ValueConversions<int>::toValue(m_executionContextId));
    result->setValue("hash", ValueConversions<String>::toValue(m_hash));
    if (m_executionContextAuxData.isJust())
        result->setValue("executionContextAuxData", ValueConversions<protocol::DictionaryValue>::toValue(m_executionContextAuxData.fromJust()));
    if (m_sourceMapURL.isJust())
        result->setValue("sourceMapURL", ValueConversions<String>::toValue(m_sourceMapURL.fromJust()));
    if (m_hasSourceURL.isJust())
        result->setValue("hasSourceURL", ValueConversions<bool>::toValue(m_hasSourceURL.fromJust()));
    if (m_isModule.isJust())
        result->setValue("isModule", ValueConversions<bool>::toValue(m_isModule.fromJust()));
    if (m_length.isJust())
        result->setValue("length", ValueConversions<int>::toValue(m_length.fromJust()));
    if (m_stackTrace.isJust())
        result->setValue("stackTrace", ValueConversions<protocol::Runtime::StackTrace>::toValue(m_stackTrace.fromJust()));
    if (m_codeOffset.isJust())
        result->setValue("codeOffset", ValueConversions<int>::toValue(m_codeOffset.fromJust()));
    if (m_scriptLanguage.isJust())
        result->setValue("scriptLanguage", ValueConversions<String>::toValue(m_scriptLanguage.fromJust()));
    return result;
}

void ScriptFailedToParseNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("scriptId"), m_scriptId, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("url"), m_url, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("startLine"), m_startLine, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("startColumn"), m_startColumn, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("endLine"), m_endLine, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("endColumn"), m_endColumn, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("executionContextId"), m_executionContextId, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("hash"), m_hash, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("executionContextAuxData"), m_executionContextAuxData, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("sourceMapURL"), m_sourceMapURL, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("hasSourceURL"), m_hasSourceURL, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("isModule"), m_isModule, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("length"), m_length, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("stackTrace"), m_stackTrace, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("codeOffset"), m_codeOffset, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("scriptLanguage"), m_scriptLanguage, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ScriptFailedToParseNotification> ScriptFailedToParseNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<ScriptParsedNotification> ScriptParsedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ScriptParsedNotification> result(new ScriptParsedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* scriptIdValue = object->get("scriptId");
    errors->SetName("scriptId");
    result->m_scriptId = ValueConversions<String>::fromValue(scriptIdValue, errors);
    protocol::Value* urlValue = object->get("url");
    errors->SetName("url");
    result->m_url = ValueConversions<String>::fromValue(urlValue, errors);
    protocol::Value* startLineValue = object->get("startLine");
    errors->SetName("startLine");
    result->m_startLine = ValueConversions<int>::fromValue(startLineValue, errors);
    protocol::Value* startColumnValue = object->get("startColumn");
    errors->SetName("startColumn");
    result->m_startColumn = ValueConversions<int>::fromValue(startColumnValue, errors);
    protocol::Value* endLineValue = object->get("endLine");
    errors->SetName("endLine");
    result->m_endLine = ValueConversions<int>::fromValue(endLineValue, errors);
    protocol::Value* endColumnValue = object->get("endColumn");
    errors->SetName("endColumn");
    result->m_endColumn = ValueConversions<int>::fromValue(endColumnValue, errors);
    protocol::Value* executionContextIdValue = object->get("executionContextId");
    errors->SetName("executionContextId");
    result->m_executionContextId = ValueConversions<int>::fromValue(executionContextIdValue, errors);
    protocol::Value* hashValue = object->get("hash");
    errors->SetName("hash");
    result->m_hash = ValueConversions<String>::fromValue(hashValue, errors);
    protocol::Value* executionContextAuxDataValue = object->get("executionContextAuxData");
    if (executionContextAuxDataValue) {
        errors->SetName("executionContextAuxData");
        result->m_executionContextAuxData = ValueConversions<protocol::DictionaryValue>::fromValue(executionContextAuxDataValue, errors);
    }
    protocol::Value* isLiveEditValue = object->get("isLiveEdit");
    if (isLiveEditValue) {
        errors->SetName("isLiveEdit");
        result->m_isLiveEdit = ValueConversions<bool>::fromValue(isLiveEditValue, errors);
    }
    protocol::Value* sourceMapURLValue = object->get("sourceMapURL");
    if (sourceMapURLValue) {
        errors->SetName("sourceMapURL");
        result->m_sourceMapURL = ValueConversions<String>::fromValue(sourceMapURLValue, errors);
    }
    protocol::Value* hasSourceURLValue = object->get("hasSourceURL");
    if (hasSourceURLValue) {
        errors->SetName("hasSourceURL");
        result->m_hasSourceURL = ValueConversions<bool>::fromValue(hasSourceURLValue, errors);
    }
    protocol::Value* isModuleValue = object->get("isModule");
    if (isModuleValue) {
        errors->SetName("isModule");
        result->m_isModule = ValueConversions<bool>::fromValue(isModuleValue, errors);
    }
    protocol::Value* lengthValue = object->get("length");
    if (lengthValue) {
        errors->SetName("length");
        result->m_length = ValueConversions<int>::fromValue(lengthValue, errors);
    }
    protocol::Value* stackTraceValue = object->get("stackTrace");
    if (stackTraceValue) {
        errors->SetName("stackTrace");
        result->m_stackTrace = ValueConversions<protocol::Runtime::StackTrace>::fromValue(stackTraceValue, errors);
    }
    protocol::Value* codeOffsetValue = object->get("codeOffset");
    if (codeOffsetValue) {
        errors->SetName("codeOffset");
        result->m_codeOffset = ValueConversions<int>::fromValue(codeOffsetValue, errors);
    }
    protocol::Value* scriptLanguageValue = object->get("scriptLanguage");
    if (scriptLanguageValue) {
        errors->SetName("scriptLanguage");
        result->m_scriptLanguage = ValueConversions<String>::fromValue(scriptLanguageValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ScriptParsedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("scriptId", ValueConversions<String>::toValue(m_scriptId));
    result->setValue("url", ValueConversions<String>::toValue(m_url));
    result->setValue("startLine", ValueConversions<int>::toValue(m_startLine));
    result->setValue("startColumn", ValueConversions<int>::toValue(m_startColumn));
    result->setValue("endLine", ValueConversions<int>::toValue(m_endLine));
    result->setValue("endColumn", ValueConversions<int>::toValue(m_endColumn));
    result->setValue("executionContextId", ValueConversions<int>::toValue(m_executionContextId));
    result->setValue("hash", ValueConversions<String>::toValue(m_hash));
    if (m_executionContextAuxData.isJust())
        result->setValue("executionContextAuxData", ValueConversions<protocol::DictionaryValue>::toValue(m_executionContextAuxData.fromJust()));
    if (m_isLiveEdit.isJust())
        result->setValue("isLiveEdit", ValueConversions<bool>::toValue(m_isLiveEdit.fromJust()));
    if (m_sourceMapURL.isJust())
        result->setValue("sourceMapURL", ValueConversions<String>::toValue(m_sourceMapURL.fromJust()));
    if (m_hasSourceURL.isJust())
        result->setValue("hasSourceURL", ValueConversions<bool>::toValue(m_hasSourceURL.fromJust()));
    if (m_isModule.isJust())
        result->setValue("isModule", ValueConversions<bool>::toValue(m_isModule.fromJust()));
    if (m_length.isJust())
        result->setValue("length", ValueConversions<int>::toValue(m_length.fromJust()));
    if (m_stackTrace.isJust())
        result->setValue("stackTrace", ValueConversions<protocol::Runtime::StackTrace>::toValue(m_stackTrace.fromJust()));
    if (m_codeOffset.isJust())
        result->setValue("codeOffset", ValueConversions<int>::toValue(m_codeOffset.fromJust()));
    if (m_scriptLanguage.isJust())
        result->setValue("scriptLanguage", ValueConversions<String>::toValue(m_scriptLanguage.fromJust()));
    return result;
}

void ScriptParsedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("scriptId"), m_scriptId, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("url"), m_url, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("startLine"), m_startLine, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("startColumn"), m_startColumn, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("endLine"), m_endLine, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("endColumn"), m_endColumn, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("executionContextId"), m_executionContextId, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("hash"), m_hash, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("executionContextAuxData"), m_executionContextAuxData, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("isLiveEdit"), m_isLiveEdit, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("sourceMapURL"), m_sourceMapURL, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("hasSourceURL"), m_hasSourceURL, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("isModule"), m_isModule, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("length"), m_length, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("stackTrace"), m_stackTrace, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("codeOffset"), m_codeOffset, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("scriptLanguage"), m_scriptLanguage, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ScriptParsedNotification> ScriptParsedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

// ------------- Enum values from params.


namespace ContinueToLocation {
namespace TargetCallFramesEnum {
const char* Any = "any";
const char* Current = "current";
} // namespace TargetCallFramesEnum
} // namespace ContinueToLocation

namespace SetInstrumentationBreakpoint {
namespace InstrumentationEnum {
const char* BeforeScriptExecution = "beforeScriptExecution";
const char* BeforeScriptWithSourceMapExecution = "beforeScriptWithSourceMapExecution";
} // namespace InstrumentationEnum
} // namespace SetInstrumentationBreakpoint

namespace SetPauseOnExceptions {
namespace StateEnum {
const char* None = "none";
const char* Uncaught = "uncaught";
const char* All = "all";
} // namespace StateEnum
} // namespace SetPauseOnExceptions

namespace Paused {
namespace ReasonEnum {
const char* Ambiguous = "ambiguous";
const char* Assert = "assert";
const char* DebugCommand = "debugCommand";
const char* DOM = "DOM";
const char* EventListener = "EventListener";
const char* Exception = "exception";
const char* Instrumentation = "instrumentation";
const char* OOM = "OOM";
const char* Other = "other";
const char* PromiseRejection = "promiseRejection";
const char* XHR = "XHR";
} // namespace ReasonEnum
} // namespace Paused

namespace API {
namespace Paused {
namespace ReasonEnum {
const char* Ambiguous = "ambiguous";
const char* Assert = "assert";
const char* DebugCommand = "debugCommand";
const char* DOM = "DOM";
const char* EventListener = "EventListener";
const char* Exception = "exception";
const char* Instrumentation = "instrumentation";
const char* OOM = "OOM";
const char* Other = "other";
const char* PromiseRejection = "promiseRejection";
const char* XHR = "XHR";
} // namespace ReasonEnum
} // namespace Paused
} // namespace API

// ------------- Frontend notifications.

void Frontend::breakpointResolved(const String& breakpointId, std::unique_ptr<protocol::Debugger::Location> location)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<BreakpointResolvedNotification> messageData = BreakpointResolvedNotification::create()
        .setBreakpointId(breakpointId)
        .setLocation(std::move(location))
        .build();
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Debugger.breakpointResolved", std::move(messageData)));
}

void Frontend::paused(std::unique_ptr<protocol::Array<protocol::Debugger::CallFrame>> callFrames, const String& reason, Maybe<protocol::DictionaryValue> data, Maybe<protocol::Array<String>> hitBreakpoints, Maybe<protocol::Runtime::StackTrace> asyncStackTrace, Maybe<protocol::Runtime::StackTraceId> asyncStackTraceId, Maybe<protocol::Runtime::StackTraceId> asyncCallStackTraceId)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<PausedNotification> messageData = PausedNotification::create()
        .setCallFrames(std::move(callFrames))
        .setReason(reason)
        .build();
    if (data.isJust())
        messageData->setData(std::move(data).takeJust());
    if (hitBreakpoints.isJust())
        messageData->setHitBreakpoints(std::move(hitBreakpoints).takeJust());
    if (asyncStackTrace.isJust())
        messageData->setAsyncStackTrace(std::move(asyncStackTrace).takeJust());
    if (asyncStackTraceId.isJust())
        messageData->setAsyncStackTraceId(std::move(asyncStackTraceId).takeJust());
    if (asyncCallStackTraceId.isJust())
        messageData->setAsyncCallStackTraceId(std::move(asyncCallStackTraceId).takeJust());
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Debugger.paused", std::move(messageData)));
}

void Frontend::resumed()
{
    if (!frontend_channel_)
        return;
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Debugger.resumed"));
}

void Frontend::scriptFailedToParse(const String& scriptId, const String& url, int startLine, int startColumn, int endLine, int endColumn, int executionContextId, const String& hash, Maybe<protocol::DictionaryValue> executionContextAuxData, Maybe<String> sourceMapURL, Maybe<bool> hasSourceURL, Maybe<bool> isModule, Maybe<int> length, Maybe<protocol::Runtime::StackTrace> stackTrace, Maybe<int> codeOffset, Maybe<String> scriptLanguage)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<ScriptFailedToParseNotification> messageData = ScriptFailedToParseNotification::create()
        .setScriptId(scriptId)
        .setUrl(url)
        .setStartLine(startLine)
        .setStartColumn(startColumn)
        .setEndLine(endLine)
        .setEndColumn(endColumn)
        .setExecutionContextId(executionContextId)
        .setHash(hash)
        .build();
    if (executionContextAuxData.isJust())
        messageData->setExecutionContextAuxData(std::move(executionContextAuxData).takeJust());
    if (sourceMapURL.isJust())
        messageData->setSourceMapURL(std::move(sourceMapURL).takeJust());
    if (hasSourceURL.isJust())
        messageData->setHasSourceURL(std::move(hasSourceURL).takeJust());
    if (isModule.isJust())
        messageData->setIsModule(std::move(isModule).takeJust());
    if (length.isJust())
        messageData->setLength(std::move(length).takeJust());
    if (stackTrace.isJust())
        messageData->setStackTrace(std::move(stackTrace).takeJust());
    if (codeOffset.isJust())
        messageData->setCodeOffset(std::move(codeOffset).takeJust());
    if (scriptLanguage.isJust())
        messageData->setScriptLanguage(std::move(scriptLanguage).takeJust());
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Debugger.scriptFailedToParse", std::move(messageData)));
}

void Frontend::scriptParsed(const String& scriptId, const String& url, int startLine, int startColumn, int endLine, int endColumn, int executionContextId, const String& hash, Maybe<protocol::DictionaryValue> executionContextAuxData, Maybe<bool> isLiveEdit, Maybe<String> sourceMapURL, Maybe<bool> hasSourceURL, Maybe<bool> isModule, Maybe<int> length, Maybe<protocol::Runtime::StackTrace> stackTrace, Maybe<int> codeOffset, Maybe<String> scriptLanguage)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<ScriptParsedNotification> messageData = ScriptParsedNotification::create()
        .setScriptId(scriptId)
        .setUrl(url)
        .setStartLine(startLine)
        .setStartColumn(startColumn)
        .setEndLine(endLine)
        .setEndColumn(endColumn)
        .setExecutionContextId(executionContextId)
        .setHash(hash)
        .build();
    if (executionContextAuxData.isJust())
        messageData->setExecutionContextAuxData(std::move(executionContextAuxData).takeJust());
    if (isLiveEdit.isJust())
        messageData->setIsLiveEdit(std::move(isLiveEdit).takeJust());
    if (sourceMapURL.isJust())
        messageData->setSourceMapURL(std::move(sourceMapURL).takeJust());
    if (hasSourceURL.isJust())
        messageData->setHasSourceURL(std::move(hasSourceURL).takeJust());
    if (isModule.isJust())
        messageData->setIsModule(std::move(isModule).takeJust());
    if (length.isJust())
        messageData->setLength(std::move(length).takeJust());
    if (stackTrace.isJust())
        messageData->setStackTrace(std::move(stackTrace).takeJust());
    if (codeOffset.isJust())
        messageData->setCodeOffset(std::move(codeOffset).takeJust());
    if (scriptLanguage.isJust())
        messageData->setScriptLanguage(std::move(scriptLanguage).takeJust());
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Debugger.scriptParsed", std::move(messageData)));
}

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);

    std::function<void(const v8_crdtp::Dispatchable&)> Dispatch(v8_crdtp::span<uint8_t> command_name) override;

    void continueToLocation(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void disable(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void enable(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void evaluateOnCallFrame(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getPossibleBreakpoints(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getScriptSource(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getWasmBytecode(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getStackTrace(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void pause(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void pauseOnAsyncCall(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void removeBreakpoint(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void restartFrame(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void resume(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void searchInContent(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setAsyncCallStackDepth(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setBlackboxPatterns(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setBlackboxedRanges(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setBreakpoint(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setInstrumentationBreakpoint(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setBreakpointByUrl(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setBreakpointOnFunctionCall(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setBreakpointsActive(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setPauseOnExceptions(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setReturnValue(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setScriptSource(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setSkipAllPauses(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setVariableValue(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void stepInto(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void stepOut(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void stepOver(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(v8_crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<v8_crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          v8_crdtp::SpanFrom("continueToLocation"),
          &DomainDispatcherImpl::continueToLocation
    },
    {
          v8_crdtp::SpanFrom("disable"),
          &DomainDispatcherImpl::disable
    },
    {
          v8_crdtp::SpanFrom("enable"),
          &DomainDispatcherImpl::enable
    },
    {
          v8_crdtp::SpanFrom("evaluateOnCallFrame"),
          &DomainDispatcherImpl::evaluateOnCallFrame
    },
    {
          v8_crdtp::SpanFrom("getPossibleBreakpoints"),
          &DomainDispatcherImpl::getPossibleBreakpoints
    },
    {
          v8_crdtp::SpanFrom("getScriptSource"),
          &DomainDispatcherImpl::getScriptSource
    },
    {
          v8_crdtp::SpanFrom("getStackTrace"),
          &DomainDispatcherImpl::getStackTrace
    },
    {
          v8_crdtp::SpanFrom("getWasmBytecode"),
          &DomainDispatcherImpl::getWasmBytecode
    },
    {
          v8_crdtp::SpanFrom("pause"),
          &DomainDispatcherImpl::pause
    },
    {
          v8_crdtp::SpanFrom("pauseOnAsyncCall"),
          &DomainDispatcherImpl::pauseOnAsyncCall
    },
    {
          v8_crdtp::SpanFrom("removeBreakpoint"),
          &DomainDispatcherImpl::removeBreakpoint
    },
    {
          v8_crdtp::SpanFrom("restartFrame"),
          &DomainDispatcherImpl::restartFrame
    },
    {
          v8_crdtp::SpanFrom("resume"),
          &DomainDispatcherImpl::resume
    },
    {
          v8_crdtp::SpanFrom("searchInContent"),
          &DomainDispatcherImpl::searchInContent
    },
    {
          v8_crdtp::SpanFrom("setAsyncCallStackDepth"),
          &DomainDispatcherImpl::setAsyncCallStackDepth
    },
    {
          v8_crdtp::SpanFrom("setBlackboxPatterns"),
          &DomainDispatcherImpl::setBlackboxPatterns
    },
    {
          v8_crdtp::SpanFrom("setBlackboxedRanges"),
          &DomainDispatcherImpl::setBlackboxedRanges
    },
    {
          v8_crdtp::SpanFrom("setBreakpoint"),
          &DomainDispatcherImpl::setBreakpoint
    },
    {
          v8_crdtp::SpanFrom("setBreakpointByUrl"),
          &DomainDispatcherImpl::setBreakpointByUrl
    },
    {
          v8_crdtp::SpanFrom("setBreakpointOnFunctionCall"),
          &DomainDispatcherImpl::setBreakpointOnFunctionCall
    },
    {
          v8_crdtp::SpanFrom("setBreakpointsActive"),
          &DomainDispatcherImpl::setBreakpointsActive
    },
    {
          v8_crdtp::SpanFrom("setInstrumentationBreakpoint"),
          &DomainDispatcherImpl::setInstrumentationBreakpoint
    },
    {
          v8_crdtp::SpanFrom("setPauseOnExceptions"),
          &DomainDispatcherImpl::setPauseOnExceptions
    },
    {
          v8_crdtp::SpanFrom("setReturnValue"),
          &DomainDispatcherImpl::setReturnValue
    },
    {
          v8_crdtp::SpanFrom("setScriptSource"),
          &DomainDispatcherImpl::setScriptSource
    },
    {
          v8_crdtp::SpanFrom("setSkipAllPauses"),
          &DomainDispatcherImpl::setSkipAllPauses
    },
    {
          v8_crdtp::SpanFrom("setVariableValue"),
          &DomainDispatcherImpl::setVariableValue
    },
    {
          v8_crdtp::SpanFrom("stepInto"),
          &DomainDispatcherImpl::stepInto
    },
    {
          v8_crdtp::SpanFrom("stepOut"),
          &DomainDispatcherImpl::stepOut
    },
    {
          v8_crdtp::SpanFrom("stepOver"),
          &DomainDispatcherImpl::stepOver
    },
    };
    return commands;
  }();
  return v8_crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const v8_crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(v8_crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;
  return [this, handler](const v8_crdtp::Dispatchable& dispatchable){
    std::unique_ptr<DictionaryValue> params =
        DictionaryValue::cast(protocol::Value::parseBinary(dispatchable.Params().data(),
        dispatchable.Params().size()));
    ErrorSupport errors;
    errors.Push();
    (this->*handler)(dispatchable, params.get(), &errors);
  };
}


void DomainDispatcherImpl::continueToLocation(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* locationValue = params ? params->get("location") : nullptr;
    errors->SetName("location");
    std::unique_ptr<protocol::Debugger::Location> in_location = ValueConversions<protocol::Debugger::Location>::fromValue(locationValue, errors);
    protocol::Value* targetCallFramesValue = params ? params->get("targetCallFrames") : nullptr;
    Maybe<String> in_targetCallFrames;
    if (targetCallFramesValue) {
        errors->SetName("targetCallFrames");
        in_targetCallFrames = ValueConversions<String>::fromValue(targetCallFramesValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->continueToLocation(std::move(in_location), std::move(in_targetCallFrames));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.continueToLocation"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::disable(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->disable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.disable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::enable(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* maxScriptsCacheSizeValue = params ? params->get("maxScriptsCacheSize") : nullptr;
    Maybe<double> in_maxScriptsCacheSize;
    if (maxScriptsCacheSizeValue) {
        errors->SetName("maxScriptsCacheSize");
        in_maxScriptsCacheSize = ValueConversions<double>::fromValue(maxScriptsCacheSizeValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    String out_debuggerId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->enable(std::move(in_maxScriptsCacheSize), &out_debuggerId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.enable"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("debuggerId"), out_debuggerId, &result);
          result.push_back(v8_crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, v8_crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::evaluateOnCallFrame(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* callFrameIdValue = params ? params->get("callFrameId") : nullptr;
    errors->SetName("callFrameId");
    String in_callFrameId = ValueConversions<String>::fromValue(callFrameIdValue, errors);
    protocol::Value* expressionValue = params ? params->get("expression") : nullptr;
    errors->SetName("expression");
    String in_expression = ValueConversions<String>::fromValue(expressionValue, errors);
    protocol::Value* objectGroupValue = params ? params->get("objectGroup") : nullptr;
    Maybe<String> in_objectGroup;
    if (objectGroupValue) {
        errors->SetName("objectGroup");
        in_objectGroup = ValueConversions<String>::fromValue(objectGroupValue, errors);
    }
    protocol::Value* includeCommandLineAPIValue = params ? params->get("includeCommandLineAPI") : nullptr;
    Maybe<bool> in_includeCommandLineAPI;
    if (includeCommandLineAPIValue) {
        errors->SetName("includeCommandLineAPI");
        in_includeCommandLineAPI = ValueConversions<bool>::fromValue(includeCommandLineAPIValue, errors);
    }
    protocol::Value* silentValue = params ? params->get("silent") : nullptr;
    Maybe<bool> in_silent;
    if (silentValue) {
        errors->SetName("silent");
        in_silent = ValueConversions<bool>::fromValue(silentValue, errors);
    }
    protocol::Value* returnByValueValue = params ? params->get("returnByValue") : nullptr;
    Maybe<bool> in_returnByValue;
    if (returnByValueValue) {
        errors->SetName("returnByValue");
        in_returnByValue = ValueConversions<bool>::fromValue(returnByValueValue, errors);
    }
    protocol::Value* generatePreviewValue = params ? params->get("generatePreview") : nullptr;
    Maybe<bool> in_generatePreview;
    if (generatePreviewValue) {
        errors->SetName("generatePreview");
        in_generatePreview = ValueConversions<bool>::fromValue(generatePreviewValue, errors);
    }
    protocol::Value* throwOnSideEffectValue = params ? params->get("throwOnSideEffect") : nullptr;
    Maybe<bool> in_throwOnSideEffect;
    if (throwOnSideEffectValue) {
        errors->SetName("throwOnSideEffect");
        in_throwOnSideEffect = ValueConversions<bool>::fromValue(throwOnSideEffectValue, errors);
    }
    protocol::Value* timeoutValue = params ? params->get("timeout") : nullptr;
    Maybe<double> in_timeout;
    if (timeoutValue) {
        errors->SetName("timeout");
        in_timeout = ValueConversions<double>::fromValue(timeoutValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    std::unique_ptr<protocol::Runtime::RemoteObject> out_result;
    Maybe<protocol::Runtime::ExceptionDetails> out_exceptionDetails;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->evaluateOnCallFrame(in_callFrameId, in_expression, std::move(in_objectGroup), std::move(in_includeCommandLineAPI), std::move(in_silent), std::move(in_returnByValue), std::move(in_generatePreview), std::move(in_throwOnSideEffect), std::move(in_timeout), &out_result, &out_exceptionDetails);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.evaluateOnCallFrame"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("result"), out_result, &result);
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("exceptionDetails"), out_exceptionDetails, &result);
          result.push_back(v8_crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, v8_crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::getPossibleBreakpoints(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* startValue = params ? params->get("start") : nullptr;
    errors->SetName("start");
    std::unique_ptr<protocol::Debugger::Location> in_start = ValueConversions<protocol::Debugger::Location>::fromValue(startValue, errors);
    protocol::Value* endValue = params ? params->get("end") : nullptr;
    Maybe<protocol::Debugger::Location> in_end;
    if (endValue) {
        errors->SetName("end");
        in_end = ValueConversions<protocol::Debugger::Location>::fromValue(endValue, errors);
    }
    protocol::Value* restrictToFunctionValue = params ? params->get("restrictToFunction") : nullptr;
    Maybe<bool> in_restrictToFunction;
    if (restrictToFunctionValue) {
        errors->SetName("restrictToFunction");
        in_restrictToFunction = ValueConversions<bool>::fromValue(restrictToFunctionValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::Debugger::BreakLocation>> out_locations;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getPossibleBreakpoints(std::move(in_start), std::move(in_end), std::move(in_restrictToFunction), &out_locations);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.getPossibleBreakpoints"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("locations"), out_locations, &result);
          result.push_back(v8_crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, v8_crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::getScriptSource(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* scriptIdValue = params ? params->get("scriptId") : nullptr;
    errors->SetName("scriptId");
    String in_scriptId = ValueConversions<String>::fromValue(scriptIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    String out_scriptSource;
    Maybe<Binary> out_bytecode;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getScriptSource(in_scriptId, &out_scriptSource, &out_bytecode);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.getScriptSource"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("scriptSource"), out_scriptSource, &result);
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("bytecode"), out_bytecode, &result);
          result.push_back(v8_crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, v8_crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::getWasmBytecode(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* scriptIdValue = params ? params->get("scriptId") : nullptr;
    errors->SetName("scriptId");
    String in_scriptId = ValueConversions<String>::fromValue(scriptIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    Binary out_bytecode;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getWasmBytecode(in_scriptId, &out_bytecode);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.getWasmBytecode"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("bytecode"), out_bytecode, &result);
          result.push_back(v8_crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, v8_crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::getStackTrace(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* stackTraceIdValue = params ? params->get("stackTraceId") : nullptr;
    errors->SetName("stackTraceId");
    std::unique_ptr<protocol::Runtime::StackTraceId> in_stackTraceId = ValueConversions<protocol::Runtime::StackTraceId>::fromValue(stackTraceIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    std::unique_ptr<protocol::Runtime::StackTrace> out_stackTrace;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getStackTrace(std::move(in_stackTraceId), &out_stackTrace);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.getStackTrace"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("stackTrace"), out_stackTrace, &result);
          result.push_back(v8_crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, v8_crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::pause(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->pause();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.pause"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::pauseOnAsyncCall(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* parentStackTraceIdValue = params ? params->get("parentStackTraceId") : nullptr;
    errors->SetName("parentStackTraceId");
    std::unique_ptr<protocol::Runtime::StackTraceId> in_parentStackTraceId = ValueConversions<protocol::Runtime::StackTraceId>::fromValue(parentStackTraceIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->pauseOnAsyncCall(std::move(in_parentStackTraceId));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.pauseOnAsyncCall"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::removeBreakpoint(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* breakpointIdValue = params ? params->get("breakpointId") : nullptr;
    errors->SetName("breakpointId");
    String in_breakpointId = ValueConversions<String>::fromValue(breakpointIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->removeBreakpoint(in_breakpointId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.removeBreakpoint"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::restartFrame(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* callFrameIdValue = params ? params->get("callFrameId") : nullptr;
    errors->SetName("callFrameId");
    String in_callFrameId = ValueConversions<String>::fromValue(callFrameIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::Debugger::CallFrame>> out_callFrames;
    Maybe<protocol::Runtime::StackTrace> out_asyncStackTrace;
    Maybe<protocol::Runtime::StackTraceId> out_asyncStackTraceId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->restartFrame(in_callFrameId, &out_callFrames, &out_asyncStackTrace, &out_asyncStackTraceId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.restartFrame"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("callFrames"), out_callFrames, &result);
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("asyncStackTrace"), out_asyncStackTrace, &result);
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("asyncStackTraceId"), out_asyncStackTraceId, &result);
          result.push_back(v8_crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, v8_crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::resume(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* terminateOnResumeValue = params ? params->get("terminateOnResume") : nullptr;
    Maybe<bool> in_terminateOnResume;
    if (terminateOnResumeValue) {
        errors->SetName("terminateOnResume");
        in_terminateOnResume = ValueConversions<bool>::fromValue(terminateOnResumeValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->resume(std::move(in_terminateOnResume));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.resume"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::searchInContent(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* scriptIdValue = params ? params->get("scriptId") : nullptr;
    errors->SetName("scriptId");
    String in_scriptId = ValueConversions<String>::fromValue(scriptIdValue, errors);
    protocol::Value* queryValue = params ? params->get("query") : nullptr;
    errors->SetName("query");
    String in_query = ValueConversions<String>::fromValue(queryValue, errors);
    protocol::Value* caseSensitiveValue = params ? params->get("caseSensitive") : nullptr;
    Maybe<bool> in_caseSensitive;
    if (caseSensitiveValue) {
        errors->SetName("caseSensitive");
        in_caseSensitive = ValueConversions<bool>::fromValue(caseSensitiveValue, errors);
    }
    protocol::Value* isRegexValue = params ? params->get("isRegex") : nullptr;
    Maybe<bool> in_isRegex;
    if (isRegexValue) {
        errors->SetName("isRegex");
        in_isRegex = ValueConversions<bool>::fromValue(isRegexValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::Debugger::SearchMatch>> out_result;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->searchInContent(in_scriptId, in_query, std::move(in_caseSensitive), std::move(in_isRegex), &out_result);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.searchInContent"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("result"), out_result, &result);
          result.push_back(v8_crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, v8_crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::setAsyncCallStackDepth(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* maxDepthValue = params ? params->get("maxDepth") : nullptr;
    errors->SetName("maxDepth");
    int in_maxDepth = ValueConversions<int>::fromValue(maxDepthValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setAsyncCallStackDepth(in_maxDepth);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.setAsyncCallStackDepth"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::setBlackboxPatterns(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* patternsValue = params ? params->get("patterns") : nullptr;
    errors->SetName("patterns");
    std::unique_ptr<protocol::Array<String>> in_patterns = ValueConversions<protocol::Array<String>>::fromValue(patternsValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setBlackboxPatterns(std::move(in_patterns));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.setBlackboxPatterns"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::setBlackboxedRanges(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* scriptIdValue = params ? params->get("scriptId") : nullptr;
    errors->SetName("scriptId");
    String in_scriptId = ValueConversions<String>::fromValue(scriptIdValue, errors);
    protocol::Value* positionsValue = params ? params->get("positions") : nullptr;
    errors->SetName("positions");
    std::unique_ptr<protocol::Array<protocol::Debugger::ScriptPosition>> in_positions = ValueConversions<protocol::Array<protocol::Debugger::ScriptPosition>>::fromValue(positionsValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setBlackboxedRanges(in_scriptId, std::move(in_positions));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.setBlackboxedRanges"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::setBreakpoint(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* locationValue = params ? params->get("location") : nullptr;
    errors->SetName("location");
    std::unique_ptr<protocol::Debugger::Location> in_location = ValueConversions<protocol::Debugger::Location>::fromValue(locationValue, errors);
    protocol::Value* conditionValue = params ? params->get("condition") : nullptr;
    Maybe<String> in_condition;
    if (conditionValue) {
        errors->SetName("condition");
        in_condition = ValueConversions<String>::fromValue(conditionValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    String out_breakpointId;
    std::unique_ptr<protocol::Debugger::Location> out_actualLocation;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setBreakpoint(std::move(in_location), std::move(in_condition), &out_breakpointId, &out_actualLocation);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.setBreakpoint"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("breakpointId"), out_breakpointId, &result);
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("actualLocation"), out_actualLocation, &result);
          result.push_back(v8_crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, v8_crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::setInstrumentationBreakpoint(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* instrumentationValue = params ? params->get("instrumentation") : nullptr;
    errors->SetName("instrumentation");
    String in_instrumentation = ValueConversions<String>::fromValue(instrumentationValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    String out_breakpointId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setInstrumentationBreakpoint(in_instrumentation, &out_breakpointId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.setInstrumentationBreakpoint"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("breakpointId"), out_breakpointId, &result);
          result.push_back(v8_crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, v8_crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::setBreakpointByUrl(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* lineNumberValue = params ? params->get("lineNumber") : nullptr;
    errors->SetName("lineNumber");
    int in_lineNumber = ValueConversions<int>::fromValue(lineNumberValue, errors);
    protocol::Value* urlValue = params ? params->get("url") : nullptr;
    Maybe<String> in_url;
    if (urlValue) {
        errors->SetName("url");
        in_url = ValueConversions<String>::fromValue(urlValue, errors);
    }
    protocol::Value* urlRegexValue = params ? params->get("urlRegex") : nullptr;
    Maybe<String> in_urlRegex;
    if (urlRegexValue) {
        errors->SetName("urlRegex");
        in_urlRegex = ValueConversions<String>::fromValue(urlRegexValue, errors);
    }
    protocol::Value* scriptHashValue = params ? params->get("scriptHash") : nullptr;
    Maybe<String> in_scriptHash;
    if (scriptHashValue) {
        errors->SetName("scriptHash");
        in_scriptHash = ValueConversions<String>::fromValue(scriptHashValue, errors);
    }
    protocol::Value* columnNumberValue = params ? params->get("columnNumber") : nullptr;
    Maybe<int> in_columnNumber;
    if (columnNumberValue) {
        errors->SetName("columnNumber");
        in_columnNumber = ValueConversions<int>::fromValue(columnNumberValue, errors);
    }
    protocol::Value* conditionValue = params ? params->get("condition") : nullptr;
    Maybe<String> in_condition;
    if (conditionValue) {
        errors->SetName("condition");
        in_condition = ValueConversions<String>::fromValue(conditionValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    String out_breakpointId;
    std::unique_ptr<protocol::Array<protocol::Debugger::Location>> out_locations;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setBreakpointByUrl(in_lineNumber, std::move(in_url), std::move(in_urlRegex), std::move(in_scriptHash), std::move(in_columnNumber), std::move(in_condition), &out_breakpointId, &out_locations);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.setBreakpointByUrl"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("breakpointId"), out_breakpointId, &result);
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("locations"), out_locations, &result);
          result.push_back(v8_crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, v8_crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::setBreakpointOnFunctionCall(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* objectIdValue = params ? params->get("objectId") : nullptr;
    errors->SetName("objectId");
    String in_objectId = ValueConversions<String>::fromValue(objectIdValue, errors);
    protocol::Value* conditionValue = params ? params->get("condition") : nullptr;
    Maybe<String> in_condition;
    if (conditionValue) {
        errors->SetName("condition");
        in_condition = ValueConversions<String>::fromValue(conditionValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    String out_breakpointId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setBreakpointOnFunctionCall(in_objectId, std::move(in_condition), &out_breakpointId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.setBreakpointOnFunctionCall"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("breakpointId"), out_breakpointId, &result);
          result.push_back(v8_crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, v8_crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::setBreakpointsActive(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* activeValue = params ? params->get("active") : nullptr;
    errors->SetName("active");
    bool in_active = ValueConversions<bool>::fromValue(activeValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setBreakpointsActive(in_active);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.setBreakpointsActive"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::setPauseOnExceptions(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* stateValue = params ? params->get("state") : nullptr;
    errors->SetName("state");
    String in_state = ValueConversions<String>::fromValue(stateValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setPauseOnExceptions(in_state);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.setPauseOnExceptions"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::setReturnValue(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* newValueValue = params ? params->get("newValue") : nullptr;
    errors->SetName("newValue");
    std::unique_ptr<protocol::Runtime::CallArgument> in_newValue = ValueConversions<protocol::Runtime::CallArgument>::fromValue(newValueValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setReturnValue(std::move(in_newValue));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.setReturnValue"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::setScriptSource(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* scriptIdValue = params ? params->get("scriptId") : nullptr;
    errors->SetName("scriptId");
    String in_scriptId = ValueConversions<String>::fromValue(scriptIdValue, errors);
    protocol::Value* scriptSourceValue = params ? params->get("scriptSource") : nullptr;
    errors->SetName("scriptSource");
    String in_scriptSource = ValueConversions<String>::fromValue(scriptSourceValue, errors);
    protocol::Value* dryRunValue = params ? params->get("dryRun") : nullptr;
    Maybe<bool> in_dryRun;
    if (dryRunValue) {
        errors->SetName("dryRun");
        in_dryRun = ValueConversions<bool>::fromValue(dryRunValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    Maybe<protocol::Array<protocol::Debugger::CallFrame>> out_callFrames;
    Maybe<bool> out_stackChanged;
    Maybe<protocol::Runtime::StackTrace> out_asyncStackTrace;
    Maybe<protocol::Runtime::StackTraceId> out_asyncStackTraceId;
    Maybe<protocol::Runtime::ExceptionDetails> out_exceptionDetails;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setScriptSource(in_scriptId, in_scriptSource, std::move(in_dryRun), &out_callFrames, &out_stackChanged, &out_asyncStackTrace, &out_asyncStackTraceId, &out_exceptionDetails);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.setScriptSource"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("callFrames"), out_callFrames, &result);
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("stackChanged"), out_stackChanged, &result);
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("asyncStackTrace"), out_asyncStackTrace, &result);
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("asyncStackTraceId"), out_asyncStackTraceId, &result);
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("exceptionDetails"), out_exceptionDetails, &result);
          result.push_back(v8_crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, v8_crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::setSkipAllPauses(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* skipValue = params ? params->get("skip") : nullptr;
    errors->SetName("skip");
    bool in_skip = ValueConversions<bool>::fromValue(skipValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setSkipAllPauses(in_skip);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.setSkipAllPauses"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::setVariableValue(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* scopeNumberValue = params ? params->get("scopeNumber") : nullptr;
    errors->SetName("scopeNumber");
    int in_scopeNumber = ValueConversions<int>::fromValue(scopeNumberValue, errors);
    protocol::Value* variableNameValue = params ? params->get("variableName") : nullptr;
    errors->SetName("variableName");
    String in_variableName = ValueConversions<String>::fromValue(variableNameValue, errors);
    protocol::Value* newValueValue = params ? params->get("newValue") : nullptr;
    errors->SetName("newValue");
    std::unique_ptr<protocol::Runtime::CallArgument> in_newValue = ValueConversions<protocol::Runtime::CallArgument>::fromValue(newValueValue, errors);
    protocol::Value* callFrameIdValue = params ? params->get("callFrameId") : nullptr;
    errors->SetName("callFrameId");
    String in_callFrameId = ValueConversions<String>::fromValue(callFrameIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setVariableValue(in_scopeNumber, in_variableName, std::move(in_newValue), in_callFrameId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.setVariableValue"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::stepInto(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* breakOnAsyncCallValue = params ? params->get("breakOnAsyncCall") : nullptr;
    Maybe<bool> in_breakOnAsyncCall;
    if (breakOnAsyncCallValue) {
        errors->SetName("breakOnAsyncCall");
        in_breakOnAsyncCall = ValueConversions<bool>::fromValue(breakOnAsyncCallValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->stepInto(std::move(in_breakOnAsyncCall));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.stepInto"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::stepOut(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->stepOut();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.stepOut"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::stepOver(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->stepOver();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Debugger.stepOver"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<v8_crdtp::span<uint8_t>, v8_crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<v8_crdtp::span<uint8_t>, v8_crdtp::span<uint8_t>>>{
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(v8_crdtp::SpanFrom("Debugger"), SortedRedirects(), std::move(dispatcher));
}

} // Debugger
} // namespace v8_inspector
} // namespace protocol
