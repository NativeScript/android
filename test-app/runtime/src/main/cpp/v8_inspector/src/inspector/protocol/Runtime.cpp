// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/inspector/protocol/Runtime.h"

#include "src/inspector/protocol/Protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/find_by_first.h"
#include "third_party/inspector_protocol/crdtp/serializer_traits.h"
#include "third_party/inspector_protocol/crdtp/span.h"

namespace v8_inspector {
namespace protocol {
namespace Runtime {

// ------------- Enum values from types.

const char Metainfo::domainName[] = "Runtime";
const char Metainfo::commandPrefix[] = "Runtime.";
const char Metainfo::version[] = "1.3";

const char* RemoteObject::TypeEnum::Object = "object";
const char* RemoteObject::TypeEnum::Function = "function";
const char* RemoteObject::TypeEnum::Undefined = "undefined";
const char* RemoteObject::TypeEnum::String = "string";
const char* RemoteObject::TypeEnum::Number = "number";
const char* RemoteObject::TypeEnum::Boolean = "boolean";
const char* RemoteObject::TypeEnum::Symbol = "symbol";
const char* RemoteObject::TypeEnum::Bigint = "bigint";
const char* RemoteObject::TypeEnum::Wasm = "wasm";

const char* RemoteObject::SubtypeEnum::Array = "array";
const char* RemoteObject::SubtypeEnum::Null = "null";
const char* RemoteObject::SubtypeEnum::Node = "node";
const char* RemoteObject::SubtypeEnum::Regexp = "regexp";
const char* RemoteObject::SubtypeEnum::Date = "date";
const char* RemoteObject::SubtypeEnum::Map = "map";
const char* RemoteObject::SubtypeEnum::Set = "set";
const char* RemoteObject::SubtypeEnum::Weakmap = "weakmap";
const char* RemoteObject::SubtypeEnum::Weakset = "weakset";
const char* RemoteObject::SubtypeEnum::Iterator = "iterator";
const char* RemoteObject::SubtypeEnum::Generator = "generator";
const char* RemoteObject::SubtypeEnum::Error = "error";
const char* RemoteObject::SubtypeEnum::Proxy = "proxy";
const char* RemoteObject::SubtypeEnum::Promise = "promise";
const char* RemoteObject::SubtypeEnum::Typedarray = "typedarray";
const char* RemoteObject::SubtypeEnum::Arraybuffer = "arraybuffer";
const char* RemoteObject::SubtypeEnum::Dataview = "dataview";
const char* RemoteObject::SubtypeEnum::I32 = "i32";
const char* RemoteObject::SubtypeEnum::I64 = "i64";
const char* RemoteObject::SubtypeEnum::F32 = "f32";
const char* RemoteObject::SubtypeEnum::F64 = "f64";
const char* RemoteObject::SubtypeEnum::V128 = "v128";

std::unique_ptr<RemoteObject> RemoteObject::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<RemoteObject> result(new RemoteObject());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* typeValue = object->get("type");
    errors->SetName("type");
    result->m_type = ValueConversions<String>::fromValue(typeValue, errors);
    protocol::Value* subtypeValue = object->get("subtype");
    if (subtypeValue) {
        errors->SetName("subtype");
        result->m_subtype = ValueConversions<String>::fromValue(subtypeValue, errors);
    }
    protocol::Value* classNameValue = object->get("className");
    if (classNameValue) {
        errors->SetName("className");
        result->m_className = ValueConversions<String>::fromValue(classNameValue, errors);
    }
    protocol::Value* valueValue = object->get("value");
    if (valueValue) {
        errors->SetName("value");
        result->m_value = ValueConversions<protocol::Value>::fromValue(valueValue, errors);
    }
    protocol::Value* unserializableValueValue = object->get("unserializableValue");
    if (unserializableValueValue) {
        errors->SetName("unserializableValue");
        result->m_unserializableValue = ValueConversions<String>::fromValue(unserializableValueValue, errors);
    }
    protocol::Value* descriptionValue = object->get("description");
    if (descriptionValue) {
        errors->SetName("description");
        result->m_description = ValueConversions<String>::fromValue(descriptionValue, errors);
    }
    protocol::Value* objectIdValue = object->get("objectId");
    if (objectIdValue) {
        errors->SetName("objectId");
        result->m_objectId = ValueConversions<String>::fromValue(objectIdValue, errors);
    }
    protocol::Value* previewValue = object->get("preview");
    if (previewValue) {
        errors->SetName("preview");
        result->m_preview = ValueConversions<protocol::Runtime::ObjectPreview>::fromValue(previewValue, errors);
    }
    protocol::Value* customPreviewValue = object->get("customPreview");
    if (customPreviewValue) {
        errors->SetName("customPreview");
        result->m_customPreview = ValueConversions<protocol::Runtime::CustomPreview>::fromValue(customPreviewValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> RemoteObject::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("type", ValueConversions<String>::toValue(m_type));
    if (m_subtype.isJust())
        result->setValue("subtype", ValueConversions<String>::toValue(m_subtype.fromJust()));
    if (m_className.isJust())
        result->setValue("className", ValueConversions<String>::toValue(m_className.fromJust()));
    if (m_value.isJust())
        result->setValue("value", ValueConversions<protocol::Value>::toValue(m_value.fromJust()));
    if (m_unserializableValue.isJust())
        result->setValue("unserializableValue", ValueConversions<String>::toValue(m_unserializableValue.fromJust()));
    if (m_description.isJust())
        result->setValue("description", ValueConversions<String>::toValue(m_description.fromJust()));
    if (m_objectId.isJust())
        result->setValue("objectId", ValueConversions<String>::toValue(m_objectId.fromJust()));
    if (m_preview.isJust())
        result->setValue("preview", ValueConversions<protocol::Runtime::ObjectPreview>::toValue(m_preview.fromJust()));
    if (m_customPreview.isJust())
        result->setValue("customPreview", ValueConversions<protocol::Runtime::CustomPreview>::toValue(m_customPreview.fromJust()));
    return result;
}

void RemoteObject::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("type"), m_type, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("subtype"), m_subtype, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("className"), m_className, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("value"), m_value, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("unserializableValue"), m_unserializableValue, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("description"), m_description, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("objectId"), m_objectId, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("preview"), m_preview, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("customPreview"), m_customPreview, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<RemoteObject> RemoteObject::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

// static
std::unique_ptr<API::RemoteObject> API::RemoteObject::fromBinary(const uint8_t* data, size_t length)
{
    ErrorSupport errors;
    std::unique_ptr<Value> value = Value::parseBinary(data, length);
    if (!value)
        return nullptr;
    return protocol::Runtime::RemoteObject::fromValue(value.get(), &errors);
}


std::unique_ptr<CustomPreview> CustomPreview::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<CustomPreview> result(new CustomPreview());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* headerValue = object->get("header");
    errors->SetName("header");
    result->m_header = ValueConversions<String>::fromValue(headerValue, errors);
    protocol::Value* bodyGetterIdValue = object->get("bodyGetterId");
    if (bodyGetterIdValue) {
        errors->SetName("bodyGetterId");
        result->m_bodyGetterId = ValueConversions<String>::fromValue(bodyGetterIdValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> CustomPreview::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("header", ValueConversions<String>::toValue(m_header));
    if (m_bodyGetterId.isJust())
        result->setValue("bodyGetterId", ValueConversions<String>::toValue(m_bodyGetterId.fromJust()));
    return result;
}

void CustomPreview::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("header"), m_header, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("bodyGetterId"), m_bodyGetterId, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<CustomPreview> CustomPreview::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

const char* ObjectPreview::TypeEnum::Object = "object";
const char* ObjectPreview::TypeEnum::Function = "function";
const char* ObjectPreview::TypeEnum::Undefined = "undefined";
const char* ObjectPreview::TypeEnum::String = "string";
const char* ObjectPreview::TypeEnum::Number = "number";
const char* ObjectPreview::TypeEnum::Boolean = "boolean";
const char* ObjectPreview::TypeEnum::Symbol = "symbol";
const char* ObjectPreview::TypeEnum::Bigint = "bigint";

const char* ObjectPreview::SubtypeEnum::Array = "array";
const char* ObjectPreview::SubtypeEnum::Null = "null";
const char* ObjectPreview::SubtypeEnum::Node = "node";
const char* ObjectPreview::SubtypeEnum::Regexp = "regexp";
const char* ObjectPreview::SubtypeEnum::Date = "date";
const char* ObjectPreview::SubtypeEnum::Map = "map";
const char* ObjectPreview::SubtypeEnum::Set = "set";
const char* ObjectPreview::SubtypeEnum::Weakmap = "weakmap";
const char* ObjectPreview::SubtypeEnum::Weakset = "weakset";
const char* ObjectPreview::SubtypeEnum::Iterator = "iterator";
const char* ObjectPreview::SubtypeEnum::Generator = "generator";
const char* ObjectPreview::SubtypeEnum::Error = "error";

std::unique_ptr<ObjectPreview> ObjectPreview::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ObjectPreview> result(new ObjectPreview());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* typeValue = object->get("type");
    errors->SetName("type");
    result->m_type = ValueConversions<String>::fromValue(typeValue, errors);
    protocol::Value* subtypeValue = object->get("subtype");
    if (subtypeValue) {
        errors->SetName("subtype");
        result->m_subtype = ValueConversions<String>::fromValue(subtypeValue, errors);
    }
    protocol::Value* descriptionValue = object->get("description");
    if (descriptionValue) {
        errors->SetName("description");
        result->m_description = ValueConversions<String>::fromValue(descriptionValue, errors);
    }
    protocol::Value* overflowValue = object->get("overflow");
    errors->SetName("overflow");
    result->m_overflow = ValueConversions<bool>::fromValue(overflowValue, errors);
    protocol::Value* propertiesValue = object->get("properties");
    errors->SetName("properties");
    result->m_properties = ValueConversions<protocol::Array<protocol::Runtime::PropertyPreview>>::fromValue(propertiesValue, errors);
    protocol::Value* entriesValue = object->get("entries");
    if (entriesValue) {
        errors->SetName("entries");
        result->m_entries = ValueConversions<protocol::Array<protocol::Runtime::EntryPreview>>::fromValue(entriesValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ObjectPreview::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("type", ValueConversions<String>::toValue(m_type));
    if (m_subtype.isJust())
        result->setValue("subtype", ValueConversions<String>::toValue(m_subtype.fromJust()));
    if (m_description.isJust())
        result->setValue("description", ValueConversions<String>::toValue(m_description.fromJust()));
    result->setValue("overflow", ValueConversions<bool>::toValue(m_overflow));
    result->setValue("properties", ValueConversions<protocol::Array<protocol::Runtime::PropertyPreview>>::toValue(m_properties.get()));
    if (m_entries.isJust())
        result->setValue("entries", ValueConversions<protocol::Array<protocol::Runtime::EntryPreview>>::toValue(m_entries.fromJust()));
    return result;
}

void ObjectPreview::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("type"), m_type, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("subtype"), m_subtype, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("description"), m_description, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("overflow"), m_overflow, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("properties"), m_properties, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("entries"), m_entries, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ObjectPreview> ObjectPreview::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

const char* PropertyPreview::TypeEnum::Object = "object";
const char* PropertyPreview::TypeEnum::Function = "function";
const char* PropertyPreview::TypeEnum::Undefined = "undefined";
const char* PropertyPreview::TypeEnum::String = "string";
const char* PropertyPreview::TypeEnum::Number = "number";
const char* PropertyPreview::TypeEnum::Boolean = "boolean";
const char* PropertyPreview::TypeEnum::Symbol = "symbol";
const char* PropertyPreview::TypeEnum::Accessor = "accessor";
const char* PropertyPreview::TypeEnum::Bigint = "bigint";

const char* PropertyPreview::SubtypeEnum::Array = "array";
const char* PropertyPreview::SubtypeEnum::Null = "null";
const char* PropertyPreview::SubtypeEnum::Node = "node";
const char* PropertyPreview::SubtypeEnum::Regexp = "regexp";
const char* PropertyPreview::SubtypeEnum::Date = "date";
const char* PropertyPreview::SubtypeEnum::Map = "map";
const char* PropertyPreview::SubtypeEnum::Set = "set";
const char* PropertyPreview::SubtypeEnum::Weakmap = "weakmap";
const char* PropertyPreview::SubtypeEnum::Weakset = "weakset";
const char* PropertyPreview::SubtypeEnum::Iterator = "iterator";
const char* PropertyPreview::SubtypeEnum::Generator = "generator";
const char* PropertyPreview::SubtypeEnum::Error = "error";

std::unique_ptr<PropertyPreview> PropertyPreview::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<PropertyPreview> result(new PropertyPreview());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* nameValue = object->get("name");
    errors->SetName("name");
    result->m_name = ValueConversions<String>::fromValue(nameValue, errors);
    protocol::Value* typeValue = object->get("type");
    errors->SetName("type");
    result->m_type = ValueConversions<String>::fromValue(typeValue, errors);
    protocol::Value* valueValue = object->get("value");
    if (valueValue) {
        errors->SetName("value");
        result->m_value = ValueConversions<String>::fromValue(valueValue, errors);
    }
    protocol::Value* valuePreviewValue = object->get("valuePreview");
    if (valuePreviewValue) {
        errors->SetName("valuePreview");
        result->m_valuePreview = ValueConversions<protocol::Runtime::ObjectPreview>::fromValue(valuePreviewValue, errors);
    }
    protocol::Value* subtypeValue = object->get("subtype");
    if (subtypeValue) {
        errors->SetName("subtype");
        result->m_subtype = ValueConversions<String>::fromValue(subtypeValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> PropertyPreview::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("name", ValueConversions<String>::toValue(m_name));
    result->setValue("type", ValueConversions<String>::toValue(m_type));
    if (m_value.isJust())
        result->setValue("value", ValueConversions<String>::toValue(m_value.fromJust()));
    if (m_valuePreview.isJust())
        result->setValue("valuePreview", ValueConversions<protocol::Runtime::ObjectPreview>::toValue(m_valuePreview.fromJust()));
    if (m_subtype.isJust())
        result->setValue("subtype", ValueConversions<String>::toValue(m_subtype.fromJust()));
    return result;
}

void PropertyPreview::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("name"), m_name, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("type"), m_type, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("value"), m_value, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("valuePreview"), m_valuePreview, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("subtype"), m_subtype, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<PropertyPreview> PropertyPreview::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<EntryPreview> EntryPreview::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<EntryPreview> result(new EntryPreview());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* keyValue = object->get("key");
    if (keyValue) {
        errors->SetName("key");
        result->m_key = ValueConversions<protocol::Runtime::ObjectPreview>::fromValue(keyValue, errors);
    }
    protocol::Value* valueValue = object->get("value");
    errors->SetName("value");
    result->m_value = ValueConversions<protocol::Runtime::ObjectPreview>::fromValue(valueValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> EntryPreview::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    if (m_key.isJust())
        result->setValue("key", ValueConversions<protocol::Runtime::ObjectPreview>::toValue(m_key.fromJust()));
    result->setValue("value", ValueConversions<protocol::Runtime::ObjectPreview>::toValue(m_value.get()));
    return result;
}

void EntryPreview::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("key"), m_key, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("value"), m_value, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<EntryPreview> EntryPreview::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<PropertyDescriptor> PropertyDescriptor::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<PropertyDescriptor> result(new PropertyDescriptor());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* nameValue = object->get("name");
    errors->SetName("name");
    result->m_name = ValueConversions<String>::fromValue(nameValue, errors);
    protocol::Value* valueValue = object->get("value");
    if (valueValue) {
        errors->SetName("value");
        result->m_value = ValueConversions<protocol::Runtime::RemoteObject>::fromValue(valueValue, errors);
    }
    protocol::Value* writableValue = object->get("writable");
    if (writableValue) {
        errors->SetName("writable");
        result->m_writable = ValueConversions<bool>::fromValue(writableValue, errors);
    }
    protocol::Value* getValue = object->get("get");
    if (getValue) {
        errors->SetName("get");
        result->m_get = ValueConversions<protocol::Runtime::RemoteObject>::fromValue(getValue, errors);
    }
    protocol::Value* setValue = object->get("set");
    if (setValue) {
        errors->SetName("set");
        result->m_set = ValueConversions<protocol::Runtime::RemoteObject>::fromValue(setValue, errors);
    }
    protocol::Value* configurableValue = object->get("configurable");
    errors->SetName("configurable");
    result->m_configurable = ValueConversions<bool>::fromValue(configurableValue, errors);
    protocol::Value* enumerableValue = object->get("enumerable");
    errors->SetName("enumerable");
    result->m_enumerable = ValueConversions<bool>::fromValue(enumerableValue, errors);
    protocol::Value* wasThrownValue = object->get("wasThrown");
    if (wasThrownValue) {
        errors->SetName("wasThrown");
        result->m_wasThrown = ValueConversions<bool>::fromValue(wasThrownValue, errors);
    }
    protocol::Value* isOwnValue = object->get("isOwn");
    if (isOwnValue) {
        errors->SetName("isOwn");
        result->m_isOwn = ValueConversions<bool>::fromValue(isOwnValue, errors);
    }
    protocol::Value* symbolValue = object->get("symbol");
    if (symbolValue) {
        errors->SetName("symbol");
        result->m_symbol = ValueConversions<protocol::Runtime::RemoteObject>::fromValue(symbolValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> PropertyDescriptor::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("name", ValueConversions<String>::toValue(m_name));
    if (m_value.isJust())
        result->setValue("value", ValueConversions<protocol::Runtime::RemoteObject>::toValue(m_value.fromJust()));
    if (m_writable.isJust())
        result->setValue("writable", ValueConversions<bool>::toValue(m_writable.fromJust()));
    if (m_get.isJust())
        result->setValue("get", ValueConversions<protocol::Runtime::RemoteObject>::toValue(m_get.fromJust()));
    if (m_set.isJust())
        result->setValue("set", ValueConversions<protocol::Runtime::RemoteObject>::toValue(m_set.fromJust()));
    result->setValue("configurable", ValueConversions<bool>::toValue(m_configurable));
    result->setValue("enumerable", ValueConversions<bool>::toValue(m_enumerable));
    if (m_wasThrown.isJust())
        result->setValue("wasThrown", ValueConversions<bool>::toValue(m_wasThrown.fromJust()));
    if (m_isOwn.isJust())
        result->setValue("isOwn", ValueConversions<bool>::toValue(m_isOwn.fromJust()));
    if (m_symbol.isJust())
        result->setValue("symbol", ValueConversions<protocol::Runtime::RemoteObject>::toValue(m_symbol.fromJust()));
    return result;
}

void PropertyDescriptor::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("name"), m_name, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("value"), m_value, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("writable"), m_writable, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("get"), m_get, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("set"), m_set, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("configurable"), m_configurable, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("enumerable"), m_enumerable, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("wasThrown"), m_wasThrown, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("isOwn"), m_isOwn, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("symbol"), m_symbol, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<PropertyDescriptor> PropertyDescriptor::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<InternalPropertyDescriptor> InternalPropertyDescriptor::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<InternalPropertyDescriptor> result(new InternalPropertyDescriptor());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* nameValue = object->get("name");
    errors->SetName("name");
    result->m_name = ValueConversions<String>::fromValue(nameValue, errors);
    protocol::Value* valueValue = object->get("value");
    if (valueValue) {
        errors->SetName("value");
        result->m_value = ValueConversions<protocol::Runtime::RemoteObject>::fromValue(valueValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> InternalPropertyDescriptor::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("name", ValueConversions<String>::toValue(m_name));
    if (m_value.isJust())
        result->setValue("value", ValueConversions<protocol::Runtime::RemoteObject>::toValue(m_value.fromJust()));
    return result;
}

void InternalPropertyDescriptor::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("name"), m_name, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("value"), m_value, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<InternalPropertyDescriptor> InternalPropertyDescriptor::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<PrivatePropertyDescriptor> PrivatePropertyDescriptor::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<PrivatePropertyDescriptor> result(new PrivatePropertyDescriptor());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* nameValue = object->get("name");
    errors->SetName("name");
    result->m_name = ValueConversions<String>::fromValue(nameValue, errors);
    protocol::Value* valueValue = object->get("value");
    if (valueValue) {
        errors->SetName("value");
        result->m_value = ValueConversions<protocol::Runtime::RemoteObject>::fromValue(valueValue, errors);
    }
    protocol::Value* getValue = object->get("get");
    if (getValue) {
        errors->SetName("get");
        result->m_get = ValueConversions<protocol::Runtime::RemoteObject>::fromValue(getValue, errors);
    }
    protocol::Value* setValue = object->get("set");
    if (setValue) {
        errors->SetName("set");
        result->m_set = ValueConversions<protocol::Runtime::RemoteObject>::fromValue(setValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> PrivatePropertyDescriptor::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("name", ValueConversions<String>::toValue(m_name));
    if (m_value.isJust())
        result->setValue("value", ValueConversions<protocol::Runtime::RemoteObject>::toValue(m_value.fromJust()));
    if (m_get.isJust())
        result->setValue("get", ValueConversions<protocol::Runtime::RemoteObject>::toValue(m_get.fromJust()));
    if (m_set.isJust())
        result->setValue("set", ValueConversions<protocol::Runtime::RemoteObject>::toValue(m_set.fromJust()));
    return result;
}

void PrivatePropertyDescriptor::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("name"), m_name, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("value"), m_value, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("get"), m_get, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("set"), m_set, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<PrivatePropertyDescriptor> PrivatePropertyDescriptor::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<CallArgument> CallArgument::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<CallArgument> result(new CallArgument());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* valueValue = object->get("value");
    if (valueValue) {
        errors->SetName("value");
        result->m_value = ValueConversions<protocol::Value>::fromValue(valueValue, errors);
    }
    protocol::Value* unserializableValueValue = object->get("unserializableValue");
    if (unserializableValueValue) {
        errors->SetName("unserializableValue");
        result->m_unserializableValue = ValueConversions<String>::fromValue(unserializableValueValue, errors);
    }
    protocol::Value* objectIdValue = object->get("objectId");
    if (objectIdValue) {
        errors->SetName("objectId");
        result->m_objectId = ValueConversions<String>::fromValue(objectIdValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> CallArgument::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    if (m_value.isJust())
        result->setValue("value", ValueConversions<protocol::Value>::toValue(m_value.fromJust()));
    if (m_unserializableValue.isJust())
        result->setValue("unserializableValue", ValueConversions<String>::toValue(m_unserializableValue.fromJust()));
    if (m_objectId.isJust())
        result->setValue("objectId", ValueConversions<String>::toValue(m_objectId.fromJust()));
    return result;
}

void CallArgument::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("value"), m_value, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("unserializableValue"), m_unserializableValue, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("objectId"), m_objectId, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<CallArgument> CallArgument::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<ExecutionContextDescription> ExecutionContextDescription::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ExecutionContextDescription> result(new ExecutionContextDescription());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* idValue = object->get("id");
    errors->SetName("id");
    result->m_id = ValueConversions<int>::fromValue(idValue, errors);
    protocol::Value* originValue = object->get("origin");
    errors->SetName("origin");
    result->m_origin = ValueConversions<String>::fromValue(originValue, errors);
    protocol::Value* nameValue = object->get("name");
    errors->SetName("name");
    result->m_name = ValueConversions<String>::fromValue(nameValue, errors);
    protocol::Value* auxDataValue = object->get("auxData");
    if (auxDataValue) {
        errors->SetName("auxData");
        result->m_auxData = ValueConversions<protocol::DictionaryValue>::fromValue(auxDataValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ExecutionContextDescription::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("id", ValueConversions<int>::toValue(m_id));
    result->setValue("origin", ValueConversions<String>::toValue(m_origin));
    result->setValue("name", ValueConversions<String>::toValue(m_name));
    if (m_auxData.isJust())
        result->setValue("auxData", ValueConversions<protocol::DictionaryValue>::toValue(m_auxData.fromJust()));
    return result;
}

void ExecutionContextDescription::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("id"), m_id, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("origin"), m_origin, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("name"), m_name, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("auxData"), m_auxData, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ExecutionContextDescription> ExecutionContextDescription::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<ExceptionDetails> ExceptionDetails::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ExceptionDetails> result(new ExceptionDetails());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* exceptionIdValue = object->get("exceptionId");
    errors->SetName("exceptionId");
    result->m_exceptionId = ValueConversions<int>::fromValue(exceptionIdValue, errors);
    protocol::Value* textValue = object->get("text");
    errors->SetName("text");
    result->m_text = ValueConversions<String>::fromValue(textValue, errors);
    protocol::Value* lineNumberValue = object->get("lineNumber");
    errors->SetName("lineNumber");
    result->m_lineNumber = ValueConversions<int>::fromValue(lineNumberValue, errors);
    protocol::Value* columnNumberValue = object->get("columnNumber");
    errors->SetName("columnNumber");
    result->m_columnNumber = ValueConversions<int>::fromValue(columnNumberValue, errors);
    protocol::Value* scriptIdValue = object->get("scriptId");
    if (scriptIdValue) {
        errors->SetName("scriptId");
        result->m_scriptId = ValueConversions<String>::fromValue(scriptIdValue, errors);
    }
    protocol::Value* urlValue = object->get("url");
    if (urlValue) {
        errors->SetName("url");
        result->m_url = ValueConversions<String>::fromValue(urlValue, errors);
    }
    protocol::Value* stackTraceValue = object->get("stackTrace");
    if (stackTraceValue) {
        errors->SetName("stackTrace");
        result->m_stackTrace = ValueConversions<protocol::Runtime::StackTrace>::fromValue(stackTraceValue, errors);
    }
    protocol::Value* exceptionValue = object->get("exception");
    if (exceptionValue) {
        errors->SetName("exception");
        result->m_exception = ValueConversions<protocol::Runtime::RemoteObject>::fromValue(exceptionValue, errors);
    }
    protocol::Value* executionContextIdValue = object->get("executionContextId");
    if (executionContextIdValue) {
        errors->SetName("executionContextId");
        result->m_executionContextId = ValueConversions<int>::fromValue(executionContextIdValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ExceptionDetails::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("exceptionId", ValueConversions<int>::toValue(m_exceptionId));
    result->setValue("text", ValueConversions<String>::toValue(m_text));
    result->setValue("lineNumber", ValueConversions<int>::toValue(m_lineNumber));
    result->setValue("columnNumber", ValueConversions<int>::toValue(m_columnNumber));
    if (m_scriptId.isJust())
        result->setValue("scriptId", ValueConversions<String>::toValue(m_scriptId.fromJust()));
    if (m_url.isJust())
        result->setValue("url", ValueConversions<String>::toValue(m_url.fromJust()));
    if (m_stackTrace.isJust())
        result->setValue("stackTrace", ValueConversions<protocol::Runtime::StackTrace>::toValue(m_stackTrace.fromJust()));
    if (m_exception.isJust())
        result->setValue("exception", ValueConversions<protocol::Runtime::RemoteObject>::toValue(m_exception.fromJust()));
    if (m_executionContextId.isJust())
        result->setValue("executionContextId", ValueConversions<int>::toValue(m_executionContextId.fromJust()));
    return result;
}

void ExceptionDetails::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("exceptionId"), m_exceptionId, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("text"), m_text, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("lineNumber"), m_lineNumber, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("columnNumber"), m_columnNumber, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("scriptId"), m_scriptId, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("url"), m_url, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("stackTrace"), m_stackTrace, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("exception"), m_exception, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("executionContextId"), m_executionContextId, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ExceptionDetails> ExceptionDetails::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<CallFrame> CallFrame::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<CallFrame> result(new CallFrame());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* functionNameValue = object->get("functionName");
    errors->SetName("functionName");
    result->m_functionName = ValueConversions<String>::fromValue(functionNameValue, errors);
    protocol::Value* scriptIdValue = object->get("scriptId");
    errors->SetName("scriptId");
    result->m_scriptId = ValueConversions<String>::fromValue(scriptIdValue, errors);
    protocol::Value* urlValue = object->get("url");
    errors->SetName("url");
    result->m_url = ValueConversions<String>::fromValue(urlValue, errors);
    protocol::Value* lineNumberValue = object->get("lineNumber");
    errors->SetName("lineNumber");
    result->m_lineNumber = ValueConversions<int>::fromValue(lineNumberValue, errors);
    protocol::Value* columnNumberValue = object->get("columnNumber");
    errors->SetName("columnNumber");
    result->m_columnNumber = ValueConversions<int>::fromValue(columnNumberValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> CallFrame::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("functionName", ValueConversions<String>::toValue(m_functionName));
    result->setValue("scriptId", ValueConversions<String>::toValue(m_scriptId));
    result->setValue("url", ValueConversions<String>::toValue(m_url));
    result->setValue("lineNumber", ValueConversions<int>::toValue(m_lineNumber));
    result->setValue("columnNumber", ValueConversions<int>::toValue(m_columnNumber));
    return result;
}

void CallFrame::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("functionName"), m_functionName, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("scriptId"), m_scriptId, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("url"), m_url, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("lineNumber"), m_lineNumber, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("columnNumber"), m_columnNumber, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<CallFrame> CallFrame::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<StackTrace> StackTrace::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<StackTrace> result(new StackTrace());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* descriptionValue = object->get("description");
    if (descriptionValue) {
        errors->SetName("description");
        result->m_description = ValueConversions<String>::fromValue(descriptionValue, errors);
    }
    protocol::Value* callFramesValue = object->get("callFrames");
    errors->SetName("callFrames");
    result->m_callFrames = ValueConversions<protocol::Array<protocol::Runtime::CallFrame>>::fromValue(callFramesValue, errors);
    protocol::Value* parentValue = object->get("parent");
    if (parentValue) {
        errors->SetName("parent");
        result->m_parent = ValueConversions<protocol::Runtime::StackTrace>::fromValue(parentValue, errors);
    }
    protocol::Value* parentIdValue = object->get("parentId");
    if (parentIdValue) {
        errors->SetName("parentId");
        result->m_parentId = ValueConversions<protocol::Runtime::StackTraceId>::fromValue(parentIdValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> StackTrace::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    if (m_description.isJust())
        result->setValue("description", ValueConversions<String>::toValue(m_description.fromJust()));
    result->setValue("callFrames", ValueConversions<protocol::Array<protocol::Runtime::CallFrame>>::toValue(m_callFrames.get()));
    if (m_parent.isJust())
        result->setValue("parent", ValueConversions<protocol::Runtime::StackTrace>::toValue(m_parent.fromJust()));
    if (m_parentId.isJust())
        result->setValue("parentId", ValueConversions<protocol::Runtime::StackTraceId>::toValue(m_parentId.fromJust()));
    return result;
}

void StackTrace::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("description"), m_description, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("callFrames"), m_callFrames, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("parent"), m_parent, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("parentId"), m_parentId, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<StackTrace> StackTrace::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

// static
std::unique_ptr<API::StackTrace> API::StackTrace::fromBinary(const uint8_t* data, size_t length)
{
    ErrorSupport errors;
    std::unique_ptr<Value> value = Value::parseBinary(data, length);
    if (!value)
        return nullptr;
    return protocol::Runtime::StackTrace::fromValue(value.get(), &errors);
}


std::unique_ptr<StackTraceId> StackTraceId::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<StackTraceId> result(new StackTraceId());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* idValue = object->get("id");
    errors->SetName("id");
    result->m_id = ValueConversions<String>::fromValue(idValue, errors);
    protocol::Value* debuggerIdValue = object->get("debuggerId");
    if (debuggerIdValue) {
        errors->SetName("debuggerId");
        result->m_debuggerId = ValueConversions<String>::fromValue(debuggerIdValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> StackTraceId::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("id", ValueConversions<String>::toValue(m_id));
    if (m_debuggerId.isJust())
        result->setValue("debuggerId", ValueConversions<String>::toValue(m_debuggerId.fromJust()));
    return result;
}

void StackTraceId::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("id"), m_id, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("debuggerId"), m_debuggerId, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<StackTraceId> StackTraceId::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

// static
std::unique_ptr<API::StackTraceId> API::StackTraceId::fromBinary(const uint8_t* data, size_t length)
{
    ErrorSupport errors;
    std::unique_ptr<Value> value = Value::parseBinary(data, length);
    if (!value)
        return nullptr;
    return protocol::Runtime::StackTraceId::fromValue(value.get(), &errors);
}


std::unique_ptr<BindingCalledNotification> BindingCalledNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<BindingCalledNotification> result(new BindingCalledNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* nameValue = object->get("name");
    errors->SetName("name");
    result->m_name = ValueConversions<String>::fromValue(nameValue, errors);
    protocol::Value* payloadValue = object->get("payload");
    errors->SetName("payload");
    result->m_payload = ValueConversions<String>::fromValue(payloadValue, errors);
    protocol::Value* executionContextIdValue = object->get("executionContextId");
    errors->SetName("executionContextId");
    result->m_executionContextId = ValueConversions<int>::fromValue(executionContextIdValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> BindingCalledNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("name", ValueConversions<String>::toValue(m_name));
    result->setValue("payload", ValueConversions<String>::toValue(m_payload));
    result->setValue("executionContextId", ValueConversions<int>::toValue(m_executionContextId));
    return result;
}

void BindingCalledNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("name"), m_name, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("payload"), m_payload, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("executionContextId"), m_executionContextId, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<BindingCalledNotification> BindingCalledNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

const char* ConsoleAPICalledNotification::TypeEnum::Log = "log";
const char* ConsoleAPICalledNotification::TypeEnum::Debug = "debug";
const char* ConsoleAPICalledNotification::TypeEnum::Info = "info";
const char* ConsoleAPICalledNotification::TypeEnum::Error = "error";
const char* ConsoleAPICalledNotification::TypeEnum::Warning = "warning";
const char* ConsoleAPICalledNotification::TypeEnum::Dir = "dir";
const char* ConsoleAPICalledNotification::TypeEnum::Dirxml = "dirxml";
const char* ConsoleAPICalledNotification::TypeEnum::Table = "table";
const char* ConsoleAPICalledNotification::TypeEnum::Trace = "trace";
const char* ConsoleAPICalledNotification::TypeEnum::Clear = "clear";
const char* ConsoleAPICalledNotification::TypeEnum::StartGroup = "startGroup";
const char* ConsoleAPICalledNotification::TypeEnum::StartGroupCollapsed = "startGroupCollapsed";
const char* ConsoleAPICalledNotification::TypeEnum::EndGroup = "endGroup";
const char* ConsoleAPICalledNotification::TypeEnum::Assert = "assert";
const char* ConsoleAPICalledNotification::TypeEnum::Profile = "profile";
const char* ConsoleAPICalledNotification::TypeEnum::ProfileEnd = "profileEnd";
const char* ConsoleAPICalledNotification::TypeEnum::Count = "count";
const char* ConsoleAPICalledNotification::TypeEnum::TimeEnd = "timeEnd";

std::unique_ptr<ConsoleAPICalledNotification> ConsoleAPICalledNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ConsoleAPICalledNotification> result(new ConsoleAPICalledNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* typeValue = object->get("type");
    errors->SetName("type");
    result->m_type = ValueConversions<String>::fromValue(typeValue, errors);
    protocol::Value* argsValue = object->get("args");
    errors->SetName("args");
    result->m_args = ValueConversions<protocol::Array<protocol::Runtime::RemoteObject>>::fromValue(argsValue, errors);
    protocol::Value* executionContextIdValue = object->get("executionContextId");
    errors->SetName("executionContextId");
    result->m_executionContextId = ValueConversions<int>::fromValue(executionContextIdValue, errors);
    protocol::Value* timestampValue = object->get("timestamp");
    errors->SetName("timestamp");
    result->m_timestamp = ValueConversions<double>::fromValue(timestampValue, errors);
    protocol::Value* stackTraceValue = object->get("stackTrace");
    if (stackTraceValue) {
        errors->SetName("stackTrace");
        result->m_stackTrace = ValueConversions<protocol::Runtime::StackTrace>::fromValue(stackTraceValue, errors);
    }
    protocol::Value* contextValue = object->get("context");
    if (contextValue) {
        errors->SetName("context");
        result->m_context = ValueConversions<String>::fromValue(contextValue, errors);
    }
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ConsoleAPICalledNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("type", ValueConversions<String>::toValue(m_type));
    result->setValue("args", ValueConversions<protocol::Array<protocol::Runtime::RemoteObject>>::toValue(m_args.get()));
    result->setValue("executionContextId", ValueConversions<int>::toValue(m_executionContextId));
    result->setValue("timestamp", ValueConversions<double>::toValue(m_timestamp));
    if (m_stackTrace.isJust())
        result->setValue("stackTrace", ValueConversions<protocol::Runtime::StackTrace>::toValue(m_stackTrace.fromJust()));
    if (m_context.isJust())
        result->setValue("context", ValueConversions<String>::toValue(m_context.fromJust()));
    return result;
}

void ConsoleAPICalledNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("type"), m_type, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("args"), m_args, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("executionContextId"), m_executionContextId, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("timestamp"), m_timestamp, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("stackTrace"), m_stackTrace, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("context"), m_context, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ConsoleAPICalledNotification> ConsoleAPICalledNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<ExceptionRevokedNotification> ExceptionRevokedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ExceptionRevokedNotification> result(new ExceptionRevokedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* reasonValue = object->get("reason");
    errors->SetName("reason");
    result->m_reason = ValueConversions<String>::fromValue(reasonValue, errors);
    protocol::Value* exceptionIdValue = object->get("exceptionId");
    errors->SetName("exceptionId");
    result->m_exceptionId = ValueConversions<int>::fromValue(exceptionIdValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ExceptionRevokedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("reason", ValueConversions<String>::toValue(m_reason));
    result->setValue("exceptionId", ValueConversions<int>::toValue(m_exceptionId));
    return result;
}

void ExceptionRevokedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("reason"), m_reason, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("exceptionId"), m_exceptionId, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ExceptionRevokedNotification> ExceptionRevokedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<ExceptionThrownNotification> ExceptionThrownNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ExceptionThrownNotification> result(new ExceptionThrownNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* timestampValue = object->get("timestamp");
    errors->SetName("timestamp");
    result->m_timestamp = ValueConversions<double>::fromValue(timestampValue, errors);
    protocol::Value* exceptionDetailsValue = object->get("exceptionDetails");
    errors->SetName("exceptionDetails");
    result->m_exceptionDetails = ValueConversions<protocol::Runtime::ExceptionDetails>::fromValue(exceptionDetailsValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ExceptionThrownNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("timestamp", ValueConversions<double>::toValue(m_timestamp));
    result->setValue("exceptionDetails", ValueConversions<protocol::Runtime::ExceptionDetails>::toValue(m_exceptionDetails.get()));
    return result;
}

void ExceptionThrownNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("timestamp"), m_timestamp, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("exceptionDetails"), m_exceptionDetails, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ExceptionThrownNotification> ExceptionThrownNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<ExecutionContextCreatedNotification> ExecutionContextCreatedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ExecutionContextCreatedNotification> result(new ExecutionContextCreatedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* contextValue = object->get("context");
    errors->SetName("context");
    result->m_context = ValueConversions<protocol::Runtime::ExecutionContextDescription>::fromValue(contextValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ExecutionContextCreatedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("context", ValueConversions<protocol::Runtime::ExecutionContextDescription>::toValue(m_context.get()));
    return result;
}

void ExecutionContextCreatedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("context"), m_context, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ExecutionContextCreatedNotification> ExecutionContextCreatedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<ExecutionContextDestroyedNotification> ExecutionContextDestroyedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<ExecutionContextDestroyedNotification> result(new ExecutionContextDestroyedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* executionContextIdValue = object->get("executionContextId");
    errors->SetName("executionContextId");
    result->m_executionContextId = ValueConversions<int>::fromValue(executionContextIdValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> ExecutionContextDestroyedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("executionContextId", ValueConversions<int>::toValue(m_executionContextId));
    return result;
}

void ExecutionContextDestroyedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("executionContextId"), m_executionContextId, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<ExecutionContextDestroyedNotification> ExecutionContextDestroyedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

std::unique_ptr<InspectRequestedNotification> InspectRequestedNotification::fromValue(protocol::Value* value, ErrorSupport* errors)
{
    if (!value || value->type() != protocol::Value::TypeObject) {
        errors->AddError("object expected");
        return nullptr;
    }

    std::unique_ptr<InspectRequestedNotification> result(new InspectRequestedNotification());
    protocol::DictionaryValue* object = DictionaryValue::cast(value);
    errors->Push();
    protocol::Value* objectValue = object->get("object");
    errors->SetName("object");
    result->m_object = ValueConversions<protocol::Runtime::RemoteObject>::fromValue(objectValue, errors);
    protocol::Value* hintsValue = object->get("hints");
    errors->SetName("hints");
    result->m_hints = ValueConversions<protocol::DictionaryValue>::fromValue(hintsValue, errors);
    errors->Pop();
    if (!errors->Errors().empty())
        return nullptr;
    return result;
}

std::unique_ptr<protocol::DictionaryValue> InspectRequestedNotification::toValue() const
{
    std::unique_ptr<protocol::DictionaryValue> result = DictionaryValue::create();
    result->setValue("object", ValueConversions<protocol::Runtime::RemoteObject>::toValue(m_object.get()));
    result->setValue("hints", ValueConversions<protocol::DictionaryValue>::toValue(m_hints.get()));
    return result;
}

void InspectRequestedNotification::AppendSerialized(std::vector<uint8_t>* out) const {
    v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
    envelope_encoder.EncodeStart(out);
    out->push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("object"), m_object, out);
      v8_crdtp::SerializeField(v8_crdtp::SpanFrom("hints"), m_hints, out);
    out->push_back(v8_crdtp::cbor::EncodeStop());
    envelope_encoder.EncodeStop(out);
}

std::unique_ptr<InspectRequestedNotification> InspectRequestedNotification::clone() const
{
    ErrorSupport errors;
    return fromValue(toValue().get(), &errors);
}

// ------------- Enum values from params.


namespace ConsoleAPICalled {
namespace TypeEnum {
const char* Log = "log";
const char* Debug = "debug";
const char* Info = "info";
const char* Error = "error";
const char* Warning = "warning";
const char* Dir = "dir";
const char* Dirxml = "dirxml";
const char* Table = "table";
const char* Trace = "trace";
const char* Clear = "clear";
const char* StartGroup = "startGroup";
const char* StartGroupCollapsed = "startGroupCollapsed";
const char* EndGroup = "endGroup";
const char* Assert = "assert";
const char* Profile = "profile";
const char* ProfileEnd = "profileEnd";
const char* Count = "count";
const char* TimeEnd = "timeEnd";
} // namespace TypeEnum
} // namespace ConsoleAPICalled

// ------------- Frontend notifications.

void Frontend::bindingCalled(const String& name, const String& payload, int executionContextId)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<BindingCalledNotification> messageData = BindingCalledNotification::create()
        .setName(name)
        .setPayload(payload)
        .setExecutionContextId(executionContextId)
        .build();
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Runtime.bindingCalled", std::move(messageData)));
}

void Frontend::consoleAPICalled(const String& type, std::unique_ptr<protocol::Array<protocol::Runtime::RemoteObject>> args, int executionContextId, double timestamp, Maybe<protocol::Runtime::StackTrace> stackTrace, Maybe<String> context)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<ConsoleAPICalledNotification> messageData = ConsoleAPICalledNotification::create()
        .setType(type)
        .setArgs(std::move(args))
        .setExecutionContextId(executionContextId)
        .setTimestamp(timestamp)
        .build();
    if (stackTrace.isJust())
        messageData->setStackTrace(std::move(stackTrace).takeJust());
    if (context.isJust())
        messageData->setContext(std::move(context).takeJust());
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Runtime.consoleAPICalled", std::move(messageData)));
}

void Frontend::exceptionRevoked(const String& reason, int exceptionId)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<ExceptionRevokedNotification> messageData = ExceptionRevokedNotification::create()
        .setReason(reason)
        .setExceptionId(exceptionId)
        .build();
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Runtime.exceptionRevoked", std::move(messageData)));
}

void Frontend::exceptionThrown(double timestamp, std::unique_ptr<protocol::Runtime::ExceptionDetails> exceptionDetails)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<ExceptionThrownNotification> messageData = ExceptionThrownNotification::create()
        .setTimestamp(timestamp)
        .setExceptionDetails(std::move(exceptionDetails))
        .build();
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Runtime.exceptionThrown", std::move(messageData)));
}

void Frontend::executionContextCreated(std::unique_ptr<protocol::Runtime::ExecutionContextDescription> context)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<ExecutionContextCreatedNotification> messageData = ExecutionContextCreatedNotification::create()
        .setContext(std::move(context))
        .build();
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Runtime.executionContextCreated", std::move(messageData)));
}

void Frontend::executionContextDestroyed(int executionContextId)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<ExecutionContextDestroyedNotification> messageData = ExecutionContextDestroyedNotification::create()
        .setExecutionContextId(executionContextId)
        .build();
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Runtime.executionContextDestroyed", std::move(messageData)));
}

void Frontend::executionContextsCleared()
{
    if (!frontend_channel_)
        return;
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Runtime.executionContextsCleared"));
}

void Frontend::inspectRequested(std::unique_ptr<protocol::Runtime::RemoteObject> object, std::unique_ptr<protocol::DictionaryValue> hints)
{
    if (!frontend_channel_)
        return;
    std::unique_ptr<InspectRequestedNotification> messageData = InspectRequestedNotification::create()
        .setObject(std::move(object))
        .setHints(std::move(hints))
        .build();
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("Runtime.inspectRequested", std::move(messageData)));
}

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);

    std::function<void(const v8_crdtp::Dispatchable&)> Dispatch(v8_crdtp::span<uint8_t> command_name) override;

    void awaitPromise(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void callFunctionOn(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void compileScript(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void disable(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void discardConsoleEntries(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void enable(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void evaluate(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getIsolateId(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getHeapUsage(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void getProperties(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void globalLexicalScopeNames(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void queryObjects(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void releaseObject(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void releaseObjectGroup(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void runIfWaitingForDebugger(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void runScript(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setCustomObjectFormatterEnabled(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void setMaxCallStackSizeToCapture(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void terminateExecution(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void addBinding(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
    void removeBinding(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(v8_crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<v8_crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          v8_crdtp::SpanFrom("addBinding"),
          &DomainDispatcherImpl::addBinding
    },
    {
          v8_crdtp::SpanFrom("awaitPromise"),
          &DomainDispatcherImpl::awaitPromise
    },
    {
          v8_crdtp::SpanFrom("callFunctionOn"),
          &DomainDispatcherImpl::callFunctionOn
    },
    {
          v8_crdtp::SpanFrom("compileScript"),
          &DomainDispatcherImpl::compileScript
    },
    {
          v8_crdtp::SpanFrom("disable"),
          &DomainDispatcherImpl::disable
    },
    {
          v8_crdtp::SpanFrom("discardConsoleEntries"),
          &DomainDispatcherImpl::discardConsoleEntries
    },
    {
          v8_crdtp::SpanFrom("enable"),
          &DomainDispatcherImpl::enable
    },
    {
          v8_crdtp::SpanFrom("evaluate"),
          &DomainDispatcherImpl::evaluate
    },
    {
          v8_crdtp::SpanFrom("getHeapUsage"),
          &DomainDispatcherImpl::getHeapUsage
    },
    {
          v8_crdtp::SpanFrom("getIsolateId"),
          &DomainDispatcherImpl::getIsolateId
    },
    {
          v8_crdtp::SpanFrom("getProperties"),
          &DomainDispatcherImpl::getProperties
    },
    {
          v8_crdtp::SpanFrom("globalLexicalScopeNames"),
          &DomainDispatcherImpl::globalLexicalScopeNames
    },
    {
          v8_crdtp::SpanFrom("queryObjects"),
          &DomainDispatcherImpl::queryObjects
    },
    {
          v8_crdtp::SpanFrom("releaseObject"),
          &DomainDispatcherImpl::releaseObject
    },
    {
          v8_crdtp::SpanFrom("releaseObjectGroup"),
          &DomainDispatcherImpl::releaseObjectGroup
    },
    {
          v8_crdtp::SpanFrom("removeBinding"),
          &DomainDispatcherImpl::removeBinding
    },
    {
          v8_crdtp::SpanFrom("runIfWaitingForDebugger"),
          &DomainDispatcherImpl::runIfWaitingForDebugger
    },
    {
          v8_crdtp::SpanFrom("runScript"),
          &DomainDispatcherImpl::runScript
    },
    {
          v8_crdtp::SpanFrom("setCustomObjectFormatterEnabled"),
          &DomainDispatcherImpl::setCustomObjectFormatterEnabled
    },
    {
          v8_crdtp::SpanFrom("setMaxCallStackSizeToCapture"),
          &DomainDispatcherImpl::setMaxCallStackSizeToCapture
    },
    {
          v8_crdtp::SpanFrom("terminateExecution"),
          &DomainDispatcherImpl::terminateExecution
    },
    };
    return commands;
  }();
  return v8_crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const v8_crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(v8_crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;
  return [this, handler](const v8_crdtp::Dispatchable& dispatchable){
    std::unique_ptr<DictionaryValue> params =
        DictionaryValue::cast(protocol::Value::parseBinary(dispatchable.Params().data(),
        dispatchable.Params().size()));
    ErrorSupport errors;
    errors.Push();
    (this->*handler)(dispatchable, params.get(), &errors);
  };
}


class AwaitPromiseCallbackImpl : public Backend::AwaitPromiseCallback, public DomainDispatcher::Callback {
public:
    AwaitPromiseCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, v8_crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
v8_crdtp::SpanFrom("Runtime.awaitPromise"), message) { }

    void sendSuccess(std::unique_ptr<protocol::Runtime::RemoteObject> result, Maybe<protocol::Runtime::ExceptionDetails> exceptionDetails) override
    {
        std::vector<uint8_t> result_buffer;
        v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
          v8_crdtp::SerializeField(v8_crdtp::SpanFrom("result"), result, &result_buffer);
          v8_crdtp::SerializeField(v8_crdtp::SpanFrom("exceptionDetails"), exceptionDetails, &result_buffer);
        result_buffer.push_back(v8_crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(v8_crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::awaitPromise(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* promiseObjectIdValue = params ? params->get("promiseObjectId") : nullptr;
    errors->SetName("promiseObjectId");
    String in_promiseObjectId = ValueConversions<String>::fromValue(promiseObjectIdValue, errors);
    protocol::Value* returnByValueValue = params ? params->get("returnByValue") : nullptr;
    Maybe<bool> in_returnByValue;
    if (returnByValueValue) {
        errors->SetName("returnByValue");
        in_returnByValue = ValueConversions<bool>::fromValue(returnByValueValue, errors);
    }
    protocol::Value* generatePreviewValue = params ? params->get("generatePreview") : nullptr;
    Maybe<bool> in_generatePreview;
    if (generatePreviewValue) {
        errors->SetName("generatePreview");
        in_generatePreview = ValueConversions<bool>::fromValue(generatePreviewValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->awaitPromise(in_promiseObjectId, std::move(in_returnByValue), std::move(in_generatePreview), std::make_unique<AwaitPromiseCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class CallFunctionOnCallbackImpl : public Backend::CallFunctionOnCallback, public DomainDispatcher::Callback {
public:
    CallFunctionOnCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, v8_crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
v8_crdtp::SpanFrom("Runtime.callFunctionOn"), message) { }

    void sendSuccess(std::unique_ptr<protocol::Runtime::RemoteObject> result, Maybe<protocol::Runtime::ExceptionDetails> exceptionDetails) override
    {
        std::vector<uint8_t> result_buffer;
        v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
          v8_crdtp::SerializeField(v8_crdtp::SpanFrom("result"), result, &result_buffer);
          v8_crdtp::SerializeField(v8_crdtp::SpanFrom("exceptionDetails"), exceptionDetails, &result_buffer);
        result_buffer.push_back(v8_crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(v8_crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::callFunctionOn(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* functionDeclarationValue = params ? params->get("functionDeclaration") : nullptr;
    errors->SetName("functionDeclaration");
    String in_functionDeclaration = ValueConversions<String>::fromValue(functionDeclarationValue, errors);
    protocol::Value* objectIdValue = params ? params->get("objectId") : nullptr;
    Maybe<String> in_objectId;
    if (objectIdValue) {
        errors->SetName("objectId");
        in_objectId = ValueConversions<String>::fromValue(objectIdValue, errors);
    }
    protocol::Value* argumentsValue = params ? params->get("arguments") : nullptr;
    Maybe<protocol::Array<protocol::Runtime::CallArgument>> in_arguments;
    if (argumentsValue) {
        errors->SetName("arguments");
        in_arguments = ValueConversions<protocol::Array<protocol::Runtime::CallArgument>>::fromValue(argumentsValue, errors);
    }
    protocol::Value* silentValue = params ? params->get("silent") : nullptr;
    Maybe<bool> in_silent;
    if (silentValue) {
        errors->SetName("silent");
        in_silent = ValueConversions<bool>::fromValue(silentValue, errors);
    }
    protocol::Value* returnByValueValue = params ? params->get("returnByValue") : nullptr;
    Maybe<bool> in_returnByValue;
    if (returnByValueValue) {
        errors->SetName("returnByValue");
        in_returnByValue = ValueConversions<bool>::fromValue(returnByValueValue, errors);
    }
    protocol::Value* generatePreviewValue = params ? params->get("generatePreview") : nullptr;
    Maybe<bool> in_generatePreview;
    if (generatePreviewValue) {
        errors->SetName("generatePreview");
        in_generatePreview = ValueConversions<bool>::fromValue(generatePreviewValue, errors);
    }
    protocol::Value* userGestureValue = params ? params->get("userGesture") : nullptr;
    Maybe<bool> in_userGesture;
    if (userGestureValue) {
        errors->SetName("userGesture");
        in_userGesture = ValueConversions<bool>::fromValue(userGestureValue, errors);
    }
    protocol::Value* awaitPromiseValue = params ? params->get("awaitPromise") : nullptr;
    Maybe<bool> in_awaitPromise;
    if (awaitPromiseValue) {
        errors->SetName("awaitPromise");
        in_awaitPromise = ValueConversions<bool>::fromValue(awaitPromiseValue, errors);
    }
    protocol::Value* executionContextIdValue = params ? params->get("executionContextId") : nullptr;
    Maybe<int> in_executionContextId;
    if (executionContextIdValue) {
        errors->SetName("executionContextId");
        in_executionContextId = ValueConversions<int>::fromValue(executionContextIdValue, errors);
    }
    protocol::Value* objectGroupValue = params ? params->get("objectGroup") : nullptr;
    Maybe<String> in_objectGroup;
    if (objectGroupValue) {
        errors->SetName("objectGroup");
        in_objectGroup = ValueConversions<String>::fromValue(objectGroupValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->callFunctionOn(in_functionDeclaration, std::move(in_objectId), std::move(in_arguments), std::move(in_silent), std::move(in_returnByValue), std::move(in_generatePreview), std::move(in_userGesture), std::move(in_awaitPromise), std::move(in_executionContextId), std::move(in_objectGroup), std::make_unique<CallFunctionOnCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

void DomainDispatcherImpl::compileScript(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* expressionValue = params ? params->get("expression") : nullptr;
    errors->SetName("expression");
    String in_expression = ValueConversions<String>::fromValue(expressionValue, errors);
    protocol::Value* sourceURLValue = params ? params->get("sourceURL") : nullptr;
    errors->SetName("sourceURL");
    String in_sourceURL = ValueConversions<String>::fromValue(sourceURLValue, errors);
    protocol::Value* persistScriptValue = params ? params->get("persistScript") : nullptr;
    errors->SetName("persistScript");
    bool in_persistScript = ValueConversions<bool>::fromValue(persistScriptValue, errors);
    protocol::Value* executionContextIdValue = params ? params->get("executionContextId") : nullptr;
    Maybe<int> in_executionContextId;
    if (executionContextIdValue) {
        errors->SetName("executionContextId");
        in_executionContextId = ValueConversions<int>::fromValue(executionContextIdValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    Maybe<String> out_scriptId;
    Maybe<protocol::Runtime::ExceptionDetails> out_exceptionDetails;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->compileScript(in_expression, in_sourceURL, in_persistScript, std::move(in_executionContextId), &out_scriptId, &out_exceptionDetails);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Runtime.compileScript"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("scriptId"), out_scriptId, &result);
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("exceptionDetails"), out_exceptionDetails, &result);
          result.push_back(v8_crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, v8_crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::disable(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->disable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Runtime.disable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::discardConsoleEntries(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->discardConsoleEntries();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Runtime.discardConsoleEntries"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::enable(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->enable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Runtime.enable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class EvaluateCallbackImpl : public Backend::EvaluateCallback, public DomainDispatcher::Callback {
public:
    EvaluateCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, v8_crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
v8_crdtp::SpanFrom("Runtime.evaluate"), message) { }

    void sendSuccess(std::unique_ptr<protocol::Runtime::RemoteObject> result, Maybe<protocol::Runtime::ExceptionDetails> exceptionDetails) override
    {
        std::vector<uint8_t> result_buffer;
        v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
          v8_crdtp::SerializeField(v8_crdtp::SpanFrom("result"), result, &result_buffer);
          v8_crdtp::SerializeField(v8_crdtp::SpanFrom("exceptionDetails"), exceptionDetails, &result_buffer);
        result_buffer.push_back(v8_crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(v8_crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::evaluate(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* expressionValue = params ? params->get("expression") : nullptr;
    errors->SetName("expression");
    String in_expression = ValueConversions<String>::fromValue(expressionValue, errors);
    protocol::Value* objectGroupValue = params ? params->get("objectGroup") : nullptr;
    Maybe<String> in_objectGroup;
    if (objectGroupValue) {
        errors->SetName("objectGroup");
        in_objectGroup = ValueConversions<String>::fromValue(objectGroupValue, errors);
    }
    protocol::Value* includeCommandLineAPIValue = params ? params->get("includeCommandLineAPI") : nullptr;
    Maybe<bool> in_includeCommandLineAPI;
    if (includeCommandLineAPIValue) {
        errors->SetName("includeCommandLineAPI");
        in_includeCommandLineAPI = ValueConversions<bool>::fromValue(includeCommandLineAPIValue, errors);
    }
    protocol::Value* silentValue = params ? params->get("silent") : nullptr;
    Maybe<bool> in_silent;
    if (silentValue) {
        errors->SetName("silent");
        in_silent = ValueConversions<bool>::fromValue(silentValue, errors);
    }
    protocol::Value* contextIdValue = params ? params->get("contextId") : nullptr;
    Maybe<int> in_contextId;
    if (contextIdValue) {
        errors->SetName("contextId");
        in_contextId = ValueConversions<int>::fromValue(contextIdValue, errors);
    }
    protocol::Value* returnByValueValue = params ? params->get("returnByValue") : nullptr;
    Maybe<bool> in_returnByValue;
    if (returnByValueValue) {
        errors->SetName("returnByValue");
        in_returnByValue = ValueConversions<bool>::fromValue(returnByValueValue, errors);
    }
    protocol::Value* generatePreviewValue = params ? params->get("generatePreview") : nullptr;
    Maybe<bool> in_generatePreview;
    if (generatePreviewValue) {
        errors->SetName("generatePreview");
        in_generatePreview = ValueConversions<bool>::fromValue(generatePreviewValue, errors);
    }
    protocol::Value* userGestureValue = params ? params->get("userGesture") : nullptr;
    Maybe<bool> in_userGesture;
    if (userGestureValue) {
        errors->SetName("userGesture");
        in_userGesture = ValueConversions<bool>::fromValue(userGestureValue, errors);
    }
    protocol::Value* awaitPromiseValue = params ? params->get("awaitPromise") : nullptr;
    Maybe<bool> in_awaitPromise;
    if (awaitPromiseValue) {
        errors->SetName("awaitPromise");
        in_awaitPromise = ValueConversions<bool>::fromValue(awaitPromiseValue, errors);
    }
    protocol::Value* throwOnSideEffectValue = params ? params->get("throwOnSideEffect") : nullptr;
    Maybe<bool> in_throwOnSideEffect;
    if (throwOnSideEffectValue) {
        errors->SetName("throwOnSideEffect");
        in_throwOnSideEffect = ValueConversions<bool>::fromValue(throwOnSideEffectValue, errors);
    }
    protocol::Value* timeoutValue = params ? params->get("timeout") : nullptr;
    Maybe<double> in_timeout;
    if (timeoutValue) {
        errors->SetName("timeout");
        in_timeout = ValueConversions<double>::fromValue(timeoutValue, errors);
    }
    protocol::Value* disableBreaksValue = params ? params->get("disableBreaks") : nullptr;
    Maybe<bool> in_disableBreaks;
    if (disableBreaksValue) {
        errors->SetName("disableBreaks");
        in_disableBreaks = ValueConversions<bool>::fromValue(disableBreaksValue, errors);
    }
    protocol::Value* replModeValue = params ? params->get("replMode") : nullptr;
    Maybe<bool> in_replMode;
    if (replModeValue) {
        errors->SetName("replMode");
        in_replMode = ValueConversions<bool>::fromValue(replModeValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->evaluate(in_expression, std::move(in_objectGroup), std::move(in_includeCommandLineAPI), std::move(in_silent), std::move(in_contextId), std::move(in_returnByValue), std::move(in_generatePreview), std::move(in_userGesture), std::move(in_awaitPromise), std::move(in_throwOnSideEffect), std::move(in_timeout), std::move(in_disableBreaks), std::move(in_replMode), std::make_unique<EvaluateCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

void DomainDispatcherImpl::getIsolateId(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Declare output parameters.
    String out_id;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getIsolateId(&out_id);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Runtime.getIsolateId"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("id"), out_id, &result);
          result.push_back(v8_crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, v8_crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::getHeapUsage(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Declare output parameters.
    double out_usedSize;
    double out_totalSize;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getHeapUsage(&out_usedSize, &out_totalSize);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Runtime.getHeapUsage"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("usedSize"), out_usedSize, &result);
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("totalSize"), out_totalSize, &result);
          result.push_back(v8_crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, v8_crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::getProperties(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* objectIdValue = params ? params->get("objectId") : nullptr;
    errors->SetName("objectId");
    String in_objectId = ValueConversions<String>::fromValue(objectIdValue, errors);
    protocol::Value* ownPropertiesValue = params ? params->get("ownProperties") : nullptr;
    Maybe<bool> in_ownProperties;
    if (ownPropertiesValue) {
        errors->SetName("ownProperties");
        in_ownProperties = ValueConversions<bool>::fromValue(ownPropertiesValue, errors);
    }
    protocol::Value* accessorPropertiesOnlyValue = params ? params->get("accessorPropertiesOnly") : nullptr;
    Maybe<bool> in_accessorPropertiesOnly;
    if (accessorPropertiesOnlyValue) {
        errors->SetName("accessorPropertiesOnly");
        in_accessorPropertiesOnly = ValueConversions<bool>::fromValue(accessorPropertiesOnlyValue, errors);
    }
    protocol::Value* generatePreviewValue = params ? params->get("generatePreview") : nullptr;
    Maybe<bool> in_generatePreview;
    if (generatePreviewValue) {
        errors->SetName("generatePreview");
        in_generatePreview = ValueConversions<bool>::fromValue(generatePreviewValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::Runtime::PropertyDescriptor>> out_result;
    Maybe<protocol::Array<protocol::Runtime::InternalPropertyDescriptor>> out_internalProperties;
    Maybe<protocol::Array<protocol::Runtime::PrivatePropertyDescriptor>> out_privateProperties;
    Maybe<protocol::Runtime::ExceptionDetails> out_exceptionDetails;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getProperties(in_objectId, std::move(in_ownProperties), std::move(in_accessorPropertiesOnly), std::move(in_generatePreview), &out_result, &out_internalProperties, &out_privateProperties, &out_exceptionDetails);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Runtime.getProperties"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("result"), out_result, &result);
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("internalProperties"), out_internalProperties, &result);
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("privateProperties"), out_privateProperties, &result);
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("exceptionDetails"), out_exceptionDetails, &result);
          result.push_back(v8_crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, v8_crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::globalLexicalScopeNames(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* executionContextIdValue = params ? params->get("executionContextId") : nullptr;
    Maybe<int> in_executionContextId;
    if (executionContextIdValue) {
        errors->SetName("executionContextId");
        in_executionContextId = ValueConversions<int>::fromValue(executionContextIdValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    std::unique_ptr<protocol::Array<String>> out_names;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->globalLexicalScopeNames(std::move(in_executionContextId), &out_names);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Runtime.globalLexicalScopeNames"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("names"), out_names, &result);
          result.push_back(v8_crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, v8_crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::queryObjects(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* prototypeObjectIdValue = params ? params->get("prototypeObjectId") : nullptr;
    errors->SetName("prototypeObjectId");
    String in_prototypeObjectId = ValueConversions<String>::fromValue(prototypeObjectIdValue, errors);
    protocol::Value* objectGroupValue = params ? params->get("objectGroup") : nullptr;
    Maybe<String> in_objectGroup;
    if (objectGroupValue) {
        errors->SetName("objectGroup");
        in_objectGroup = ValueConversions<String>::fromValue(objectGroupValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;
    // Declare output parameters.
    std::unique_ptr<protocol::Runtime::RemoteObject> out_objects;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->queryObjects(in_prototypeObjectId, std::move(in_objectGroup), &out_objects);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Runtime.queryObjects"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::vector<uint8_t> result;
        if (response.IsSuccess()) {
          v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
          envelope_encoder.EncodeStart(&result);
          result.push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
            v8_crdtp::SerializeField(v8_crdtp::SpanFrom("objects"), out_objects, &result);
          result.push_back(v8_crdtp::cbor::EncodeStop());
          envelope_encoder.EncodeStop(&result);
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, v8_crdtp::Serializable::From(std::move(result)));
      }
    return;
}

void DomainDispatcherImpl::releaseObject(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* objectIdValue = params ? params->get("objectId") : nullptr;
    errors->SetName("objectId");
    String in_objectId = ValueConversions<String>::fromValue(objectIdValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->releaseObject(in_objectId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Runtime.releaseObject"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::releaseObjectGroup(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* objectGroupValue = params ? params->get("objectGroup") : nullptr;
    errors->SetName("objectGroup");
    String in_objectGroup = ValueConversions<String>::fromValue(objectGroupValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->releaseObjectGroup(in_objectGroup);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Runtime.releaseObjectGroup"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::runIfWaitingForDebugger(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->runIfWaitingForDebugger();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Runtime.runIfWaitingForDebugger"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class RunScriptCallbackImpl : public Backend::RunScriptCallback, public DomainDispatcher::Callback {
public:
    RunScriptCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, v8_crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
v8_crdtp::SpanFrom("Runtime.runScript"), message) { }

    void sendSuccess(std::unique_ptr<protocol::Runtime::RemoteObject> result, Maybe<protocol::Runtime::ExceptionDetails> exceptionDetails) override
    {
        std::vector<uint8_t> result_buffer;
        v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
          v8_crdtp::SerializeField(v8_crdtp::SpanFrom("result"), result, &result_buffer);
          v8_crdtp::SerializeField(v8_crdtp::SpanFrom("exceptionDetails"), exceptionDetails, &result_buffer);
        result_buffer.push_back(v8_crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(v8_crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::runScript(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* scriptIdValue = params ? params->get("scriptId") : nullptr;
    errors->SetName("scriptId");
    String in_scriptId = ValueConversions<String>::fromValue(scriptIdValue, errors);
    protocol::Value* executionContextIdValue = params ? params->get("executionContextId") : nullptr;
    Maybe<int> in_executionContextId;
    if (executionContextIdValue) {
        errors->SetName("executionContextId");
        in_executionContextId = ValueConversions<int>::fromValue(executionContextIdValue, errors);
    }
    protocol::Value* objectGroupValue = params ? params->get("objectGroup") : nullptr;
    Maybe<String> in_objectGroup;
    if (objectGroupValue) {
        errors->SetName("objectGroup");
        in_objectGroup = ValueConversions<String>::fromValue(objectGroupValue, errors);
    }
    protocol::Value* silentValue = params ? params->get("silent") : nullptr;
    Maybe<bool> in_silent;
    if (silentValue) {
        errors->SetName("silent");
        in_silent = ValueConversions<bool>::fromValue(silentValue, errors);
    }
    protocol::Value* includeCommandLineAPIValue = params ? params->get("includeCommandLineAPI") : nullptr;
    Maybe<bool> in_includeCommandLineAPI;
    if (includeCommandLineAPIValue) {
        errors->SetName("includeCommandLineAPI");
        in_includeCommandLineAPI = ValueConversions<bool>::fromValue(includeCommandLineAPIValue, errors);
    }
    protocol::Value* returnByValueValue = params ? params->get("returnByValue") : nullptr;
    Maybe<bool> in_returnByValue;
    if (returnByValueValue) {
        errors->SetName("returnByValue");
        in_returnByValue = ValueConversions<bool>::fromValue(returnByValueValue, errors);
    }
    protocol::Value* generatePreviewValue = params ? params->get("generatePreview") : nullptr;
    Maybe<bool> in_generatePreview;
    if (generatePreviewValue) {
        errors->SetName("generatePreview");
        in_generatePreview = ValueConversions<bool>::fromValue(generatePreviewValue, errors);
    }
    protocol::Value* awaitPromiseValue = params ? params->get("awaitPromise") : nullptr;
    Maybe<bool> in_awaitPromise;
    if (awaitPromiseValue) {
        errors->SetName("awaitPromise");
        in_awaitPromise = ValueConversions<bool>::fromValue(awaitPromiseValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    m_backend->runScript(in_scriptId, std::move(in_executionContextId), std::move(in_objectGroup), std::move(in_silent), std::move(in_includeCommandLineAPI), std::move(in_returnByValue), std::move(in_generatePreview), std::move(in_awaitPromise), std::make_unique<RunScriptCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

void DomainDispatcherImpl::setCustomObjectFormatterEnabled(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* enabledValue = params ? params->get("enabled") : nullptr;
    errors->SetName("enabled");
    bool in_enabled = ValueConversions<bool>::fromValue(enabledValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setCustomObjectFormatterEnabled(in_enabled);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Runtime.setCustomObjectFormatterEnabled"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::setMaxCallStackSizeToCapture(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* sizeValue = params ? params->get("size") : nullptr;
    errors->SetName("size");
    int in_size = ValueConversions<int>::fromValue(sizeValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setMaxCallStackSizeToCapture(in_size);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Runtime.setMaxCallStackSizeToCapture"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class TerminateExecutionCallbackImpl : public Backend::TerminateExecutionCallback, public DomainDispatcher::Callback {
public:
    TerminateExecutionCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, v8_crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
v8_crdtp::SpanFrom("Runtime.terminateExecution"), message) { }

    void sendSuccess() override
    {
        std::vector<uint8_t> result_buffer;
        v8_crdtp::cbor::EnvelopeEncoder envelope_encoder;
        envelope_encoder.EncodeStart(&result_buffer);
        result_buffer.push_back(v8_crdtp::cbor::EncodeIndefiniteLengthMapStart());
        result_buffer.push_back(v8_crdtp::cbor::EncodeStop());
        envelope_encoder.EncodeStop(&result_buffer);
        sendIfActive(v8_crdtp::Serializable::From(std::move(result_buffer)), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

void DomainDispatcherImpl::terminateExecution(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{

    m_backend->terminateExecution(std::make_unique<TerminateExecutionCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

void DomainDispatcherImpl::addBinding(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* nameValue = params ? params->get("name") : nullptr;
    errors->SetName("name");
    String in_name = ValueConversions<String>::fromValue(nameValue, errors);
    protocol::Value* executionContextIdValue = params ? params->get("executionContextId") : nullptr;
    Maybe<int> in_executionContextId;
    if (executionContextIdValue) {
        errors->SetName("executionContextId");
        in_executionContextId = ValueConversions<int>::fromValue(executionContextIdValue, errors);
    }
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->addBinding(in_name, std::move(in_executionContextId));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Runtime.addBinding"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

void DomainDispatcherImpl::removeBinding(const v8_crdtp::Dispatchable& dispatchable, DictionaryValue* params, ErrorSupport* errors)
{
    // Prepare input parameters.
    protocol::Value* nameValue = params ? params->get("name") : nullptr;
    errors->SetName("name");
    String in_name = ValueConversions<String>::fromValue(nameValue, errors);
    if (MaybeReportInvalidParams(dispatchable, *errors)) return;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->removeBinding(in_name);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("Runtime.removeBinding"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<v8_crdtp::span<uint8_t>, v8_crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<v8_crdtp::span<uint8_t>, v8_crdtp::span<uint8_t>>>{
          { v8_crdtp::SpanFrom("Runtime.setAsyncCallStackDepth"), v8_crdtp::SpanFrom("Debugger.setAsyncCallStackDepth") },
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(v8_crdtp::SpanFrom("Runtime"), SortedRedirects(), std::move(dispatcher));
}

} // Runtime
} // namespace v8_inspector
} // namespace protocol
