// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/inspector/protocol/CSS.h"

#include "src/inspector/protocol/Protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/find_by_first.h"
#include "third_party/inspector_protocol/crdtp/span.h"

namespace v8_inspector {
namespace protocol {
namespace CSS {

using v8_crdtp::DeserializerState;
using v8_crdtp::ProtocolTypeTraits;

// ------------- Enum values from types.

const char Metainfo::domainName[] = "CSS";
const char Metainfo::commandPrefix[] = "CSS.";
const char Metainfo::version[] = "1.3";


namespace StyleSheetOriginEnum {
const char Injected[] = "injected";
const char UserAgent[] = "user-agent";
const char Inspector[] = "inspector";
const char Regular[] = "regular";
} // namespace StyleSheetOriginEnum


V8_CRDTP_BEGIN_DESERIALIZER(PseudoElementMatches)
    V8_CRDTP_DESERIALIZE_FIELD("matches", m_matches),
    V8_CRDTP_DESERIALIZE_FIELD("pseudoType", m_pseudoType),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(PseudoElementMatches)
    V8_CRDTP_SERIALIZE_FIELD("pseudoType", m_pseudoType);
    V8_CRDTP_SERIALIZE_FIELD("matches", m_matches);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(InheritedStyleEntry)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("inlineStyle", m_inlineStyle),
    V8_CRDTP_DESERIALIZE_FIELD("matchedCSSRules", m_matchedCSSRules),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(InheritedStyleEntry)
    V8_CRDTP_SERIALIZE_FIELD("inlineStyle", m_inlineStyle);
    V8_CRDTP_SERIALIZE_FIELD("matchedCSSRules", m_matchedCSSRules);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(RuleMatch)
    V8_CRDTP_DESERIALIZE_FIELD("matchingSelectors", m_matchingSelectors),
    V8_CRDTP_DESERIALIZE_FIELD("rule", m_rule),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(RuleMatch)
    V8_CRDTP_SERIALIZE_FIELD("rule", m_rule);
    V8_CRDTP_SERIALIZE_FIELD("matchingSelectors", m_matchingSelectors);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(Value)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("range", m_range),
    V8_CRDTP_DESERIALIZE_FIELD("text", m_text),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(Value)
    V8_CRDTP_SERIALIZE_FIELD("text", m_text);
    V8_CRDTP_SERIALIZE_FIELD("range", m_range);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(SelectorList)
    V8_CRDTP_DESERIALIZE_FIELD("selectors", m_selectors),
    V8_CRDTP_DESERIALIZE_FIELD("text", m_text),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(SelectorList)
    V8_CRDTP_SERIALIZE_FIELD("selectors", m_selectors);
    V8_CRDTP_SERIALIZE_FIELD("text", m_text);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(CSSStyleSheetHeader)
    V8_CRDTP_DESERIALIZE_FIELD("disabled", m_disabled),
    V8_CRDTP_DESERIALIZE_FIELD("frameId", m_frameId),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("hasSourceURL", m_hasSourceURL),
    V8_CRDTP_DESERIALIZE_FIELD("isInline", m_isInline),
    V8_CRDTP_DESERIALIZE_FIELD("length", m_length),
    V8_CRDTP_DESERIALIZE_FIELD("origin", m_origin),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("ownerNode", m_ownerNode),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("sourceMapURL", m_sourceMapURL),
    V8_CRDTP_DESERIALIZE_FIELD("sourceURL", m_sourceURL),
    V8_CRDTP_DESERIALIZE_FIELD("startColumn", m_startColumn),
    V8_CRDTP_DESERIALIZE_FIELD("startLine", m_startLine),
    V8_CRDTP_DESERIALIZE_FIELD("styleSheetId", m_styleSheetId),
    V8_CRDTP_DESERIALIZE_FIELD("title", m_title),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(CSSStyleSheetHeader)
    V8_CRDTP_SERIALIZE_FIELD("styleSheetId", m_styleSheetId);
    V8_CRDTP_SERIALIZE_FIELD("frameId", m_frameId);
    V8_CRDTP_SERIALIZE_FIELD("sourceURL", m_sourceURL);
    V8_CRDTP_SERIALIZE_FIELD("sourceMapURL", m_sourceMapURL);
    V8_CRDTP_SERIALIZE_FIELD("origin", m_origin);
    V8_CRDTP_SERIALIZE_FIELD("title", m_title);
    V8_CRDTP_SERIALIZE_FIELD("ownerNode", m_ownerNode);
    V8_CRDTP_SERIALIZE_FIELD("disabled", m_disabled);
    V8_CRDTP_SERIALIZE_FIELD("hasSourceURL", m_hasSourceURL);
    V8_CRDTP_SERIALIZE_FIELD("isInline", m_isInline);
    V8_CRDTP_SERIALIZE_FIELD("startLine", m_startLine);
    V8_CRDTP_SERIALIZE_FIELD("startColumn", m_startColumn);
    V8_CRDTP_SERIALIZE_FIELD("length", m_length);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(CSSRule)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("media", m_media),
    V8_CRDTP_DESERIALIZE_FIELD("origin", m_origin),
    V8_CRDTP_DESERIALIZE_FIELD("selectorList", m_selectorList),
    V8_CRDTP_DESERIALIZE_FIELD("style", m_style),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("styleSheetId", m_styleSheetId),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(CSSRule)
    V8_CRDTP_SERIALIZE_FIELD("styleSheetId", m_styleSheetId);
    V8_CRDTP_SERIALIZE_FIELD("selectorList", m_selectorList);
    V8_CRDTP_SERIALIZE_FIELD("origin", m_origin);
    V8_CRDTP_SERIALIZE_FIELD("style", m_style);
    V8_CRDTP_SERIALIZE_FIELD("media", m_media);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(RuleUsage)
    V8_CRDTP_DESERIALIZE_FIELD("endOffset", m_endOffset),
    V8_CRDTP_DESERIALIZE_FIELD("startOffset", m_startOffset),
    V8_CRDTP_DESERIALIZE_FIELD("styleSheetId", m_styleSheetId),
    V8_CRDTP_DESERIALIZE_FIELD("used", m_used),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(RuleUsage)
    V8_CRDTP_SERIALIZE_FIELD("styleSheetId", m_styleSheetId);
    V8_CRDTP_SERIALIZE_FIELD("startOffset", m_startOffset);
    V8_CRDTP_SERIALIZE_FIELD("endOffset", m_endOffset);
    V8_CRDTP_SERIALIZE_FIELD("used", m_used);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(SourceRange)
    V8_CRDTP_DESERIALIZE_FIELD("endColumn", m_endColumn),
    V8_CRDTP_DESERIALIZE_FIELD("endLine", m_endLine),
    V8_CRDTP_DESERIALIZE_FIELD("startColumn", m_startColumn),
    V8_CRDTP_DESERIALIZE_FIELD("startLine", m_startLine),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(SourceRange)
    V8_CRDTP_SERIALIZE_FIELD("startLine", m_startLine);
    V8_CRDTP_SERIALIZE_FIELD("startColumn", m_startColumn);
    V8_CRDTP_SERIALIZE_FIELD("endLine", m_endLine);
    V8_CRDTP_SERIALIZE_FIELD("endColumn", m_endColumn);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(ShorthandEntry)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("important", m_important),
    V8_CRDTP_DESERIALIZE_FIELD("name", m_name),
    V8_CRDTP_DESERIALIZE_FIELD("value", m_value),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(ShorthandEntry)
    V8_CRDTP_SERIALIZE_FIELD("name", m_name);
    V8_CRDTP_SERIALIZE_FIELD("value", m_value);
    V8_CRDTP_SERIALIZE_FIELD("important", m_important);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(CSSComputedStyleProperty)
    V8_CRDTP_DESERIALIZE_FIELD("name", m_name),
    V8_CRDTP_DESERIALIZE_FIELD("value", m_value),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(CSSComputedStyleProperty)
    V8_CRDTP_SERIALIZE_FIELD("name", m_name);
    V8_CRDTP_SERIALIZE_FIELD("value", m_value);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(CSSStyle)
    V8_CRDTP_DESERIALIZE_FIELD("cssProperties", m_cssProperties),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("cssText", m_cssText),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("range", m_range),
    V8_CRDTP_DESERIALIZE_FIELD("shorthandEntries", m_shorthandEntries),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("styleSheetId", m_styleSheetId),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(CSSStyle)
    V8_CRDTP_SERIALIZE_FIELD("styleSheetId", m_styleSheetId);
    V8_CRDTP_SERIALIZE_FIELD("cssProperties", m_cssProperties);
    V8_CRDTP_SERIALIZE_FIELD("shorthandEntries", m_shorthandEntries);
    V8_CRDTP_SERIALIZE_FIELD("cssText", m_cssText);
    V8_CRDTP_SERIALIZE_FIELD("range", m_range);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(CSSProperty)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("disabled", m_disabled),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("implicit", m_implicit),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("important", m_important),
    V8_CRDTP_DESERIALIZE_FIELD("name", m_name),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("parsedOk", m_parsedOk),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("range", m_range),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("text", m_text),
    V8_CRDTP_DESERIALIZE_FIELD("value", m_value),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(CSSProperty)
    V8_CRDTP_SERIALIZE_FIELD("name", m_name);
    V8_CRDTP_SERIALIZE_FIELD("value", m_value);
    V8_CRDTP_SERIALIZE_FIELD("important", m_important);
    V8_CRDTP_SERIALIZE_FIELD("implicit", m_implicit);
    V8_CRDTP_SERIALIZE_FIELD("text", m_text);
    V8_CRDTP_SERIALIZE_FIELD("parsedOk", m_parsedOk);
    V8_CRDTP_SERIALIZE_FIELD("disabled", m_disabled);
    V8_CRDTP_SERIALIZE_FIELD("range", m_range);
V8_CRDTP_END_SERIALIZER();



const char* CSSMedia::SourceEnum::MediaRule = "mediaRule";
const char* CSSMedia::SourceEnum::ImportRule = "importRule";
const char* CSSMedia::SourceEnum::LinkedSheet = "linkedSheet";
const char* CSSMedia::SourceEnum::InlineSheet = "inlineSheet";
V8_CRDTP_BEGIN_DESERIALIZER(CSSMedia)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("mediaList", m_mediaList),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("range", m_range),
    V8_CRDTP_DESERIALIZE_FIELD("source", m_source),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("sourceURL", m_sourceURL),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("styleSheetId", m_styleSheetId),
    V8_CRDTP_DESERIALIZE_FIELD("text", m_text),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(CSSMedia)
    V8_CRDTP_SERIALIZE_FIELD("text", m_text);
    V8_CRDTP_SERIALIZE_FIELD("source", m_source);
    V8_CRDTP_SERIALIZE_FIELD("sourceURL", m_sourceURL);
    V8_CRDTP_SERIALIZE_FIELD("range", m_range);
    V8_CRDTP_SERIALIZE_FIELD("styleSheetId", m_styleSheetId);
    V8_CRDTP_SERIALIZE_FIELD("mediaList", m_mediaList);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(MediaQuery)
    V8_CRDTP_DESERIALIZE_FIELD("active", m_active),
    V8_CRDTP_DESERIALIZE_FIELD("expressions", m_expressions),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(MediaQuery)
    V8_CRDTP_SERIALIZE_FIELD("expressions", m_expressions);
    V8_CRDTP_SERIALIZE_FIELD("active", m_active);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(MediaQueryExpression)
    V8_CRDTP_DESERIALIZE_FIELD_OPT("computedLength", m_computedLength),
    V8_CRDTP_DESERIALIZE_FIELD("feature", m_feature),
    V8_CRDTP_DESERIALIZE_FIELD("unit", m_unit),
    V8_CRDTP_DESERIALIZE_FIELD("value", m_value),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("valueRange", m_valueRange),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(MediaQueryExpression)
    V8_CRDTP_SERIALIZE_FIELD("value", m_value);
    V8_CRDTP_SERIALIZE_FIELD("unit", m_unit);
    V8_CRDTP_SERIALIZE_FIELD("feature", m_feature);
    V8_CRDTP_SERIALIZE_FIELD("valueRange", m_valueRange);
    V8_CRDTP_SERIALIZE_FIELD("computedLength", m_computedLength);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(PlatformFontUsage)
    V8_CRDTP_DESERIALIZE_FIELD("familyName", m_familyName),
    V8_CRDTP_DESERIALIZE_FIELD("glyphCount", m_glyphCount),
    V8_CRDTP_DESERIALIZE_FIELD("isCustomFont", m_isCustomFont),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(PlatformFontUsage)
    V8_CRDTP_SERIALIZE_FIELD("familyName", m_familyName);
    V8_CRDTP_SERIALIZE_FIELD("isCustomFont", m_isCustomFont);
    V8_CRDTP_SERIALIZE_FIELD("glyphCount", m_glyphCount);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(FontFace)
    V8_CRDTP_DESERIALIZE_FIELD("fontFamily", m_fontFamily),
    V8_CRDTP_DESERIALIZE_FIELD("fontStretch", m_fontStretch),
    V8_CRDTP_DESERIALIZE_FIELD("fontStyle", m_fontStyle),
    V8_CRDTP_DESERIALIZE_FIELD("fontVariant", m_fontVariant),
    V8_CRDTP_DESERIALIZE_FIELD("fontWeight", m_fontWeight),
    V8_CRDTP_DESERIALIZE_FIELD("platformFontFamily", m_platformFontFamily),
    V8_CRDTP_DESERIALIZE_FIELD("src", m_src),
    V8_CRDTP_DESERIALIZE_FIELD("unicodeRange", m_unicodeRange),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(FontFace)
    V8_CRDTP_SERIALIZE_FIELD("fontFamily", m_fontFamily);
    V8_CRDTP_SERIALIZE_FIELD("fontStyle", m_fontStyle);
    V8_CRDTP_SERIALIZE_FIELD("fontVariant", m_fontVariant);
    V8_CRDTP_SERIALIZE_FIELD("fontWeight", m_fontWeight);
    V8_CRDTP_SERIALIZE_FIELD("fontStretch", m_fontStretch);
    V8_CRDTP_SERIALIZE_FIELD("unicodeRange", m_unicodeRange);
    V8_CRDTP_SERIALIZE_FIELD("src", m_src);
    V8_CRDTP_SERIALIZE_FIELD("platformFontFamily", m_platformFontFamily);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(CSSKeyframesRule)
    V8_CRDTP_DESERIALIZE_FIELD("animationName", m_animationName),
    V8_CRDTP_DESERIALIZE_FIELD("keyframes", m_keyframes),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(CSSKeyframesRule)
    V8_CRDTP_SERIALIZE_FIELD("animationName", m_animationName);
    V8_CRDTP_SERIALIZE_FIELD("keyframes", m_keyframes);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(CSSKeyframeRule)
    V8_CRDTP_DESERIALIZE_FIELD("keyText", m_keyText),
    V8_CRDTP_DESERIALIZE_FIELD("origin", m_origin),
    V8_CRDTP_DESERIALIZE_FIELD("style", m_style),
    V8_CRDTP_DESERIALIZE_FIELD_OPT("styleSheetId", m_styleSheetId),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(CSSKeyframeRule)
    V8_CRDTP_SERIALIZE_FIELD("styleSheetId", m_styleSheetId);
    V8_CRDTP_SERIALIZE_FIELD("origin", m_origin);
    V8_CRDTP_SERIALIZE_FIELD("keyText", m_keyText);
    V8_CRDTP_SERIALIZE_FIELD("style", m_style);
V8_CRDTP_END_SERIALIZER();


V8_CRDTP_BEGIN_DESERIALIZER(StyleDeclarationEdit)
    V8_CRDTP_DESERIALIZE_FIELD("range", m_range),
    V8_CRDTP_DESERIALIZE_FIELD("styleSheetId", m_styleSheetId),
    V8_CRDTP_DESERIALIZE_FIELD("text", m_text),
V8_CRDTP_END_DESERIALIZER()

V8_CRDTP_BEGIN_SERIALIZER(StyleDeclarationEdit)
    V8_CRDTP_SERIALIZE_FIELD("styleSheetId", m_styleSheetId);
    V8_CRDTP_SERIALIZE_FIELD("range", m_range);
    V8_CRDTP_SERIALIZE_FIELD("text", m_text);
V8_CRDTP_END_SERIALIZER();


// ------------- Enum values from params.


// ------------- Frontend notifications.

void Frontend::fontsUpdated(Maybe<protocol::CSS::FontFace> font)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("font"), font);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("CSS.fontsUpdated", serializer.Finish()));
}

void Frontend::mediaQueryResultChanged()
{
    if (!frontend_channel_)
        return;
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("CSS.mediaQueryResultChanged"));
}

void Frontend::styleSheetAdded(std::unique_ptr<protocol::CSS::CSSStyleSheetHeader> header)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("header"), header);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("CSS.styleSheetAdded", serializer.Finish()));
}

void Frontend::styleSheetChanged(const String& styleSheetId)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("styleSheetId"), styleSheetId);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("CSS.styleSheetChanged", serializer.Finish()));
}

void Frontend::styleSheetRemoved(const String& styleSheetId)
{
    if (!frontend_channel_)
        return;
    v8_crdtp::ObjectSerializer serializer;
    serializer.AddField(v8_crdtp::MakeSpan("styleSheetId"), styleSheetId);
    frontend_channel_->SendProtocolNotification(v8_crdtp::CreateNotification("CSS.styleSheetRemoved", serializer.Finish()));
}

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const v8_crdtp::Dispatchable& dispatchable);

    std::function<void(const v8_crdtp::Dispatchable&)> Dispatch(v8_crdtp::span<uint8_t> command_name) override;

    void addRule(const v8_crdtp::Dispatchable& dispatchable);
    void collectClassNames(const v8_crdtp::Dispatchable& dispatchable);
    void createStyleSheet(const v8_crdtp::Dispatchable& dispatchable);
    void disable(const v8_crdtp::Dispatchable& dispatchable);
    void enable(const v8_crdtp::Dispatchable& dispatchable);
    void forcePseudoState(const v8_crdtp::Dispatchable& dispatchable);
    void getBackgroundColors(const v8_crdtp::Dispatchable& dispatchable);
    void getComputedStyleForNode(const v8_crdtp::Dispatchable& dispatchable);
    void getInlineStylesForNode(const v8_crdtp::Dispatchable& dispatchable);
    void getMatchedStylesForNode(const v8_crdtp::Dispatchable& dispatchable);
    void getMediaQueries(const v8_crdtp::Dispatchable& dispatchable);
    void getPlatformFontsForNode(const v8_crdtp::Dispatchable& dispatchable);
    void getStyleSheetText(const v8_crdtp::Dispatchable& dispatchable);
    void setEffectivePropertyValueForNode(const v8_crdtp::Dispatchable& dispatchable);
    void setKeyframeKey(const v8_crdtp::Dispatchable& dispatchable);
    void setMediaText(const v8_crdtp::Dispatchable& dispatchable);
    void setRuleSelector(const v8_crdtp::Dispatchable& dispatchable);
    void setStyleSheetText(const v8_crdtp::Dispatchable& dispatchable);
    void setStyleTexts(const v8_crdtp::Dispatchable& dispatchable);
    void startRuleUsageTracking(const v8_crdtp::Dispatchable& dispatchable);
    void stopRuleUsageTracking(const v8_crdtp::Dispatchable& dispatchable);
    void takeCoverageDelta(const v8_crdtp::Dispatchable& dispatchable);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(v8_crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<v8_crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          v8_crdtp::SpanFrom("addRule"),
          &DomainDispatcherImpl::addRule
    },
    {
          v8_crdtp::SpanFrom("collectClassNames"),
          &DomainDispatcherImpl::collectClassNames
    },
    {
          v8_crdtp::SpanFrom("createStyleSheet"),
          &DomainDispatcherImpl::createStyleSheet
    },
    {
          v8_crdtp::SpanFrom("disable"),
          &DomainDispatcherImpl::disable
    },
    {
          v8_crdtp::SpanFrom("enable"),
          &DomainDispatcherImpl::enable
    },
    {
          v8_crdtp::SpanFrom("forcePseudoState"),
          &DomainDispatcherImpl::forcePseudoState
    },
    {
          v8_crdtp::SpanFrom("getBackgroundColors"),
          &DomainDispatcherImpl::getBackgroundColors
    },
    {
          v8_crdtp::SpanFrom("getComputedStyleForNode"),
          &DomainDispatcherImpl::getComputedStyleForNode
    },
    {
          v8_crdtp::SpanFrom("getInlineStylesForNode"),
          &DomainDispatcherImpl::getInlineStylesForNode
    },
    {
          v8_crdtp::SpanFrom("getMatchedStylesForNode"),
          &DomainDispatcherImpl::getMatchedStylesForNode
    },
    {
          v8_crdtp::SpanFrom("getMediaQueries"),
          &DomainDispatcherImpl::getMediaQueries
    },
    {
          v8_crdtp::SpanFrom("getPlatformFontsForNode"),
          &DomainDispatcherImpl::getPlatformFontsForNode
    },
    {
          v8_crdtp::SpanFrom("getStyleSheetText"),
          &DomainDispatcherImpl::getStyleSheetText
    },
    {
          v8_crdtp::SpanFrom("setEffectivePropertyValueForNode"),
          &DomainDispatcherImpl::setEffectivePropertyValueForNode
    },
    {
          v8_crdtp::SpanFrom("setKeyframeKey"),
          &DomainDispatcherImpl::setKeyframeKey
    },
    {
          v8_crdtp::SpanFrom("setMediaText"),
          &DomainDispatcherImpl::setMediaText
    },
    {
          v8_crdtp::SpanFrom("setRuleSelector"),
          &DomainDispatcherImpl::setRuleSelector
    },
    {
          v8_crdtp::SpanFrom("setStyleSheetText"),
          &DomainDispatcherImpl::setStyleSheetText
    },
    {
          v8_crdtp::SpanFrom("setStyleTexts"),
          &DomainDispatcherImpl::setStyleTexts
    },
    {
          v8_crdtp::SpanFrom("startRuleUsageTracking"),
          &DomainDispatcherImpl::startRuleUsageTracking
    },
    {
          v8_crdtp::SpanFrom("stopRuleUsageTracking"),
          &DomainDispatcherImpl::stopRuleUsageTracking
    },
    {
          v8_crdtp::SpanFrom("takeCoverageDelta"),
          &DomainDispatcherImpl::takeCoverageDelta
    },
    };
    return commands;
  }();
  return v8_crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const v8_crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(v8_crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;

  return [this, handler](const v8_crdtp::Dispatchable& dispatchable) {
    (this->*handler)(dispatchable);
  };
}


namespace {

struct addRuleParams : public v8_crdtp::DeserializableProtocolObject<addRuleParams> {
    String styleSheetId;
    String ruleText;
    std::unique_ptr<protocol::CSS::SourceRange> location;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(addRuleParams)
    V8_CRDTP_DESERIALIZE_FIELD("location", location),
    V8_CRDTP_DESERIALIZE_FIELD("ruleText", ruleText),
    V8_CRDTP_DESERIALIZE_FIELD("styleSheetId", styleSheetId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::addRule(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    addRuleParams params;
    addRuleParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    std::unique_ptr<protocol::CSS::CSSRule> out_rule;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->addRule(params.styleSheetId, params.ruleText, std::move(params.location), &out_rule);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("CSS.addRule"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("rule"), out_rule);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct collectClassNamesParams : public v8_crdtp::DeserializableProtocolObject<collectClassNamesParams> {
    String styleSheetId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(collectClassNamesParams)
    V8_CRDTP_DESERIALIZE_FIELD("styleSheetId", styleSheetId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::collectClassNames(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    collectClassNamesParams params;
    collectClassNamesParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    std::unique_ptr<protocol::Array<String>> out_classNames;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->collectClassNames(params.styleSheetId, &out_classNames);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("CSS.collectClassNames"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("classNames"), out_classNames);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct createStyleSheetParams : public v8_crdtp::DeserializableProtocolObject<createStyleSheetParams> {
    String frameId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(createStyleSheetParams)
    V8_CRDTP_DESERIALIZE_FIELD("frameId", frameId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::createStyleSheet(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    createStyleSheetParams params;
    createStyleSheetParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    String out_styleSheetId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->createStyleSheet(params.frameId, &out_styleSheetId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("CSS.createStyleSheet"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("styleSheetId"), out_styleSheetId);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::disable(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->disable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("CSS.disable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class EnableCallbackImpl : public Backend::EnableCallback, public DomainDispatcher::Callback {
public:
    EnableCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, v8_crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
v8_crdtp::SpanFrom("CSS.enable"), message) { }

    void sendSuccess() override
    {
        v8_crdtp::ObjectSerializer serializer;
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {


}  // namespace

void DomainDispatcherImpl::enable(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.


    m_backend->enable(std::make_unique<EnableCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

namespace {

struct forcePseudoStateParams : public v8_crdtp::DeserializableProtocolObject<forcePseudoStateParams> {
    int nodeId;
    std::unique_ptr<protocol::Array<String>> forcedPseudoClasses;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(forcePseudoStateParams)
    V8_CRDTP_DESERIALIZE_FIELD("forcedPseudoClasses", forcedPseudoClasses),
    V8_CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::forcePseudoState(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    forcePseudoStateParams params;
    forcePseudoStateParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->forcePseudoState(params.nodeId, std::move(params.forcedPseudoClasses));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("CSS.forcePseudoState"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct getBackgroundColorsParams : public v8_crdtp::DeserializableProtocolObject<getBackgroundColorsParams> {
    int nodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(getBackgroundColorsParams)
    V8_CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getBackgroundColors(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getBackgroundColorsParams params;
    getBackgroundColorsParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    Maybe<protocol::Array<String>> out_backgroundColors;
    Maybe<String> out_computedFontSize;
    Maybe<String> out_computedFontWeight;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getBackgroundColors(params.nodeId, &out_backgroundColors, &out_computedFontSize, &out_computedFontWeight);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("CSS.getBackgroundColors"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("backgroundColors"), out_backgroundColors);
          serializer.AddField(v8_crdtp::MakeSpan("computedFontSize"), out_computedFontSize);
          serializer.AddField(v8_crdtp::MakeSpan("computedFontWeight"), out_computedFontWeight);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getComputedStyleForNodeParams : public v8_crdtp::DeserializableProtocolObject<getComputedStyleForNodeParams> {
    int nodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(getComputedStyleForNodeParams)
    V8_CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getComputedStyleForNode(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getComputedStyleForNodeParams params;
    getComputedStyleForNodeParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::CSS::CSSComputedStyleProperty>> out_computedStyle;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getComputedStyleForNode(params.nodeId, &out_computedStyle);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("CSS.getComputedStyleForNode"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("computedStyle"), out_computedStyle);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getInlineStylesForNodeParams : public v8_crdtp::DeserializableProtocolObject<getInlineStylesForNodeParams> {
    int nodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(getInlineStylesForNodeParams)
    V8_CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getInlineStylesForNode(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getInlineStylesForNodeParams params;
    getInlineStylesForNodeParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    Maybe<protocol::CSS::CSSStyle> out_inlineStyle;
    Maybe<protocol::CSS::CSSStyle> out_attributesStyle;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getInlineStylesForNode(params.nodeId, &out_inlineStyle, &out_attributesStyle);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("CSS.getInlineStylesForNode"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("inlineStyle"), out_inlineStyle);
          serializer.AddField(v8_crdtp::MakeSpan("attributesStyle"), out_attributesStyle);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getMatchedStylesForNodeParams : public v8_crdtp::DeserializableProtocolObject<getMatchedStylesForNodeParams> {
    int nodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(getMatchedStylesForNodeParams)
    V8_CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getMatchedStylesForNode(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getMatchedStylesForNodeParams params;
    getMatchedStylesForNodeParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    Maybe<protocol::CSS::CSSStyle> out_inlineStyle;
    Maybe<protocol::CSS::CSSStyle> out_attributesStyle;
    Maybe<protocol::Array<protocol::CSS::RuleMatch>> out_matchedCSSRules;
    Maybe<protocol::Array<protocol::CSS::PseudoElementMatches>> out_pseudoElements;
    Maybe<protocol::Array<protocol::CSS::InheritedStyleEntry>> out_inherited;
    Maybe<protocol::Array<protocol::CSS::CSSKeyframesRule>> out_cssKeyframesRules;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getMatchedStylesForNode(params.nodeId, &out_inlineStyle, &out_attributesStyle, &out_matchedCSSRules, &out_pseudoElements, &out_inherited, &out_cssKeyframesRules);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("CSS.getMatchedStylesForNode"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("inlineStyle"), out_inlineStyle);
          serializer.AddField(v8_crdtp::MakeSpan("attributesStyle"), out_attributesStyle);
          serializer.AddField(v8_crdtp::MakeSpan("matchedCSSRules"), out_matchedCSSRules);
          serializer.AddField(v8_crdtp::MakeSpan("pseudoElements"), out_pseudoElements);
          serializer.AddField(v8_crdtp::MakeSpan("inherited"), out_inherited);
          serializer.AddField(v8_crdtp::MakeSpan("cssKeyframesRules"), out_cssKeyframesRules);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::getMediaQueries(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::CSS::CSSMedia>> out_medias;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getMediaQueries(&out_medias);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("CSS.getMediaQueries"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("medias"), out_medias);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getPlatformFontsForNodeParams : public v8_crdtp::DeserializableProtocolObject<getPlatformFontsForNodeParams> {
    int nodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(getPlatformFontsForNodeParams)
    V8_CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getPlatformFontsForNode(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getPlatformFontsForNodeParams params;
    getPlatformFontsForNodeParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::CSS::PlatformFontUsage>> out_fonts;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getPlatformFontsForNode(params.nodeId, &out_fonts);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("CSS.getPlatformFontsForNode"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("fonts"), out_fonts);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getStyleSheetTextParams : public v8_crdtp::DeserializableProtocolObject<getStyleSheetTextParams> {
    String styleSheetId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(getStyleSheetTextParams)
    V8_CRDTP_DESERIALIZE_FIELD("styleSheetId", styleSheetId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getStyleSheetText(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getStyleSheetTextParams params;
    getStyleSheetTextParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    String out_text;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getStyleSheetText(params.styleSheetId, &out_text);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("CSS.getStyleSheetText"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("text"), out_text);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct setEffectivePropertyValueForNodeParams : public v8_crdtp::DeserializableProtocolObject<setEffectivePropertyValueForNodeParams> {
    int nodeId;
    String propertyName;
    String value;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setEffectivePropertyValueForNodeParams)
    V8_CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
    V8_CRDTP_DESERIALIZE_FIELD("propertyName", propertyName),
    V8_CRDTP_DESERIALIZE_FIELD("value", value),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setEffectivePropertyValueForNode(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setEffectivePropertyValueForNodeParams params;
    setEffectivePropertyValueForNodeParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setEffectivePropertyValueForNode(params.nodeId, params.propertyName, params.value);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("CSS.setEffectivePropertyValueForNode"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setKeyframeKeyParams : public v8_crdtp::DeserializableProtocolObject<setKeyframeKeyParams> {
    String styleSheetId;
    std::unique_ptr<protocol::CSS::SourceRange> range;
    String keyText;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setKeyframeKeyParams)
    V8_CRDTP_DESERIALIZE_FIELD("keyText", keyText),
    V8_CRDTP_DESERIALIZE_FIELD("range", range),
    V8_CRDTP_DESERIALIZE_FIELD("styleSheetId", styleSheetId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setKeyframeKey(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setKeyframeKeyParams params;
    setKeyframeKeyParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    std::unique_ptr<protocol::CSS::Value> out_keyText;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setKeyframeKey(params.styleSheetId, std::move(params.range), params.keyText, &out_keyText);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("CSS.setKeyframeKey"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("keyText"), out_keyText);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct setMediaTextParams : public v8_crdtp::DeserializableProtocolObject<setMediaTextParams> {
    String styleSheetId;
    std::unique_ptr<protocol::CSS::SourceRange> range;
    String text;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setMediaTextParams)
    V8_CRDTP_DESERIALIZE_FIELD("range", range),
    V8_CRDTP_DESERIALIZE_FIELD("styleSheetId", styleSheetId),
    V8_CRDTP_DESERIALIZE_FIELD("text", text),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setMediaText(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setMediaTextParams params;
    setMediaTextParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    std::unique_ptr<protocol::CSS::CSSMedia> out_media;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setMediaText(params.styleSheetId, std::move(params.range), params.text, &out_media);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("CSS.setMediaText"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("media"), out_media);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct setRuleSelectorParams : public v8_crdtp::DeserializableProtocolObject<setRuleSelectorParams> {
    String styleSheetId;
    std::unique_ptr<protocol::CSS::SourceRange> range;
    String selector;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setRuleSelectorParams)
    V8_CRDTP_DESERIALIZE_FIELD("range", range),
    V8_CRDTP_DESERIALIZE_FIELD("selector", selector),
    V8_CRDTP_DESERIALIZE_FIELD("styleSheetId", styleSheetId),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setRuleSelector(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setRuleSelectorParams params;
    setRuleSelectorParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    std::unique_ptr<protocol::CSS::SelectorList> out_selectorList;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setRuleSelector(params.styleSheetId, std::move(params.range), params.selector, &out_selectorList);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("CSS.setRuleSelector"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("selectorList"), out_selectorList);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct setStyleSheetTextParams : public v8_crdtp::DeserializableProtocolObject<setStyleSheetTextParams> {
    String styleSheetId;
    String text;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setStyleSheetTextParams)
    V8_CRDTP_DESERIALIZE_FIELD("styleSheetId", styleSheetId),
    V8_CRDTP_DESERIALIZE_FIELD("text", text),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setStyleSheetText(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setStyleSheetTextParams params;
    setStyleSheetTextParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    Maybe<String> out_sourceMapURL;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setStyleSheetText(params.styleSheetId, params.text, &out_sourceMapURL);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("CSS.setStyleSheetText"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("sourceMapURL"), out_sourceMapURL);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct setStyleTextsParams : public v8_crdtp::DeserializableProtocolObject<setStyleTextsParams> {
    std::unique_ptr<protocol::Array<protocol::CSS::StyleDeclarationEdit>> edits;
    DECLARE_DESERIALIZATION_SUPPORT();
};

V8_CRDTP_BEGIN_DESERIALIZER(setStyleTextsParams)
    V8_CRDTP_DESERIALIZE_FIELD("edits", edits),
V8_CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setStyleTexts(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = v8_crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setStyleTextsParams params;
    setStyleTextsParams::Deserialize(&deserializer, &params);
    if (MaybeReportInvalidParams(dispatchable, deserializer))
      return;

    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::CSS::CSSStyle>> out_styles;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setStyleTexts(std::move(params.edits), &out_styles);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("CSS.setStyleTexts"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("styles"), out_styles);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::startRuleUsageTracking(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.


    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->startRuleUsageTracking();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("CSS.startRuleUsageTracking"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::stopRuleUsageTracking(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::CSS::RuleUsage>> out_ruleUsage;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->stopRuleUsageTracking(&out_ruleUsage);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("CSS.stopRuleUsageTracking"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("ruleUsage"), out_ruleUsage);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::takeCoverageDelta(const v8_crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::CSS::RuleUsage>> out_coverage;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->takeCoverageDelta(&out_coverage);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), v8_crdtp::SpanFrom("CSS.takeCoverageDelta"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<v8_crdtp::Serializable> result;
        if (response.IsSuccess()) {
          v8_crdtp::ObjectSerializer serializer;
          serializer.AddField(v8_crdtp::MakeSpan("coverage"), out_coverage);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<v8_crdtp::span<uint8_t>, v8_crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<v8_crdtp::span<uint8_t>, v8_crdtp::span<uint8_t>>>{
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(v8_crdtp::SpanFrom("CSS"), SortedRedirects(), std::move(dispatcher));
}

} // CSS
} // namespace v8_inspector
} // namespace protocol
