#ifndef V8_GEN_TORQUE_GENERATED_EXPORTED_MACROS_ASSEMBLER_H_
#define V8_GEN_TORQUE_GENERATED_EXPORTED_MACROS_ASSEMBLER_H_

#include "src/compiler/code-assembler.h"
#include "src/execution/frames.h"
#include "torque-generated/csa-types.h"
namespace v8 {
namespace internal {
class V8_EXPORT_PRIVATE TorqueGeneratedExportedMacrosAssembler {
 public:
  explicit TorqueGeneratedExportedMacrosAssembler(compiler::CodeAssemblerState* state) : state_(state) {
    USE(state_);
  }
void EnsureArrayLengthWritable(TNode<Context> p_context, TNode<Map> p_map, compiler::CodeAssemblerLabel* label_Bailout);
TNode<Number> ToInteger_Inline(TNode<Context> p_context, TNode<Object> p_input);
TNode<Object> RequireObjectCoercible(TNode<Context> p_context, TNode<Object> p_value, const char* p_name);
TNode<UintPtrT> ChangeUintPtrNumberToUintPtr(TNode<Number> p_value);
TNode<UintPtrT> ChangeSafeIntegerNumberToUintPtr(TNode<Number> p_value, compiler::CodeAssemblerLabel* label_IfUIntPtrOverflow);
TNode<UintPtrT> ToIndex(TNode<Context> p_context, TNode<Object> p_value, compiler::CodeAssemblerLabel* label_IfRangeError);
TNode<UintPtrT> ConvertToRelativeIndex(TNode<Context> p_context, TNode<Object> p_index, TNode<UintPtrT> p_length);
TNode<UintPtrT> ConvertToRelativeIndex(TNode<Number> p_indexNumber, TNode<UintPtrT> p_length);
TNode<UintPtrT> ClampToIndexRange(TNode<Context> p_context, TNode<Object> p_index, TNode<UintPtrT> p_limit);
TNode<UintPtrT> ClampToIndexRange(TNode<Number> p_indexNumber, TNode<UintPtrT> p_limit);
TNode<BoolT> IsFastJSArray(TNode<Object> p_o, TNode<Context> p_context);
void BranchIfFastJSArray(TNode<Object> p_o, TNode<Context> p_context, compiler::CodeAssemblerLabel* label_True, compiler::CodeAssemblerLabel* label_False);
void BranchIfFastJSArrayForRead(TNode<Object> p_o, TNode<Context> p_context, compiler::CodeAssemblerLabel* label_True, compiler::CodeAssemblerLabel* label_False);
TNode<BoolT> IsFastJSArrayWithNoCustomIteration(TNode<Context> p_context, TNode<Object> p_o);
TNode<BoolT> IsFastJSArrayForReadWithNoCustomIteration(TNode<Context> p_context, TNode<Object> p_o);
TNode<BoolT> IsIntegerOrSomeInfinity(TNode<Object> p_o);
TNode<String> ToStringImpl(TNode<Context> p_context, TNode<Object> p_o);
TNode<BoolT> IsAccessorInfo(TNode<HeapObject> p_o);
TNode<BoolT> IsAccessorPair(TNode<HeapObject> p_o);
TNode<BoolT> IsAllocationSite(TNode<HeapObject> p_o);
TNode<BoolT> IsCell(TNode<HeapObject> p_o);
TNode<BoolT> IsCode(TNode<HeapObject> p_o);
TNode<BoolT> IsCodeDataContainer(TNode<HeapObject> p_o);
TNode<BoolT> IsContext(TNode<HeapObject> p_o);
TNode<BoolT> IsCoverageInfo(TNode<HeapObject> p_o);
TNode<BoolT> IsDebugInfo(TNode<HeapObject> p_o);
TNode<BoolT> IsFixedDoubleArray(TNode<HeapObject> p_o);
TNode<BoolT> IsFeedbackCell(TNode<HeapObject> p_o);
TNode<BoolT> IsFeedbackVector(TNode<HeapObject> p_o);
TNode<BoolT> IsHeapNumber(TNode<HeapObject> p_o);
TNode<BoolT> IsNativeContext(TNode<HeapObject> p_o);
TNode<BoolT> IsNumber(TNode<Object> p_o);
TNode<BoolT> IsPrivateSymbol(TNode<HeapObject> p_o);
TNode<BoolT> IsPromiseCapability(TNode<HeapObject> p_o);
TNode<BoolT> IsPromiseFulfillReactionJobTask(TNode<HeapObject> p_o);
TNode<BoolT> IsPromiseReaction(TNode<HeapObject> p_o);
TNode<BoolT> IsPromiseRejectReactionJobTask(TNode<HeapObject> p_o);
TNode<BoolT> IsSharedFunctionInfo(TNode<HeapObject> p_o);
TNode<BoolT> IsSymbol(TNode<HeapObject> p_o);
TorqueStructKeyValuePair LoadKeyValuePairNoSideEffects(TNode<Context> p_context, TNode<Object> p_o, compiler::CodeAssemblerLabel* label_MayHaveSideEffects);
TorqueStructKeyValuePair LoadKeyValuePair(TNode<Context> p_context, TNode<Object> p_o);
TNode<JSFunction> LoadTargetFromFrame();
TNode<Int32T> DynamicCheckMaps(TNode<Map> p_actualMap, TNode<IntPtrT> p_slotIndex, TNode<Object> p_actualHandler);
TNode<Int32T> DynamicCheckMapsWithFeedbackVector(TNode<Map> p_actualMap, TNode<IntPtrT> p_slotIndex, TNode<Object> p_actualHandler, TNode<FeedbackVector> p_feedbackVector);
void CollectCallFeedback(TNode<Object> p_maybeTarget, std::function<TNode<Object>()> p_maybeReceiver, TNode<Context> p_context, TNode<HeapObject> p_maybeFeedbackVector, TNode<UintPtrT> p_slotId);
void CollectInstanceOfFeedback(TNode<Object> p_maybeTarget, TNode<Context> p_context, TNode<HeapObject> p_maybeFeedbackVector, TNode<UintPtrT> p_slotId);
void CollectConstructFeedback(TNode<Context> p_context, TNode<Object> p_target, TNode<Object> p_newTarget, TNode<HeapObject> p_maybeFeedbackVector, TNode<UintPtrT> p_slotId, UpdateFeedbackMode p_updateFeedbackMode, compiler::CodeAssemblerLabel* label_ConstructGeneric, compiler::CodeAssemblerLabel* label_ConstructArray, compiler::TypedCodeAssemblerVariable<AllocationSite>* label_ConstructArray_parameter_0);
TNode<Object> ForInNextSlow(TNode<Context> p_context, TNode<UintPtrT> p_slot, TNode<HeapObject> p_receiver, TNode<Object> p_key, TNode<Object> p_cacheType, TNode<HeapObject> p_maybeFeedbackVector, UpdateFeedbackMode p_guaranteedFeedback);
void IteratorCloseOnException(TNode<Context> p_context, TorqueStructIteratorRecord p_iterator);
TNode<Number> MathPowImpl(TNode<Context> p_context, TNode<Object> p_base, TNode<Object> p_exponent);
TNode<String> NumberToStringSmi(TNode<Int32T> p_x, TNode<Int32T> p_radix, compiler::CodeAssemblerLabel* label_Slow);
TNode<Context> CreatePromiseCapabilitiesExecutorContext(TNode<NativeContext> p_nativeContext, TNode<PromiseCapability> p_capability);
TNode<PromiseCapability> CreatePromiseCapability(TNode<HeapObject> p_promise, TNode<HeapObject> p_resolve, TNode<HeapObject> p_reject);
TorqueStructPromiseResolvingFunctions CreatePromiseResolvingFunctions(TNode<Context> p_context, TNode<JSPromise> p_promise, TNode<Oddball> p_debugEvent, TNode<NativeContext> p_nativeContext);
void PerformPromiseThenImpl(TNode<Context> p_context, TNode<JSPromise> p_promise, TNode<HeapObject> p_onFulfilled, TNode<HeapObject> p_onRejected, TNode<HeapObject> p_resultPromiseOrCapability);
TNode<Context> CreatePromiseResolvingFunctionsContext(TNode<Context> p_context, TNode<JSPromise> p_promise, TNode<Oddball> p_debugEvent, TNode<NativeContext> p_nativeContext);
TNode<BoolT> PromiseHasHandler(TNode<JSPromise> p_promise);
void PromiseInit(TNode<JSPromise> p_promise);
void RunContextPromiseHookInit(TNode<Context> p_context, TNode<JSPromise> p_promise, TNode<Object> p_parent);
void RunContextPromiseHookResolve(TNode<Context> p_context, TNode<JSPromise> p_promise);
void RunContextPromiseHookResolve(TNode<Context> p_context, TNode<JSPromise> p_promise, TNode<Uint32T> p_flags);
void RunContextPromiseHookBefore(TNode<Context> p_context, TNode<HeapObject> p_promiseOrCapability);
void RunContextPromiseHookBefore(TNode<Context> p_context, TNode<HeapObject> p_promiseOrCapability, TNode<Uint32T> p_flags);
void RunContextPromiseHookAfter(TNode<Context> p_context, TNode<HeapObject> p_promiseOrCapability);
void RunContextPromiseHookAfter(TNode<Context> p_context, TNode<HeapObject> p_promiseOrCapability, TNode<Uint32T> p_flags);
TNode<JSPromise> NewJSPromise(TNode<Context> p_context, TNode<Object> p_parent);
TNode<JSPromise> NewJSPromise(TNode<Context> p_context);
TNode<JSPromise> NewJSPromise(TNode<Context> p_context, Promise::PromiseState p_status, TNode<Object> p_result);
TNode<Object> RegExpPrototypeExecBodyFast(TNode<Context> p_context, TNode<JSReceiver> p_receiver, TNode<String> p_string);
TNode<Object> RegExpPrototypeMatchAllImpl(TNode<Context> p_context, TNode<NativeContext> p_nativeContext, TNode<Object> p_receiver, TNode<Object> p_string);
TNode<BoolT> IsFastRegExpPermissive(TNode<Context> p_context, TNode<HeapObject> p_o);
TNode<Object> RegExpExec(TNode<Context> p_context, TNode<JSReceiver> p_receiver, TNode<String> p_string);
TNode<RegExpMatchInfo> RegExpPrototypeExecBodyWithoutResultFast(TNode<Context> p_context, TNode<JSRegExp> p_regexp, TNode<String> p_string, compiler::CodeAssemblerLabel* label_IfDidNotMatch);
TNode<Object> LoadLastIndex(TNode<Context> p_context, TNode<Object> p_regexp, bool p_isFastPath);
TNode<Number> LoadLastIndexAsLength(TNode<Context> p_context, TNode<JSRegExp> p_regexp, bool p_isFastPath);
void StoreLastIndex(TNode<Context> p_context, TNode<Object> p_regexp, TNode<Number> p_value, bool p_isFastPath);
TNode<BoolT> IsRegExp(TNode<Context> p_context, TNode<Object> p_obj);
TNode<Object> RegExpCreate(TNode<Context> p_context, TNode<NativeContext> p_nativeContext, TNode<Object> p_maybeString, TNode<String> p_flags);
TNode<Object> RegExpCreate(TNode<Context> p_context, TNode<Map> p_initialMap, TNode<Object> p_maybeString, TNode<String> p_flags);
TNode<BoolT> IsWhiteSpaceOrLineTerminator(TNode<Uint16T> p_charCode);
TNode<JSTypedArray> TypedArrayCreateByLength(TNode<Context> p_context, TNode<JSReceiver> p_constructor, TNode<Number> p_length, const char* p_methodName);
TNode<JSTypedArray> TypedArraySpeciesCreateByLength(TNode<Context> p_context, const char* p_methodName, TNode<JSTypedArray> p_exemplar, TNode<UintPtrT> p_length);
TNode<BoolT> IsJSArgumentsObjectWithLength(TNode<Context> p_context, TNode<Object> p_o);
TNode<JSArray> EmitFastNewAllArguments(TNode<Context> p_context, TNode<RawPtrT> p_frame, TNode<IntPtrT> p_argc);
TNode<JSArray> EmitFastNewRestArguments(TNode<Context> p_context, TNode<JSFunction> p__f);
TNode<JSArgumentsObject> EmitFastNewStrictArguments(TNode<Context> p_context, TNode<JSFunction> p__f);
TNode<JSArgumentsObject> EmitFastNewSloppyArguments(TNode<Context> p_context, TNode<JSFunction> p_f);
TNode<Object> SloppyArgumentsLoad(TNode<JSObject> p_receiver, TNode<Object> p_keyObject, compiler::CodeAssemblerLabel* label_Bailout);
TNode<Object> SloppyArgumentsHas(TNode<JSObject> p_receiver, TNode<Object> p_keyObject, compiler::CodeAssemblerLabel* label_Bailout);
TNode<Object> SloppyArgumentsStore(TNode<JSObject> p_receiver, TNode<Object> p_keyObject, TNode<Object> p_value, compiler::CodeAssemblerLabel* label_Bailout);
TNode<Context> AllocateSyntheticFunctionContext(TNode<NativeContext> p_nativeContext, int31_t p_slots);
TNode<Object> LoadContextElement(TNode<Context> p_c, TNode<IntPtrT> p_i);
TNode<Object> LoadContextElement(TNode<Context> p_c, TNode<Smi> p_i);
TNode<Object> LoadContextElement(TNode<Context> p_c, int32_t p_i);
void StoreContextElement(TNode<Context> p_c, TNode<IntPtrT> p_i, TNode<Object> p_o);
void StoreContextElement(TNode<Context> p_c, TNode<Smi> p_i, TNode<Object> p_o);
void StoreContextElement(TNode<Context> p_c, int32_t p_i, TNode<Object> p_o);
TNode<BoolT> IsDetachedBuffer(TNode<JSArrayBuffer> p_buffer);
TNode<BoolT> IsSharedArrayBuffer(TNode<JSArrayBuffer> p_buffer);
TNode<BoolT> IsResizableArrayBuffer(TNode<JSArrayBuffer> p_buffer);
TNode<BoolT> IsVariableLengthTypedArray(TNode<JSTypedArray> p_array);
TNode<BoolT> IsLengthTrackingTypedArray(TNode<JSTypedArray> p_array);
TNode<JSArrayIterator> CreateArrayIterator(TNode<NativeContext> p_context, TNode<JSReceiver> p_array, IterationKind p_kind);
TNode<PrototypeInfo> LoadMapPrototypeInfo(TNode<Map> p_m, compiler::CodeAssemblerLabel* label_HasNoPrototypeInfo);
TNode<BoolT> IsSimpleObjectMap(TNode<Map> p_map);
TNode<SmallOrderedHashSet> AllocateSmallOrderedHashSet(TNode<IntPtrT> p_capacity);
TNode<SmallOrderedHashMap> AllocateSmallOrderedHashMap(TNode<IntPtrT> p_capacity);
TNode<IntPtrT> IndexOfLocalName(TNode<ScopeInfo> p_scopeInfo, TNode<Name> p_name, compiler::CodeAssemblerLabel* label_NotFound);
TNode<String> AllocateSeqOneByteString(TNode<Uint32T> p_length);
TNode<String> AllocateSeqTwoByteString(TNode<Uint32T> p_length);
TNode<IntPtrT> SwissNameDictionaryCapacityFor(TNode<IntPtrT> p_atLeastSpaceFor);
TNode<IntPtrT> SwissNameDictionaryMaxUsableCapacity(TNode<IntPtrT> p_capacity);
TNode<IntPtrT> SwissNameDictionarySizeFor(TNode<IntPtrT> p_capacity);
TNode<IntPtrT> SwissNameDictionaryMetaTableSizePerEntryFor(TNode<IntPtrT> p_capacity);
TNode<IntPtrT> SwissNameDictionaryMetaTableSizeFor(TNode<IntPtrT> p_capacity);
TNode<IntPtrT> SwissNameDictionaryDataTableStartOffsetMT();
TNode<IntPtrT> SwissNameDictionaryCtrlTableStartOffsetMT(TNode<IntPtrT> p_capacity);
void SwissNameDictionaryDelete(TNode<SwissNameDictionary> p_table, TNode<IntPtrT> p_entry, compiler::CodeAssemblerLabel* label_Shrunk, compiler::TypedCodeAssemblerVariable<SwissNameDictionary>* label_Shrunk_parameter_0);
void SwissNameDictionaryFindEntrySIMD(TNode<SwissNameDictionary> p_table, TNode<Name> p_key, compiler::CodeAssemblerLabel* label_Found, compiler::TypedCodeAssemblerVariable<IntPtrT>* label_Found_parameter_0, compiler::CodeAssemblerLabel* label_NotFound);
void SwissNameDictionaryFindEntryPortable(TNode<SwissNameDictionary> p_table, TNode<Name> p_key, compiler::CodeAssemblerLabel* label_Found, compiler::TypedCodeAssemblerVariable<IntPtrT>* label_Found_parameter_0, compiler::CodeAssemblerLabel* label_NotFound);
void SwissNameDictionaryAddSIMD(TNode<SwissNameDictionary> p_table, TNode<Name> p_key, TNode<Object> p_value, TNode<Uint8T> p_propertyDetails, compiler::CodeAssemblerLabel* label_Bailout);
void SwissNameDictionaryAddPortable(TNode<SwissNameDictionary> p_table, TNode<Name> p_key, TNode<Object> p_value, TNode<Uint8T> p_propertyDetails, compiler::CodeAssemblerLabel* label_Bailout);
void TestConstexpr1();
void TestConstexprIf();
void TestConstexprReturn();
TNode<Oddball> TestGotoLabel();
TNode<Oddball> TestGotoLabelWithOneParameter();
TNode<Oddball> TestGotoLabelWithTwoParameters();
void TestBuiltinSpecialization();
TNode<Oddball> TestPartiallyUnusedLabel();
void TestMacroSpecialization();
TNode<Oddball> TestFunctionPointers(TNode<Context> p_context);
TNode<Oddball> TestVariableRedeclaration(TNode<Context> p_context);
TNode<Smi> TestTernaryOperator(TNode<Smi> p_x);
void TestFunctionPointerToGeneric();
TNode<BuiltinPtr> TestTypeAlias(TNode<BuiltinPtr> p_x);
TNode<Oddball> TestUnsafeCast(TNode<Context> p_context, TNode<Number> p_n);
void TestHexLiteral();
void TestLargeIntegerLiterals(TNode<Context> p_c);
void TestMultilineAssert();
void TestNewlineInString();
void TestModuleConstBindings();
void TestLocalConstBindings();
TNode<Smi> TestStruct1(TorqueStructTestStructA_0 p_i);
TorqueStructTestStructA_0 TestStruct2(TNode<Context> p_context);
TorqueStructTestStructA_0 TestStruct3(TNode<Context> p_context);
TorqueStructTestStructC_0 TestStruct4(TNode<Context> p_context);
void CallTestStructInLabel(TNode<Context> p_context);
void TestForLoop();
void TestSubtyping(TNode<Smi> p_x);
void TestTypeswitch(TNode<Context> p_context);
void TestTypeswitchAsanLsanFailure(TNode<Context> p_context, TNode<Object> p_obj);
void TestGenericOverload(TNode<Context> p_context);
void TestEquality(TNode<Context> p_context);
TNode<BoolT> TestOrAnd(TNode<BoolT> p_x, TNode<BoolT> p_y, TNode<BoolT> p_z);
TNode<BoolT> TestAndOr(TNode<BoolT> p_x, TNode<BoolT> p_y, TNode<BoolT> p_z);
void TestLogicalOperators();
TNode<Smi> TestCall(TNode<Smi> p_i, compiler::CodeAssemblerLabel* label_A);
void TestOtherwiseWithCode1();
void TestOtherwiseWithCode2();
void TestOtherwiseWithCode3();
void TestForwardLabel();
void TestQualifiedAccess(TNode<Context> p_context);
TNode<Smi> TestCatch1(TNode<Context> p_context);
void TestCatch2Wrapper(TNode<Context> p_context);
TNode<Smi> TestCatch2(TNode<Context> p_context);
void TestCatch3WrapperWithLabel(TNode<Context> p_context, compiler::CodeAssemblerLabel* label__Abort);
TNode<Smi> TestCatch3(TNode<Context> p_context);
void TestIterator(TNode<Context> p_context, TNode<JSReceiver> p_o, TNode<Map> p_map);
void TestFrame1(TNode<Context> p_context);
void TestNew(TNode<Context> p_context);
void TestStructConstructor(TNode<Context> p_context);
void TestInternalClass(TNode<Context> p_context);
void TestConstInStructs();
void TestParentFrameArguments(TNode<Context> p_context);
TNode<Object> TestNewFixedArrayFromSpread(TNode<Context> p_context);
void TestReferences();
void TestSlices();
TNode<Oddball> TestSliceEnumeration(TNode<Context> p_context);
void TestStaticAssert();
void TestLoadEliminationFixed(TNode<Context> p_context);
void TestLoadEliminationVariable(TNode<Context> p_context);
TNode<Smi> TestRedundantArrayElementCheck(TNode<Context> p_context);
TNode<Smi> TestRedundantSmiCheck(TNode<Context> p_context);
TNode<IntPtrT> TestGenericStruct1();
TorqueStructTestTuple_TestTuple_intptr_Smi_TestTuple_Smi_intptr_0 TestGenericStruct2();
void TestBranchOnBoolOptimization(TNode<Context> p_context, TNode<Smi> p_input);
void TestBitFieldLoad(TNode<Uint8T> p_val, TNode<BoolT> p_expectedA, TNode<Uint16T> p_expectedB, TNode<Uint32T> p_expectedC, TNode<BoolT> p_expectedD);
void TestBitFieldStore(TNode<Uint8T> p_val);
void TestBitFieldInit(TNode<BoolT> p_a, TNode<Uint16T> p_b, TNode<Uint32T> p_c, TNode<BoolT> p_d);
void TestBitFieldUintptrOps(TNode<Uint32T> p_val2, TNode<UintPtrT> p_val3);
void TestBitFieldMultipleFlags(TNode<BoolT> p_a, TNode<Int32T> p_b, TNode<BoolT> p_c);
void TestFullyGeneratedClassWithElements();
TNode<ExportedSubClass> TestFullyGeneratedClassFromCpp();
void TestGeneratedCastOperators(TNode<Context> p_context);
void TestNewPretenured(TNode<Context> p_context);
void TestWord8Phi();
void TestOffHeapSlice(TNode<RawPtrT> p_ptr, TNode<IntPtrT> p_length);
void TestCallMultiReturnBuiltin(TNode<Context> p_context);
TNode<Smi> TestRunLazyTwice(std::function<TNode<Smi>()> p_lazySmi);
void TestCreateLazyNodeFromTorque();
TNode<Map> LoadHeapObjectMap(TNode<HeapObject> p_o);
TNode<Smi> LoadContextLength(TNode<Context> p_o);
TorqueStructSlice_Object_MutableReference_Object_0 FieldSliceContextElements(TNode<Context> p_o);
TNode<Object> LoadContextElements(TNode<Context> p_o, TNode<IntPtrT> p_i);
void StoreContextElements(TNode<Context> p_o, TNode<IntPtrT> p_i, TNode<Object> p_v);
TNode<Object> LoadJSReceiverPropertiesOrHash(TNode<JSReceiver> p_o);
void StoreJSReceiverPropertiesOrHash(TNode<JSReceiver> p_o, TNode<Object> p_v);
TNode<Float64T> LoadHeapNumberValue(TNode<HeapNumber> p_o);
void StoreHeapNumberValue(TNode<HeapNumber> p_o, TNode<Float64T> p_v);
TNode<Uint32T> LoadNameRawHashField(TNode<Name> p_o);
void StoreNameRawHashField(TNode<Name> p_o, TNode<Uint32T> p_v);
TNode<Int32T> LoadStringLength(TNode<String> p_o);
TNode<Uint32T> LoadSymbolFlags(TNode<Symbol> p_o);
void StoreSymbolFlags(TNode<Symbol> p_o, TNode<Uint32T> p_v);
TNode<PrimitiveHeapObject> LoadSymbolDescription(TNode<Symbol> p_o);
void StoreSymbolDescription(TNode<Symbol> p_o, TNode<PrimitiveHeapObject> p_v);
TNode<Float64T> LoadOddballToNumberRaw(TNode<Oddball> p_o);
void StoreOddballToNumberRaw(TNode<Oddball> p_o, TNode<Float64T> p_v);
TNode<String> LoadOddballToString(TNode<Oddball> p_o);
void StoreOddballToString(TNode<Oddball> p_o, TNode<String> p_v);
TNode<Number> LoadOddballToNumber(TNode<Oddball> p_o);
void StoreOddballToNumber(TNode<Oddball> p_o, TNode<Number> p_v);
TNode<String> LoadOddballTypeOf(TNode<Oddball> p_o);
void StoreOddballTypeOf(TNode<Oddball> p_o, TNode<String> p_v);
TNode<Smi> LoadOddballKind(TNode<Oddball> p_o);
void StoreOddballKind(TNode<Oddball> p_o, TNode<Smi> p_v);
TNode<Smi> LoadFixedArrayBaseLength(TNode<FixedArrayBase> p_o);
TorqueStructSlice_Object_MutableReference_Object_0 FieldSliceFixedArrayObjects(TNode<FixedArray> p_o);
TNode<Object> LoadFixedArrayObjects(TNode<FixedArray> p_o, TNode<IntPtrT> p_i);
void StoreFixedArrayObjects(TNode<FixedArray> p_o, TNode<IntPtrT> p_i, TNode<Object> p_v);
TNode<FixedArrayBase> LoadJSObjectElements(TNode<JSObject> p_o);
void StoreJSObjectElements(TNode<JSObject> p_o, TNode<FixedArrayBase> p_v);
TorqueStructSlice_uint8_MutableReference_uint8_0 FieldSliceByteArrayBytes(TNode<ByteArray> p_o);
TNode<Uint8T> LoadByteArrayBytes(TNode<ByteArray> p_o, TNode<IntPtrT> p_i);
void StoreByteArrayBytes(TNode<ByteArray> p_o, TNode<IntPtrT> p_i, TNode<Uint8T> p_v);
TNode<Smi> LoadWeakFixedArrayLength(TNode<WeakFixedArray> p_o);
TorqueStructSlice_MaybeObject_MutableReference_MaybeObject_0 FieldSliceWeakFixedArrayObjects(TNode<WeakFixedArray> p_o);
TNode<MaybeObject> LoadWeakFixedArrayObjects(TNode<WeakFixedArray> p_o, TNode<IntPtrT> p_i);
void StoreWeakFixedArrayObjects(TNode<WeakFixedArray> p_o, TNode<IntPtrT> p_i, TNode<MaybeObject> p_v);
TNode<ExternalPointerT> LoadForeignForeignAddress(TNode<Foreign> p_o);
void StoreForeignForeignAddress(TNode<Foreign> p_o, TNode<ExternalPointerT> p_v);
TNode<HeapObject> LoadJSProxyTarget(TNode<JSProxy> p_o);
void StoreJSProxyTarget(TNode<JSProxy> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadJSProxyHandler(TNode<JSProxy> p_o);
void StoreJSProxyHandler(TNode<JSProxy> p_o, TNode<HeapObject> p_v);
TNode<SharedFunctionInfo> LoadJSFunctionSharedFunctionInfo(TNode<JSFunction> p_o);
void StoreJSFunctionSharedFunctionInfo(TNode<JSFunction> p_o, TNode<SharedFunctionInfo> p_v);
TNode<Context> LoadJSFunctionContext(TNode<JSFunction> p_o);
void StoreJSFunctionContext(TNode<JSFunction> p_o, TNode<Context> p_v);
TNode<FeedbackCell> LoadJSFunctionFeedbackCell(TNode<JSFunction> p_o);
void StoreJSFunctionFeedbackCell(TNode<JSFunction> p_o, TNode<FeedbackCell> p_v);
TNode<Code> LoadJSFunctionCode(TNode<JSFunction> p_o);
void StoreJSFunctionCode(TNode<JSFunction> p_o, TNode<Code> p_v);
TNode<HeapObject> LoadJSFunctionPrototypeOrInitialMap(TNode<JSFunction> p_o);
void StoreJSFunctionPrototypeOrInitialMap(TNode<JSFunction> p_o, TNode<HeapObject> p_v);
TNode<JSReceiver> LoadJSBoundFunctionBoundTargetFunction(TNode<JSBoundFunction> p_o);
void StoreJSBoundFunctionBoundTargetFunction(TNode<JSBoundFunction> p_o, TNode<JSReceiver> p_v);
TNode<Object> LoadJSBoundFunctionBoundThis(TNode<JSBoundFunction> p_o);
void StoreJSBoundFunctionBoundThis(TNode<JSBoundFunction> p_o, TNode<Object> p_v);
TNode<FixedArray> LoadJSBoundFunctionBoundArguments(TNode<JSBoundFunction> p_o);
void StoreJSBoundFunctionBoundArguments(TNode<JSBoundFunction> p_o, TNode<FixedArray> p_v);
TNode<Uint8T> LoadMapInstanceSizeInWords(TNode<Map> p_o);
void StoreMapInstanceSizeInWords(TNode<Map> p_o, TNode<Uint8T> p_v);
TNode<Uint8T> LoadMapInObjectPropertiesStartOrConstructorFunctionIndex(TNode<Map> p_o);
void StoreMapInObjectPropertiesStartOrConstructorFunctionIndex(TNode<Map> p_o, TNode<Uint8T> p_v);
TNode<Uint8T> LoadMapUsedOrUnusedInstanceSizeInWords(TNode<Map> p_o);
void StoreMapUsedOrUnusedInstanceSizeInWords(TNode<Map> p_o, TNode<Uint8T> p_v);
TNode<Uint8T> LoadMapVisitorId(TNode<Map> p_o);
void StoreMapVisitorId(TNode<Map> p_o, TNode<Uint8T> p_v);
TNode<Uint16T> LoadMapInstanceType(TNode<Map> p_o);
void StoreMapInstanceType(TNode<Map> p_o, TNode<Uint16T> p_v);
TNode<Uint8T> LoadMapBitField(TNode<Map> p_o);
void StoreMapBitField(TNode<Map> p_o, TNode<Uint8T> p_v);
TNode<Uint8T> LoadMapBitField2(TNode<Map> p_o);
void StoreMapBitField2(TNode<Map> p_o, TNode<Uint8T> p_v);
TNode<Uint32T> LoadMapBitField3(TNode<Map> p_o);
void StoreMapBitField3(TNode<Map> p_o, TNode<Uint32T> p_v);
TNode<HeapObject> LoadMapPrototype(TNode<Map> p_o);
void StoreMapPrototype(TNode<Map> p_o, TNode<HeapObject> p_v);
TNode<Object> LoadMapConstructorOrBackPointerOrNativeContext(TNode<Map> p_o);
void StoreMapConstructorOrBackPointerOrNativeContext(TNode<Map> p_o, TNode<Object> p_v);
TNode<DescriptorArray> LoadMapInstanceDescriptors(TNode<Map> p_o);
void StoreMapInstanceDescriptors(TNode<Map> p_o, TNode<DescriptorArray> p_v);
TNode<WeakFixedArray> LoadMapDependentCode(TNode<Map> p_o);
void StoreMapDependentCode(TNode<Map> p_o, TNode<WeakFixedArray> p_v);
TNode<Object> LoadMapPrototypeValidityCell(TNode<Map> p_o);
void StoreMapPrototypeValidityCell(TNode<Map> p_o, TNode<Object> p_v);
TNode<MaybeObject> LoadMapTransitionsOrPrototypeInfo(TNode<Map> p_o);
void StoreMapTransitionsOrPrototypeInfo(TNode<Map> p_o, TNode<MaybeObject> p_v);
TNode<HeapObject> LoadWeakCellFinalizationRegistry(TNode<WeakCell> p_o);
void StoreWeakCellFinalizationRegistry(TNode<WeakCell> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadWeakCellTarget(TNode<WeakCell> p_o);
void StoreWeakCellTarget(TNode<WeakCell> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadWeakCellUnregisterToken(TNode<WeakCell> p_o);
void StoreWeakCellUnregisterToken(TNode<WeakCell> p_o, TNode<HeapObject> p_v);
TNode<Object> LoadWeakCellHoldings(TNode<WeakCell> p_o);
void StoreWeakCellHoldings(TNode<WeakCell> p_o, TNode<Object> p_v);
TNode<HeapObject> LoadWeakCellPrev(TNode<WeakCell> p_o);
void StoreWeakCellPrev(TNode<WeakCell> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadWeakCellNext(TNode<WeakCell> p_o);
void StoreWeakCellNext(TNode<WeakCell> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadWeakCellKeyListPrev(TNode<WeakCell> p_o);
void StoreWeakCellKeyListPrev(TNode<WeakCell> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadWeakCellKeyListNext(TNode<WeakCell> p_o);
void StoreWeakCellKeyListNext(TNode<WeakCell> p_o, TNode<HeapObject> p_v);
TNode<Object> LoadJSPromiseReactionsOrResult(TNode<JSPromise> p_o);
void StoreJSPromiseReactionsOrResult(TNode<JSPromise> p_o, TNode<Object> p_v);
TNode<Smi> LoadJSPromiseFlags(TNode<JSPromise> p_o);
void StoreJSPromiseFlags(TNode<JSPromise> p_o, TNode<Smi> p_v);
TNode<HeapObject> LoadPromiseCapabilityPromise(TNode<PromiseCapability> p_o);
void StorePromiseCapabilityPromise(TNode<PromiseCapability> p_o, TNode<HeapObject> p_v);
TNode<Object> LoadPromiseCapabilityResolve(TNode<PromiseCapability> p_o);
void StorePromiseCapabilityResolve(TNode<PromiseCapability> p_o, TNode<Object> p_v);
TNode<Object> LoadPromiseCapabilityReject(TNode<PromiseCapability> p_o);
void StorePromiseCapabilityReject(TNode<PromiseCapability> p_o, TNode<Object> p_v);
TNode<JSArrayBuffer> LoadJSArrayBufferViewBuffer(TNode<JSArrayBufferView> p_o);
void StoreJSArrayBufferViewBuffer(TNode<JSArrayBufferView> p_o, TNode<JSArrayBuffer> p_v);
TNode<UintPtrT> LoadJSArrayBufferViewByteOffset(TNode<JSArrayBufferView> p_o);
void StoreJSArrayBufferViewByteOffset(TNode<JSArrayBufferView> p_o, TNode<UintPtrT> p_v);
TNode<UintPtrT> LoadJSArrayBufferViewByteLength(TNode<JSArrayBufferView> p_o);
void StoreJSArrayBufferViewByteLength(TNode<JSArrayBufferView> p_o, TNode<UintPtrT> p_v);
TNode<UintPtrT> LoadJSTypedArrayLength(TNode<JSTypedArray> p_o);
void StoreJSTypedArrayLength(TNode<JSTypedArray> p_o, TNode<UintPtrT> p_v);
TNode<ExternalPointerT> LoadJSTypedArrayExternalPointer(TNode<JSTypedArray> p_o);
void StoreJSTypedArrayExternalPointer(TNode<JSTypedArray> p_o, TNode<ExternalPointerT> p_v);
TNode<Object> LoadJSTypedArrayBasePointer(TNode<JSTypedArray> p_o);
void StoreJSTypedArrayBasePointer(TNode<JSTypedArray> p_o, TNode<Object> p_v);
TNode<Uint32T> LoadJSTypedArrayBitField(TNode<JSTypedArray> p_o);
void StoreJSTypedArrayBitField(TNode<JSTypedArray> p_o, TNode<Uint32T> p_v);
TNode<Object> LoadDataHandlerSmiHandler(TNode<DataHandler> p_o);
void StoreDataHandlerSmiHandler(TNode<DataHandler> p_o, TNode<Object> p_v);
TNode<Object> LoadDataHandlerValidityCell(TNode<DataHandler> p_o);
void StoreDataHandlerValidityCell(TNode<DataHandler> p_o, TNode<Object> p_v);
TNode<MaybeObject> LoadDataHandlerData1(TNode<DataHandler> p_o);
void StoreDataHandlerData1(TNode<DataHandler> p_o, TNode<MaybeObject> p_v);
TNode<MaybeObject> LoadDataHandlerData2(TNode<DataHandler> p_o);
void StoreDataHandlerData2(TNode<DataHandler> p_o, TNode<MaybeObject> p_v);
TNode<MaybeObject> LoadDataHandlerData3(TNode<DataHandler> p_o);
void StoreDataHandlerData3(TNode<DataHandler> p_o, TNode<MaybeObject> p_v);
TNode<AllocationSite> LoadAllocationMementoAllocationSite(TNode<AllocationMemento> p_o);
void StoreAllocationMementoAllocationSite(TNode<AllocationMemento> p_o, TNode<AllocationSite> p_v);
TNode<Object> LoadCallHandlerInfoCallback(TNode<CallHandlerInfo> p_o);
void StoreCallHandlerInfoCallback(TNode<CallHandlerInfo> p_o, TNode<Object> p_v);
TNode<Object> LoadCallHandlerInfoJsCallback(TNode<CallHandlerInfo> p_o);
void StoreCallHandlerInfoJsCallback(TNode<CallHandlerInfo> p_o, TNode<Object> p_v);
TNode<Object> LoadCallHandlerInfoData(TNode<CallHandlerInfo> p_o);
void StoreCallHandlerInfoData(TNode<CallHandlerInfo> p_o, TNode<Object> p_v);
TNode<Object> LoadInterceptorInfoGetter(TNode<InterceptorInfo> p_o);
void StoreInterceptorInfoGetter(TNode<InterceptorInfo> p_o, TNode<Object> p_v);
TNode<Object> LoadInterceptorInfoSetter(TNode<InterceptorInfo> p_o);
void StoreInterceptorInfoSetter(TNode<InterceptorInfo> p_o, TNode<Object> p_v);
TNode<Object> LoadInterceptorInfoQuery(TNode<InterceptorInfo> p_o);
void StoreInterceptorInfoQuery(TNode<InterceptorInfo> p_o, TNode<Object> p_v);
TNode<Object> LoadInterceptorInfoDescriptor(TNode<InterceptorInfo> p_o);
void StoreInterceptorInfoDescriptor(TNode<InterceptorInfo> p_o, TNode<Object> p_v);
TNode<Object> LoadInterceptorInfoDeleter(TNode<InterceptorInfo> p_o);
void StoreInterceptorInfoDeleter(TNode<InterceptorInfo> p_o, TNode<Object> p_v);
TNode<Object> LoadInterceptorInfoEnumerator(TNode<InterceptorInfo> p_o);
void StoreInterceptorInfoEnumerator(TNode<InterceptorInfo> p_o, TNode<Object> p_v);
TNode<Object> LoadInterceptorInfoDefiner(TNode<InterceptorInfo> p_o);
void StoreInterceptorInfoDefiner(TNode<InterceptorInfo> p_o, TNode<Object> p_v);
TNode<Object> LoadInterceptorInfoData(TNode<InterceptorInfo> p_o);
void StoreInterceptorInfoData(TNode<InterceptorInfo> p_o, TNode<Object> p_v);
TNode<Smi> LoadInterceptorInfoFlags(TNode<InterceptorInfo> p_o);
void StoreInterceptorInfoFlags(TNode<InterceptorInfo> p_o, TNode<Smi> p_v);
TNode<Object> LoadAccessCheckInfoCallback(TNode<AccessCheckInfo> p_o);
void StoreAccessCheckInfoCallback(TNode<AccessCheckInfo> p_o, TNode<Object> p_v);
TNode<Object> LoadAccessCheckInfoNamedInterceptor(TNode<AccessCheckInfo> p_o);
void StoreAccessCheckInfoNamedInterceptor(TNode<AccessCheckInfo> p_o, TNode<Object> p_v);
TNode<Object> LoadAccessCheckInfoIndexedInterceptor(TNode<AccessCheckInfo> p_o);
void StoreAccessCheckInfoIndexedInterceptor(TNode<AccessCheckInfo> p_o, TNode<Object> p_v);
TNode<Object> LoadAccessCheckInfoData(TNode<AccessCheckInfo> p_o);
void StoreAccessCheckInfoData(TNode<AccessCheckInfo> p_o, TNode<Object> p_v);
TNode<Name> LoadAccessorInfoName(TNode<AccessorInfo> p_o);
void StoreAccessorInfoName(TNode<AccessorInfo> p_o, TNode<Name> p_v);
TNode<Smi> LoadAccessorInfoFlags(TNode<AccessorInfo> p_o);
void StoreAccessorInfoFlags(TNode<AccessorInfo> p_o, TNode<Smi> p_v);
TNode<Object> LoadAccessorInfoExpectedReceiverType(TNode<AccessorInfo> p_o);
void StoreAccessorInfoExpectedReceiverType(TNode<AccessorInfo> p_o, TNode<Object> p_v);
TNode<Object> LoadAccessorInfoSetter(TNode<AccessorInfo> p_o);
void StoreAccessorInfoSetter(TNode<AccessorInfo> p_o, TNode<Object> p_v);
TNode<Object> LoadAccessorInfoGetter(TNode<AccessorInfo> p_o);
void StoreAccessorInfoGetter(TNode<AccessorInfo> p_o, TNode<Object> p_v);
TNode<Object> LoadAccessorInfoJsGetter(TNode<AccessorInfo> p_o);
void StoreAccessorInfoJsGetter(TNode<AccessorInfo> p_o, TNode<Object> p_v);
TNode<Object> LoadAccessorInfoData(TNode<AccessorInfo> p_o);
void StoreAccessorInfoData(TNode<AccessorInfo> p_o, TNode<Object> p_v);
TNode<Object> LoadJSSloppyArgumentsObjectLength(TNode<JSArgumentsObject> p_o);
void StoreJSSloppyArgumentsObjectLength(TNode<JSArgumentsObject> p_o, TNode<Object> p_v);
TNode<Object> LoadJSSloppyArgumentsObjectCallee(TNode<JSArgumentsObject> p_o);
void StoreJSSloppyArgumentsObjectCallee(TNode<JSArgumentsObject> p_o, TNode<Object> p_v);
TNode<Object> LoadJSStrictArgumentsObjectLength(TNode<JSArgumentsObject> p_o);
void StoreJSStrictArgumentsObjectLength(TNode<JSArgumentsObject> p_o, TNode<Object> p_v);
TNode<Context> LoadSloppyArgumentsElementsContext(TNode<SloppyArgumentsElements> p_o);
void StoreSloppyArgumentsElementsContext(TNode<SloppyArgumentsElements> p_o, TNode<Context> p_v);
TNode<FixedArray> LoadSloppyArgumentsElementsArguments(TNode<SloppyArgumentsElements> p_o);
void StoreSloppyArgumentsElementsArguments(TNode<SloppyArgumentsElements> p_o, TNode<FixedArray> p_v);
TorqueStructSlice_Smi_OR_TheHole_MutableReference_Smi_OR_TheHole_0 FieldSliceSloppyArgumentsElementsMappedEntries(TNode<SloppyArgumentsElements> p_o);
TNode<Object> LoadSloppyArgumentsElementsMappedEntries(TNode<SloppyArgumentsElements> p_o, TNode<IntPtrT> p_i);
void StoreSloppyArgumentsElementsMappedEntries(TNode<SloppyArgumentsElements> p_o, TNode<IntPtrT> p_i, TNode<Object> p_v);
TNode<Smi> LoadAliasedArgumentsEntryAliasedContextSlot(TNode<AliasedArgumentsEntry> p_o);
void StoreAliasedArgumentsEntryAliasedContextSlot(TNode<AliasedArgumentsEntry> p_o, TNode<Smi> p_v);
TNode<Object> LoadCellValue(TNode<Cell> p_o);
void StoreCellValue(TNode<Cell> p_o, TNode<Object> p_v);
TNode<FixedArray> LoadBytecodeArrayConstantPool(TNode<BytecodeArray> p_o);
void StoreBytecodeArrayConstantPool(TNode<BytecodeArray> p_o, TNode<FixedArray> p_v);
TNode<ByteArray> LoadBytecodeArrayHandlerTable(TNode<BytecodeArray> p_o);
void StoreBytecodeArrayHandlerTable(TNode<BytecodeArray> p_o, TNode<ByteArray> p_v);
TNode<HeapObject> LoadBytecodeArraySourcePositionTable(TNode<BytecodeArray> p_o);
void StoreBytecodeArraySourcePositionTable(TNode<BytecodeArray> p_o, TNode<HeapObject> p_v);
TNode<Int32T> LoadBytecodeArrayFrameSize(TNode<BytecodeArray> p_o);
void StoreBytecodeArrayFrameSize(TNode<BytecodeArray> p_o, TNode<Int32T> p_v);
TNode<Int32T> LoadBytecodeArrayParameterSize(TNode<BytecodeArray> p_o);
void StoreBytecodeArrayParameterSize(TNode<BytecodeArray> p_o, TNode<Int32T> p_v);
TNode<Int32T> LoadBytecodeArrayIncomingNewTargetOrGeneratorRegister(TNode<BytecodeArray> p_o);
void StoreBytecodeArrayIncomingNewTargetOrGeneratorRegister(TNode<BytecodeArray> p_o, TNode<Int32T> p_v);
TNode<Int8T> LoadBytecodeArrayOsrNestingLevel(TNode<BytecodeArray> p_o);
void StoreBytecodeArrayOsrNestingLevel(TNode<BytecodeArray> p_o, TNode<Int8T> p_v);
TNode<Int8T> LoadBytecodeArrayBytecodeAge(TNode<BytecodeArray> p_o);
void StoreBytecodeArrayBytecodeAge(TNode<BytecodeArray> p_o, TNode<Int8T> p_v);
TNode<Smi> LoadScopeInfoFlags(TNode<ScopeInfo> p_o);
TNode<Smi> LoadScopeInfoParameterCount(TNode<ScopeInfo> p_o);
void StoreScopeInfoParameterCount(TNode<ScopeInfo> p_o, TNode<Smi> p_v);
TNode<Smi> LoadScopeInfoContextLocalCount(TNode<ScopeInfo> p_o);
TorqueStructSlice_String_MutableReference_String_0 FieldSliceScopeInfoContextLocalNames(TNode<ScopeInfo> p_o);
TNode<String> LoadScopeInfoContextLocalNames(TNode<ScopeInfo> p_o, TNode<IntPtrT> p_i);
void StoreScopeInfoContextLocalNames(TNode<ScopeInfo> p_o, TNode<IntPtrT> p_i, TNode<String> p_v);
TorqueStructSlice_SmiTagged_VariableProperties_MutableReference_SmiTagged_VariableProperties_0 FieldSliceScopeInfoContextLocalInfos(TNode<ScopeInfo> p_o);
TNode<Smi> LoadScopeInfoContextLocalInfos(TNode<ScopeInfo> p_o, TNode<IntPtrT> p_i);
void StoreScopeInfoContextLocalInfos(TNode<ScopeInfo> p_o, TNode<IntPtrT> p_i, TNode<Smi> p_v);
TorqueStructSlice_Smi_MutableReference_Smi_0 FieldSliceScopeInfoSavedClassVariableInfo(TNode<ScopeInfo> p_o);
TNode<Smi> LoadScopeInfoSavedClassVariableInfo(TNode<ScopeInfo> p_o);
void StoreScopeInfoSavedClassVariableInfo(TNode<ScopeInfo> p_o, TNode<Smi> p_v);
TorqueStructSlice_Smi_MutableReference_Smi_0 FieldSliceScopeInfoReceiverInfo(TNode<ScopeInfo> p_o);
TNode<Smi> LoadScopeInfoReceiverInfo(TNode<ScopeInfo> p_o);
void StoreScopeInfoReceiverInfo(TNode<ScopeInfo> p_o, TNode<Smi> p_v);
TorqueStructSlice_FunctionVariableInfo_MutableReference_FunctionVariableInfo_0 FieldSliceScopeInfoFunctionVariableInfo(TNode<ScopeInfo> p_o);
TorqueStructSlice_String_OR_Undefined_MutableReference_String_OR_Undefined_0 FieldSliceScopeInfoInferredFunctionName(TNode<ScopeInfo> p_o);
TNode<PrimitiveHeapObject> LoadScopeInfoInferredFunctionName(TNode<ScopeInfo> p_o);
void StoreScopeInfoInferredFunctionName(TNode<ScopeInfo> p_o, TNode<PrimitiveHeapObject> p_v);
TorqueStructSlice_PositionInfo_MutableReference_PositionInfo_0 FieldSliceScopeInfoPositionInfo(TNode<ScopeInfo> p_o);
TorqueStructSlice_TheHole_OR_ScopeInfo_MutableReference_TheHole_OR_ScopeInfo_0 FieldSliceScopeInfoOuterScopeInfo(TNode<ScopeInfo> p_o);
TNode<HeapObject> LoadScopeInfoOuterScopeInfo(TNode<ScopeInfo> p_o);
void StoreScopeInfoOuterScopeInfo(TNode<ScopeInfo> p_o, TNode<HeapObject> p_v);
TorqueStructSlice_HashTable_MutableReference_HashTable_0 FieldSliceScopeInfoLocalsBlockList(TNode<ScopeInfo> p_o);
TNode<FixedArray> LoadScopeInfoLocalsBlockList(TNode<ScopeInfo> p_o);
void StoreScopeInfoLocalsBlockList(TNode<ScopeInfo> p_o, TNode<FixedArray> p_v);
TorqueStructSlice_SourceTextModuleInfo_MutableReference_SourceTextModuleInfo_0 FieldSliceScopeInfoModuleInfo(TNode<ScopeInfo> p_o);
TNode<FixedArray> LoadScopeInfoModuleInfo(TNode<ScopeInfo> p_o);
void StoreScopeInfoModuleInfo(TNode<ScopeInfo> p_o, TNode<FixedArray> p_v);
TorqueStructSlice_Smi_ConstReference_Smi_0 FieldSliceScopeInfoModuleVariableCount(TNode<ScopeInfo> p_o);
TNode<Smi> LoadScopeInfoModuleVariableCount(TNode<ScopeInfo> p_o);
TorqueStructSlice_ModuleVariable_MutableReference_ModuleVariable_0 FieldSliceScopeInfoModuleVariables(TNode<ScopeInfo> p_o);
TorqueStructSlice_float64_or_hole_MutableReference_float64_or_hole_0 FieldSliceFixedDoubleArrayFloats(TNode<FixedDoubleArray> p_o);
TNode<Smi> LoadBreakPointId(TNode<BreakPoint> p_o);
void StoreBreakPointId(TNode<BreakPoint> p_o, TNode<Smi> p_v);
TNode<String> LoadBreakPointCondition(TNode<BreakPoint> p_o);
void StoreBreakPointCondition(TNode<BreakPoint> p_o, TNode<String> p_v);
TNode<Smi> LoadBreakPointInfoSourcePosition(TNode<BreakPointInfo> p_o);
void StoreBreakPointInfoSourcePosition(TNode<BreakPointInfo> p_o, TNode<Smi> p_v);
TNode<HeapObject> LoadBreakPointInfoBreakPoints(TNode<BreakPointInfo> p_o);
void StoreBreakPointInfoBreakPoints(TNode<BreakPointInfo> p_o, TNode<HeapObject> p_v);
TNode<SharedFunctionInfo> LoadDebugInfoShared(TNode<DebugInfo> p_o);
void StoreDebugInfoShared(TNode<DebugInfo> p_o, TNode<SharedFunctionInfo> p_v);
TNode<Smi> LoadDebugInfoDebuggerHints(TNode<DebugInfo> p_o);
void StoreDebugInfoDebuggerHints(TNode<DebugInfo> p_o, TNode<Smi> p_v);
TNode<HeapObject> LoadDebugInfoScript(TNode<DebugInfo> p_o);
void StoreDebugInfoScript(TNode<DebugInfo> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadDebugInfoOriginalBytecodeArray(TNode<DebugInfo> p_o);
void StoreDebugInfoOriginalBytecodeArray(TNode<DebugInfo> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadDebugInfoDebugBytecodeArray(TNode<DebugInfo> p_o);
void StoreDebugInfoDebugBytecodeArray(TNode<DebugInfo> p_o, TNode<HeapObject> p_v);
TNode<FixedArray> LoadDebugInfoBreakPoints(TNode<DebugInfo> p_o);
void StoreDebugInfoBreakPoints(TNode<DebugInfo> p_o, TNode<FixedArray> p_v);
TNode<Smi> LoadDebugInfoFlags(TNode<DebugInfo> p_o);
void StoreDebugInfoFlags(TNode<DebugInfo> p_o, TNode<Smi> p_v);
TNode<HeapObject> LoadDebugInfoCoverageInfo(TNode<DebugInfo> p_o);
void StoreDebugInfoCoverageInfo(TNode<DebugInfo> p_o, TNode<HeapObject> p_v);
TNode<Int32T> LoadCoverageInfoSlotCount(TNode<CoverageInfo> p_o);
TorqueStructSlice_CoverageInfoSlot_MutableReference_CoverageInfoSlot_0 FieldSliceCoverageInfoSlots(TNode<CoverageInfo> p_o);
TNode<FixedArray> LoadEnumCacheKeys(TNode<EnumCache> p_o);
void StoreEnumCacheKeys(TNode<EnumCache> p_o, TNode<FixedArray> p_v);
TNode<FixedArray> LoadEnumCacheIndices(TNode<EnumCache> p_o);
void StoreEnumCacheIndices(TNode<EnumCache> p_o, TNode<FixedArray> p_v);
TNode<Object> LoadAccessorPairGetter(TNode<AccessorPair> p_o);
void StoreAccessorPairGetter(TNode<AccessorPair> p_o, TNode<Object> p_v);
TNode<Object> LoadAccessorPairSetter(TNode<AccessorPair> p_o);
void StoreAccessorPairSetter(TNode<AccessorPair> p_o, TNode<Object> p_v);
TNode<Smi> LoadClassPositionsStart(TNode<ClassPositions> p_o);
void StoreClassPositionsStart(TNode<ClassPositions> p_o, TNode<Smi> p_v);
TNode<Smi> LoadClassPositionsEnd(TNode<ClassPositions> p_o);
void StoreClassPositionsEnd(TNode<ClassPositions> p_o, TNode<Smi> p_v);
TNode<Uint16T> LoadDescriptorArrayNumberOfAllDescriptors(TNode<DescriptorArray> p_o);
TNode<Uint16T> LoadDescriptorArrayNumberOfDescriptors(TNode<DescriptorArray> p_o);
void StoreDescriptorArrayNumberOfDescriptors(TNode<DescriptorArray> p_o, TNode<Uint16T> p_v);
TNode<Uint16T> LoadDescriptorArrayRawNumberOfMarkedDescriptors(TNode<DescriptorArray> p_o);
void StoreDescriptorArrayRawNumberOfMarkedDescriptors(TNode<DescriptorArray> p_o, TNode<Uint16T> p_v);
TNode<Uint16T> LoadDescriptorArrayFiller16Bits(TNode<DescriptorArray> p_o);
void StoreDescriptorArrayFiller16Bits(TNode<DescriptorArray> p_o, TNode<Uint16T> p_v);
TNode<EnumCache> LoadDescriptorArrayEnumCache(TNode<DescriptorArray> p_o);
void StoreDescriptorArrayEnumCache(TNode<DescriptorArray> p_o, TNode<EnumCache> p_v);
TorqueStructSlice_DescriptorEntry_MutableReference_DescriptorEntry_0 FieldSliceDescriptorArrayDescriptors(TNode<DescriptorArray> p_o);
TNode<Smi> LoadEmbedderDataArrayLength(TNode<EmbedderDataArray> p_o);
void StoreEmbedderDataArrayLength(TNode<EmbedderDataArray> p_o, TNode<Smi> p_v);
TNode<HeapObject> LoadFeedbackCellValue(TNode<FeedbackCell> p_o);
void StoreFeedbackCellValue(TNode<FeedbackCell> p_o, TNode<HeapObject> p_v);
TNode<Int32T> LoadFeedbackCellInterruptBudget(TNode<FeedbackCell> p_o);
void StoreFeedbackCellInterruptBudget(TNode<FeedbackCell> p_o, TNode<Int32T> p_v);
TNode<Int32T> LoadFeedbackVectorLength(TNode<FeedbackVector> p_o);
TNode<Int32T> LoadFeedbackVectorInvocationCount(TNode<FeedbackVector> p_o);
void StoreFeedbackVectorInvocationCount(TNode<FeedbackVector> p_o, TNode<Int32T> p_v);
TNode<Int32T> LoadFeedbackVectorProfilerTicks(TNode<FeedbackVector> p_o);
void StoreFeedbackVectorProfilerTicks(TNode<FeedbackVector> p_o, TNode<Int32T> p_v);
TNode<Uint32T> LoadFeedbackVectorFlags(TNode<FeedbackVector> p_o);
void StoreFeedbackVectorFlags(TNode<FeedbackVector> p_o, TNode<Uint32T> p_v);
TNode<SharedFunctionInfo> LoadFeedbackVectorSharedFunctionInfo(TNode<FeedbackVector> p_o);
void StoreFeedbackVectorSharedFunctionInfo(TNode<FeedbackVector> p_o, TNode<SharedFunctionInfo> p_v);
TNode<MaybeObject> LoadFeedbackVectorMaybeOptimizedCode(TNode<FeedbackVector> p_o);
void StoreFeedbackVectorMaybeOptimizedCode(TNode<FeedbackVector> p_o, TNode<MaybeObject> p_v);
TNode<ClosureFeedbackCellArray> LoadFeedbackVectorClosureFeedbackCellArray(TNode<FeedbackVector> p_o);
void StoreFeedbackVectorClosureFeedbackCellArray(TNode<FeedbackVector> p_o, TNode<ClosureFeedbackCellArray> p_v);
TorqueStructSlice_MaybeObject_MutableReference_MaybeObject_0 FieldSliceFeedbackVectorRawFeedbackSlots(TNode<FeedbackVector> p_o);
TNode<MaybeObject> LoadFeedbackVectorRawFeedbackSlots(TNode<FeedbackVector> p_o, TNode<IntPtrT> p_i);
void StoreFeedbackVectorRawFeedbackSlots(TNode<FeedbackVector> p_o, TNode<IntPtrT> p_i, TNode<MaybeObject> p_v);
TNode<Smi> LoadWeakArrayListCapacity(TNode<WeakArrayList> p_o);
TNode<Smi> LoadWeakArrayListLength(TNode<WeakArrayList> p_o);
void StoreWeakArrayListLength(TNode<WeakArrayList> p_o, TNode<Smi> p_v);
TorqueStructSlice_MaybeObject_MutableReference_MaybeObject_0 FieldSliceWeakArrayListObjects(TNode<WeakArrayList> p_o);
TNode<MaybeObject> LoadWeakArrayListObjects(TNode<WeakArrayList> p_o, TNode<IntPtrT> p_i);
void StoreWeakArrayListObjects(TNode<WeakArrayList> p_o, TNode<IntPtrT> p_i, TNode<MaybeObject> p_v);
TNode<Smi> LoadFreeSpaceSize(TNode<FreeSpace> p_o);
void StoreFreeSpaceSize(TNode<FreeSpace> p_o, TNode<Smi> p_v);
TNode<MaybeObject> LoadFreeSpaceNext(TNode<FreeSpace> p_o);
void StoreFreeSpaceNext(TNode<FreeSpace> p_o, TNode<MaybeObject> p_v);
TNode<UintPtrT> LoadJSArrayBufferByteLength(TNode<JSArrayBuffer> p_o);
void StoreJSArrayBufferByteLength(TNode<JSArrayBuffer> p_o, TNode<UintPtrT> p_v);
TNode<UintPtrT> LoadJSArrayBufferMaxByteLength(TNode<JSArrayBuffer> p_o);
void StoreJSArrayBufferMaxByteLength(TNode<JSArrayBuffer> p_o, TNode<UintPtrT> p_v);
TNode<ExternalPointerT> LoadJSArrayBufferBackingStore(TNode<JSArrayBuffer> p_o);
void StoreJSArrayBufferBackingStore(TNode<JSArrayBuffer> p_o, TNode<ExternalPointerT> p_v);
TNode<RawPtrT> LoadJSArrayBufferExtension(TNode<JSArrayBuffer> p_o);
void StoreJSArrayBufferExtension(TNode<JSArrayBuffer> p_o, TNode<RawPtrT> p_v);
TNode<Uint32T> LoadJSArrayBufferBitField(TNode<JSArrayBuffer> p_o);
void StoreJSArrayBufferBitField(TNode<JSArrayBuffer> p_o, TNode<Uint32T> p_v);
TNode<ExternalPointerT> LoadJSDataViewDataPointer(TNode<JSDataView> p_o);
void StoreJSDataViewDataPointer(TNode<JSDataView> p_o, TNode<ExternalPointerT> p_v);
TNode<JSReceiver> LoadJSArrayIteratorIteratedObject(TNode<JSArrayIterator> p_o);
void StoreJSArrayIteratorIteratedObject(TNode<JSArrayIterator> p_o, TNode<JSReceiver> p_v);
TNode<Number> LoadJSArrayIteratorNextIndex(TNode<JSArrayIterator> p_o);
void StoreJSArrayIteratorNextIndex(TNode<JSArrayIterator> p_o, TNode<Number> p_v);
TNode<Smi> LoadJSArrayIteratorKind(TNode<JSArrayIterator> p_o);
void StoreJSArrayIteratorKind(TNode<JSArrayIterator> p_o, TNode<Smi> p_v);
TNode<Number> LoadJSArrayLength(TNode<JSArray> p_o);
void StoreJSArrayLength(TNode<JSArray> p_o, TNode<Number> p_v);
TNode<Object> LoadJSCollectionIteratorTable(TNode<JSCollectionIterator> p_o);
void StoreJSCollectionIteratorTable(TNode<JSCollectionIterator> p_o, TNode<Object> p_v);
TNode<Object> LoadJSCollectionIteratorIndex(TNode<JSCollectionIterator> p_o);
void StoreJSCollectionIteratorIndex(TNode<JSCollectionIterator> p_o, TNode<Object> p_v);
TNode<Object> LoadJSCollectionTable(TNode<JSCollection> p_o);
void StoreJSCollectionTable(TNode<JSCollection> p_o, TNode<Object> p_v);
TNode<Object> LoadJSWeakCollectionTable(TNode<JSWeakCollection> p_o);
void StoreJSWeakCollectionTable(TNode<JSWeakCollection> p_o, TNode<Object> p_v);
TNode<JSFunction> LoadJSGeneratorObjectFunction(TNode<JSGeneratorObject> p_o);
void StoreJSGeneratorObjectFunction(TNode<JSGeneratorObject> p_o, TNode<JSFunction> p_v);
TNode<Context> LoadJSGeneratorObjectContext(TNode<JSGeneratorObject> p_o);
void StoreJSGeneratorObjectContext(TNode<JSGeneratorObject> p_o, TNode<Context> p_v);
TNode<Object> LoadJSGeneratorObjectReceiver(TNode<JSGeneratorObject> p_o);
void StoreJSGeneratorObjectReceiver(TNode<JSGeneratorObject> p_o, TNode<Object> p_v);
TNode<Object> LoadJSGeneratorObjectInputOrDebugPos(TNode<JSGeneratorObject> p_o);
void StoreJSGeneratorObjectInputOrDebugPos(TNode<JSGeneratorObject> p_o, TNode<Object> p_v);
TNode<Smi> LoadJSGeneratorObjectResumeMode(TNode<JSGeneratorObject> p_o);
void StoreJSGeneratorObjectResumeMode(TNode<JSGeneratorObject> p_o, TNode<Smi> p_v);
TNode<Smi> LoadJSGeneratorObjectContinuation(TNode<JSGeneratorObject> p_o);
void StoreJSGeneratorObjectContinuation(TNode<JSGeneratorObject> p_o, TNode<Smi> p_v);
TNode<FixedArray> LoadJSGeneratorObjectParametersAndRegisters(TNode<JSGeneratorObject> p_o);
void StoreJSGeneratorObjectParametersAndRegisters(TNode<JSGeneratorObject> p_o, TNode<FixedArray> p_v);
TNode<JSPromise> LoadJSAsyncFunctionObjectPromise(TNode<JSAsyncFunctionObject> p_o);
void StoreJSAsyncFunctionObjectPromise(TNode<JSAsyncFunctionObject> p_o, TNode<JSPromise> p_v);
TNode<HeapObject> LoadJSAsyncGeneratorObjectQueue(TNode<JSAsyncGeneratorObject> p_o);
void StoreJSAsyncGeneratorObjectQueue(TNode<JSAsyncGeneratorObject> p_o, TNode<HeapObject> p_v);
TNode<Smi> LoadJSAsyncGeneratorObjectIsAwaiting(TNode<JSAsyncGeneratorObject> p_o);
void StoreJSAsyncGeneratorObjectIsAwaiting(TNode<JSAsyncGeneratorObject> p_o, TNode<Smi> p_v);
TNode<HeapObject> LoadAsyncGeneratorRequestNext(TNode<AsyncGeneratorRequest> p_o);
void StoreAsyncGeneratorRequestNext(TNode<AsyncGeneratorRequest> p_o, TNode<HeapObject> p_v);
TNode<Smi> LoadAsyncGeneratorRequestResumeMode(TNode<AsyncGeneratorRequest> p_o);
void StoreAsyncGeneratorRequestResumeMode(TNode<AsyncGeneratorRequest> p_o, TNode<Smi> p_v);
TNode<Object> LoadAsyncGeneratorRequestValue(TNode<AsyncGeneratorRequest> p_o);
void StoreAsyncGeneratorRequestValue(TNode<AsyncGeneratorRequest> p_o, TNode<Object> p_v);
TNode<JSPromise> LoadAsyncGeneratorRequestPromise(TNode<AsyncGeneratorRequest> p_o);
void StoreAsyncGeneratorRequestPromise(TNode<AsyncGeneratorRequest> p_o, TNode<JSPromise> p_v);
TNode<Object> LoadJSGlobalProxyNativeContext(TNode<JSGlobalProxy> p_o);
void StoreJSGlobalProxyNativeContext(TNode<JSGlobalProxy> p_o, TNode<Object> p_v);
TNode<NativeContext> LoadJSGlobalObjectNativeContext(TNode<JSGlobalObject> p_o);
void StoreJSGlobalObjectNativeContext(TNode<JSGlobalObject> p_o, TNode<NativeContext> p_v);
TNode<JSGlobalProxy> LoadJSGlobalObjectGlobalProxy(TNode<JSGlobalObject> p_o);
void StoreJSGlobalObjectGlobalProxy(TNode<JSGlobalObject> p_o, TNode<JSGlobalProxy> p_v);
TNode<Object> LoadJSPrimitiveWrapperValue(TNode<JSPrimitiveWrapper> p_o);
void StoreJSPrimitiveWrapperValue(TNode<JSPrimitiveWrapper> p_o, TNode<Object> p_v);
TNode<Smi> LoadJSMessageObjectMessageType(TNode<JSMessageObject> p_o);
void StoreJSMessageObjectMessageType(TNode<JSMessageObject> p_o, TNode<Smi> p_v);
TNode<Object> LoadJSMessageObjectArguments(TNode<JSMessageObject> p_o);
void StoreJSMessageObjectArguments(TNode<JSMessageObject> p_o, TNode<Object> p_v);
TNode<Script> LoadJSMessageObjectScript(TNode<JSMessageObject> p_o);
void StoreJSMessageObjectScript(TNode<JSMessageObject> p_o, TNode<Script> p_v);
TNode<Object> LoadJSMessageObjectStackFrames(TNode<JSMessageObject> p_o);
void StoreJSMessageObjectStackFrames(TNode<JSMessageObject> p_o, TNode<Object> p_v);
TNode<HeapObject> LoadJSMessageObjectSharedInfo(TNode<JSMessageObject> p_o);
void StoreJSMessageObjectSharedInfo(TNode<JSMessageObject> p_o, TNode<HeapObject> p_v);
TNode<Smi> LoadJSMessageObjectBytecodeOffset(TNode<JSMessageObject> p_o);
void StoreJSMessageObjectBytecodeOffset(TNode<JSMessageObject> p_o, TNode<Smi> p_v);
TNode<Smi> LoadJSMessageObjectStartPosition(TNode<JSMessageObject> p_o);
void StoreJSMessageObjectStartPosition(TNode<JSMessageObject> p_o, TNode<Smi> p_v);
TNode<Smi> LoadJSMessageObjectEndPosition(TNode<JSMessageObject> p_o);
void StoreJSMessageObjectEndPosition(TNode<JSMessageObject> p_o, TNode<Smi> p_v);
TNode<Smi> LoadJSMessageObjectErrorLevel(TNode<JSMessageObject> p_o);
void StoreJSMessageObjectErrorLevel(TNode<JSMessageObject> p_o, TNode<Smi> p_v);
TNode<Object> LoadJSDateValue(TNode<JSDate> p_o);
void StoreJSDateValue(TNode<JSDate> p_o, TNode<Object> p_v);
TNode<Object> LoadJSDateYear(TNode<JSDate> p_o);
void StoreJSDateYear(TNode<JSDate> p_o, TNode<Object> p_v);
TNode<Object> LoadJSDateMonth(TNode<JSDate> p_o);
void StoreJSDateMonth(TNode<JSDate> p_o, TNode<Object> p_v);
TNode<Object> LoadJSDateDay(TNode<JSDate> p_o);
void StoreJSDateDay(TNode<JSDate> p_o, TNode<Object> p_v);
TNode<Object> LoadJSDateWeekday(TNode<JSDate> p_o);
void StoreJSDateWeekday(TNode<JSDate> p_o, TNode<Object> p_v);
TNode<Object> LoadJSDateHour(TNode<JSDate> p_o);
void StoreJSDateHour(TNode<JSDate> p_o, TNode<Object> p_v);
TNode<Object> LoadJSDateMin(TNode<JSDate> p_o);
void StoreJSDateMin(TNode<JSDate> p_o, TNode<Object> p_v);
TNode<Object> LoadJSDateSec(TNode<JSDate> p_o);
void StoreJSDateSec(TNode<JSDate> p_o, TNode<Object> p_v);
TNode<Object> LoadJSDateCacheStamp(TNode<JSDate> p_o);
void StoreJSDateCacheStamp(TNode<JSDate> p_o, TNode<Object> p_v);
TNode<JSReceiver> LoadJSAsyncFromSyncIteratorSyncIterator(TNode<JSAsyncFromSyncIterator> p_o);
void StoreJSAsyncFromSyncIteratorSyncIterator(TNode<JSAsyncFromSyncIterator> p_o, TNode<JSReceiver> p_v);
TNode<Object> LoadJSAsyncFromSyncIteratorNext(TNode<JSAsyncFromSyncIterator> p_o);
void StoreJSAsyncFromSyncIteratorNext(TNode<JSAsyncFromSyncIterator> p_o, TNode<Object> p_v);
TNode<String> LoadJSStringIteratorString(TNode<JSStringIterator> p_o);
void StoreJSStringIteratorString(TNode<JSStringIterator> p_o, TNode<String> p_v);
TNode<Smi> LoadJSStringIteratorIndex(TNode<JSStringIterator> p_o);
void StoreJSStringIteratorIndex(TNode<JSStringIterator> p_o, TNode<Smi> p_v);
TNode<Object> LoadJSProxyRevocableResultProxy(TNode<JSObject> p_o);
void StoreJSProxyRevocableResultProxy(TNode<JSObject> p_o, TNode<Object> p_v);
TNode<Object> LoadJSProxyRevocableResultRevoke(TNode<JSObject> p_o);
void StoreJSProxyRevocableResultRevoke(TNode<JSObject> p_o, TNode<Object> p_v);
TNode<JSReceiver> LoadJSRegExpStringIteratorIteratingRegExp(TNode<JSRegExpStringIterator> p_o);
void StoreJSRegExpStringIteratorIteratingRegExp(TNode<JSRegExpStringIterator> p_o, TNode<JSReceiver> p_v);
TNode<String> LoadJSRegExpStringIteratorIteratedString(TNode<JSRegExpStringIterator> p_o);
void StoreJSRegExpStringIteratorIteratedString(TNode<JSRegExpStringIterator> p_o, TNode<String> p_v);
TNode<Smi> LoadJSRegExpStringIteratorFlags(TNode<JSRegExpStringIterator> p_o);
void StoreJSRegExpStringIteratorFlags(TNode<JSRegExpStringIterator> p_o, TNode<Smi> p_v);
TNode<HeapObject> LoadJSRegExpData(TNode<JSRegExp> p_o);
void StoreJSRegExpData(TNode<JSRegExp> p_o, TNode<HeapObject> p_v);
TNode<PrimitiveHeapObject> LoadJSRegExpSource(TNode<JSRegExp> p_o);
void StoreJSRegExpSource(TNode<JSRegExp> p_o, TNode<PrimitiveHeapObject> p_v);
TNode<Object> LoadJSRegExpFlags(TNode<JSRegExp> p_o);
void StoreJSRegExpFlags(TNode<JSRegExp> p_o, TNode<Object> p_v);
TNode<Object> LoadJSRegExpResultIndex(TNode<JSArray> p_o);
void StoreJSRegExpResultIndex(TNode<JSArray> p_o, TNode<Object> p_v);
TNode<Object> LoadJSRegExpResultInput(TNode<JSArray> p_o);
void StoreJSRegExpResultInput(TNode<JSArray> p_o, TNode<Object> p_v);
TNode<Object> LoadJSRegExpResultGroups(TNode<JSArray> p_o);
void StoreJSRegExpResultGroups(TNode<JSArray> p_o, TNode<Object> p_v);
TNode<HeapObject> LoadJSRegExpResultNames(TNode<JSArray> p_o);
void StoreJSRegExpResultNames(TNode<JSArray> p_o, TNode<HeapObject> p_v);
TNode<String> LoadJSRegExpResultRegexpInput(TNode<JSArray> p_o);
void StoreJSRegExpResultRegexpInput(TNode<JSArray> p_o, TNode<String> p_v);
TNode<Smi> LoadJSRegExpResultRegexpLastIndex(TNode<JSArray> p_o);
void StoreJSRegExpResultRegexpLastIndex(TNode<JSArray> p_o, TNode<Smi> p_v);
TNode<Object> LoadJSRegExpResultWithIndicesIndices(TNode<JSRegExpResult> p_o);
void StoreJSRegExpResultWithIndicesIndices(TNode<JSRegExpResult> p_o, TNode<Object> p_v);
TNode<Object> LoadJSRegExpResultIndicesGroups(TNode<JSArray> p_o);
void StoreJSRegExpResultIndicesGroups(TNode<JSArray> p_o, TNode<Object> p_v);
TNode<NativeContext> LoadJSFinalizationRegistryNativeContext(TNode<JSFinalizationRegistry> p_o);
void StoreJSFinalizationRegistryNativeContext(TNode<JSFinalizationRegistry> p_o, TNode<NativeContext> p_v);
TNode<JSReceiver> LoadJSFinalizationRegistryCleanup(TNode<JSFinalizationRegistry> p_o);
void StoreJSFinalizationRegistryCleanup(TNode<JSFinalizationRegistry> p_o, TNode<JSReceiver> p_v);
TNode<HeapObject> LoadJSFinalizationRegistryActiveCells(TNode<JSFinalizationRegistry> p_o);
void StoreJSFinalizationRegistryActiveCells(TNode<JSFinalizationRegistry> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadJSFinalizationRegistryClearedCells(TNode<JSFinalizationRegistry> p_o);
void StoreJSFinalizationRegistryClearedCells(TNode<JSFinalizationRegistry> p_o, TNode<HeapObject> p_v);
TNode<Object> LoadJSFinalizationRegistryKeyMap(TNode<JSFinalizationRegistry> p_o);
void StoreJSFinalizationRegistryKeyMap(TNode<JSFinalizationRegistry> p_o, TNode<Object> p_v);
TNode<HeapObject> LoadJSFinalizationRegistryNextDirty(TNode<JSFinalizationRegistry> p_o);
void StoreJSFinalizationRegistryNextDirty(TNode<JSFinalizationRegistry> p_o, TNode<HeapObject> p_v);
TNode<Smi> LoadJSFinalizationRegistryFlags(TNode<JSFinalizationRegistry> p_o);
void StoreJSFinalizationRegistryFlags(TNode<JSFinalizationRegistry> p_o, TNode<Smi> p_v);
TNode<HeapObject> LoadJSWeakRefTarget(TNode<JSWeakRef> p_o);
void StoreJSWeakRefTarget(TNode<JSWeakRef> p_o, TNode<HeapObject> p_v);
TNode<Smi> LoadArrayBoilerplateDescriptionFlags(TNode<ArrayBoilerplateDescription> p_o);
void StoreArrayBoilerplateDescriptionFlags(TNode<ArrayBoilerplateDescription> p_o, TNode<Smi> p_v);
TNode<FixedArrayBase> LoadArrayBoilerplateDescriptionConstantElements(TNode<ArrayBoilerplateDescription> p_o);
void StoreArrayBoilerplateDescriptionConstantElements(TNode<ArrayBoilerplateDescription> p_o, TNode<FixedArrayBase> p_v);
TNode<FixedArray> LoadRegExpBoilerplateDescriptionData(TNode<RegExpBoilerplateDescription> p_o);
void StoreRegExpBoilerplateDescriptionData(TNode<RegExpBoilerplateDescription> p_o, TNode<FixedArray> p_v);
TNode<String> LoadRegExpBoilerplateDescriptionSource(TNode<RegExpBoilerplateDescription> p_o);
void StoreRegExpBoilerplateDescriptionSource(TNode<RegExpBoilerplateDescription> p_o, TNode<String> p_v);
TNode<Smi> LoadRegExpBoilerplateDescriptionFlags(TNode<RegExpBoilerplateDescription> p_o);
void StoreRegExpBoilerplateDescriptionFlags(TNode<RegExpBoilerplateDescription> p_o, TNode<Smi> p_v);
TNode<MaybeObject> LoadMegaDomHandlerAccessor(TNode<MegaDomHandler> p_o);
void StoreMegaDomHandlerAccessor(TNode<MegaDomHandler> p_o, TNode<MaybeObject> p_v);
TNode<MaybeObject> LoadMegaDomHandlerContext(TNode<MegaDomHandler> p_o);
void StoreMegaDomHandlerContext(TNode<MegaDomHandler> p_o, TNode<MaybeObject> p_v);
TNode<Foreign> LoadCallbackTaskCallback(TNode<CallbackTask> p_o);
void StoreCallbackTaskCallback(TNode<CallbackTask> p_o, TNode<Foreign> p_v);
TNode<Foreign> LoadCallbackTaskData(TNode<CallbackTask> p_o);
void StoreCallbackTaskData(TNode<CallbackTask> p_o, TNode<Foreign> p_v);
TNode<JSReceiver> LoadCallableTaskCallable(TNode<CallableTask> p_o);
void StoreCallableTaskCallable(TNode<CallableTask> p_o, TNode<JSReceiver> p_v);
TNode<Context> LoadCallableTaskContext(TNode<CallableTask> p_o);
void StoreCallableTaskContext(TNode<CallableTask> p_o, TNode<Context> p_v);
TNode<ObjectHashTable> LoadModuleExports(TNode<Module> p_o);
void StoreModuleExports(TNode<Module> p_o, TNode<ObjectHashTable> p_v);
TNode<Smi> LoadModuleHash(TNode<Module> p_o);
void StoreModuleHash(TNode<Module> p_o, TNode<Smi> p_v);
TNode<Smi> LoadModuleStatus(TNode<Module> p_o);
void StoreModuleStatus(TNode<Module> p_o, TNode<Smi> p_v);
TNode<HeapObject> LoadModuleModuleNamespace(TNode<Module> p_o);
void StoreModuleModuleNamespace(TNode<Module> p_o, TNode<HeapObject> p_v);
TNode<Object> LoadModuleException(TNode<Module> p_o);
void StoreModuleException(TNode<Module> p_o, TNode<Object> p_v);
TNode<HeapObject> LoadModuleTopLevelCapability(TNode<Module> p_o);
void StoreModuleTopLevelCapability(TNode<Module> p_o, TNode<HeapObject> p_v);
TNode<Module> LoadJSModuleNamespaceModule(TNode<JSModuleNamespace> p_o);
void StoreJSModuleNamespaceModule(TNode<JSModuleNamespace> p_o, TNode<Module> p_v);
TNode<Uint8T> LoadSmallOrderedHashSetNumberOfElements(TNode<SmallOrderedHashSet> p_o);
void StoreSmallOrderedHashSetNumberOfElements(TNode<SmallOrderedHashSet> p_o, TNode<Uint8T> p_v);
TNode<Uint8T> LoadSmallOrderedHashSetNumberOfDeletedElements(TNode<SmallOrderedHashSet> p_o);
void StoreSmallOrderedHashSetNumberOfDeletedElements(TNode<SmallOrderedHashSet> p_o, TNode<Uint8T> p_v);
TNode<Uint8T> LoadSmallOrderedHashSetNumberOfBuckets(TNode<SmallOrderedHashSet> p_o);
TorqueStructSlice_uint8_MutableReference_uint8_0 FieldSliceSmallOrderedHashSetPadding(TNode<SmallOrderedHashSet> p_o);
TNode<Uint8T> LoadSmallOrderedHashSetPadding(TNode<SmallOrderedHashSet> p_o, TNode<IntPtrT> p_i);
void StoreSmallOrderedHashSetPadding(TNode<SmallOrderedHashSet> p_o, TNode<IntPtrT> p_i, TNode<Uint8T> p_v);
TorqueStructSlice_JSReceiver_OR_Smi_OR_HeapNumber_OR_BigInt_OR_String_OR_Symbol_OR_True_OR_False_OR_Null_OR_Undefined_OR_TheHole_MutableReference_JSReceiver_OR_Smi_OR_HeapNumber_OR_BigInt_OR_String_OR_Symbol_OR_True_OR_False_OR_Null_OR_Undefined_OR_TheHole_0 FieldSliceSmallOrderedHashSetDataTable(TNode<SmallOrderedHashSet> p_o);
TNode<Object> LoadSmallOrderedHashSetDataTable(TNode<SmallOrderedHashSet> p_o, TNode<IntPtrT> p_i);
void StoreSmallOrderedHashSetDataTable(TNode<SmallOrderedHashSet> p_o, TNode<IntPtrT> p_i, TNode<Object> p_v);
TorqueStructSlice_uint8_MutableReference_uint8_0 FieldSliceSmallOrderedHashSetHashTable(TNode<SmallOrderedHashSet> p_o);
TNode<Uint8T> LoadSmallOrderedHashSetHashTable(TNode<SmallOrderedHashSet> p_o, TNode<IntPtrT> p_i);
void StoreSmallOrderedHashSetHashTable(TNode<SmallOrderedHashSet> p_o, TNode<IntPtrT> p_i, TNode<Uint8T> p_v);
TorqueStructSlice_uint8_MutableReference_uint8_0 FieldSliceSmallOrderedHashSetChainTable(TNode<SmallOrderedHashSet> p_o);
TNode<Uint8T> LoadSmallOrderedHashSetChainTable(TNode<SmallOrderedHashSet> p_o, TNode<IntPtrT> p_i);
void StoreSmallOrderedHashSetChainTable(TNode<SmallOrderedHashSet> p_o, TNode<IntPtrT> p_i, TNode<Uint8T> p_v);
TNode<Uint8T> LoadSmallOrderedHashMapNumberOfElements(TNode<SmallOrderedHashMap> p_o);
void StoreSmallOrderedHashMapNumberOfElements(TNode<SmallOrderedHashMap> p_o, TNode<Uint8T> p_v);
TNode<Uint8T> LoadSmallOrderedHashMapNumberOfDeletedElements(TNode<SmallOrderedHashMap> p_o);
void StoreSmallOrderedHashMapNumberOfDeletedElements(TNode<SmallOrderedHashMap> p_o, TNode<Uint8T> p_v);
TNode<Uint8T> LoadSmallOrderedHashMapNumberOfBuckets(TNode<SmallOrderedHashMap> p_o);
TorqueStructSlice_uint8_MutableReference_uint8_0 FieldSliceSmallOrderedHashMapPadding(TNode<SmallOrderedHashMap> p_o);
TNode<Uint8T> LoadSmallOrderedHashMapPadding(TNode<SmallOrderedHashMap> p_o, TNode<IntPtrT> p_i);
void StoreSmallOrderedHashMapPadding(TNode<SmallOrderedHashMap> p_o, TNode<IntPtrT> p_i, TNode<Uint8T> p_v);
TorqueStructSlice_HashMapEntry_MutableReference_HashMapEntry_0 FieldSliceSmallOrderedHashMapDataTable(TNode<SmallOrderedHashMap> p_o);
TorqueStructSlice_uint8_MutableReference_uint8_0 FieldSliceSmallOrderedHashMapHashTable(TNode<SmallOrderedHashMap> p_o);
TNode<Uint8T> LoadSmallOrderedHashMapHashTable(TNode<SmallOrderedHashMap> p_o, TNode<IntPtrT> p_i);
void StoreSmallOrderedHashMapHashTable(TNode<SmallOrderedHashMap> p_o, TNode<IntPtrT> p_i, TNode<Uint8T> p_v);
TorqueStructSlice_uint8_MutableReference_uint8_0 FieldSliceSmallOrderedHashMapChainTable(TNode<SmallOrderedHashMap> p_o);
TNode<Uint8T> LoadSmallOrderedHashMapChainTable(TNode<SmallOrderedHashMap> p_o, TNode<IntPtrT> p_i);
void StoreSmallOrderedHashMapChainTable(TNode<SmallOrderedHashMap> p_o, TNode<IntPtrT> p_i, TNode<Uint8T> p_v);
TNode<Int32T> LoadSmallOrderedNameDictionaryHash(TNode<SmallOrderedNameDictionary> p_o);
void StoreSmallOrderedNameDictionaryHash(TNode<SmallOrderedNameDictionary> p_o, TNode<Int32T> p_v);
TNode<Uint8T> LoadSmallOrderedNameDictionaryNumberOfElements(TNode<SmallOrderedNameDictionary> p_o);
void StoreSmallOrderedNameDictionaryNumberOfElements(TNode<SmallOrderedNameDictionary> p_o, TNode<Uint8T> p_v);
TNode<Uint8T> LoadSmallOrderedNameDictionaryNumberOfDeletedElements(TNode<SmallOrderedNameDictionary> p_o);
void StoreSmallOrderedNameDictionaryNumberOfDeletedElements(TNode<SmallOrderedNameDictionary> p_o, TNode<Uint8T> p_v);
TNode<Uint8T> LoadSmallOrderedNameDictionaryNumberOfBuckets(TNode<SmallOrderedNameDictionary> p_o);
TorqueStructSlice_uint8_MutableReference_uint8_0 FieldSliceSmallOrderedNameDictionaryPadding1(TNode<SmallOrderedNameDictionary> p_o);
TNode<Uint8T> LoadSmallOrderedNameDictionaryPadding1(TNode<SmallOrderedNameDictionary> p_o, TNode<IntPtrT> p_i);
void StoreSmallOrderedNameDictionaryPadding1(TNode<SmallOrderedNameDictionary> p_o, TNode<IntPtrT> p_i, TNode<Uint8T> p_v);
TorqueStructSlice_NameDictionaryEntry_MutableReference_NameDictionaryEntry_0 FieldSliceSmallOrderedNameDictionaryDataTable(TNode<SmallOrderedNameDictionary> p_o);
TorqueStructSlice_uint8_MutableReference_uint8_0 FieldSliceSmallOrderedNameDictionaryHashTable(TNode<SmallOrderedNameDictionary> p_o);
TNode<Uint8T> LoadSmallOrderedNameDictionaryHashTable(TNode<SmallOrderedNameDictionary> p_o, TNode<IntPtrT> p_i);
void StoreSmallOrderedNameDictionaryHashTable(TNode<SmallOrderedNameDictionary> p_o, TNode<IntPtrT> p_i, TNode<Uint8T> p_v);
TorqueStructSlice_uint8_MutableReference_uint8_0 FieldSliceSmallOrderedNameDictionaryChainTable(TNode<SmallOrderedNameDictionary> p_o);
TNode<Uint8T> LoadSmallOrderedNameDictionaryChainTable(TNode<SmallOrderedNameDictionary> p_o, TNode<IntPtrT> p_i);
void StoreSmallOrderedNameDictionaryChainTable(TNode<SmallOrderedNameDictionary> p_o, TNode<IntPtrT> p_i, TNode<Uint8T> p_v);
TNode<Object> LoadPromiseReactionNext(TNode<PromiseReaction> p_o);
void StorePromiseReactionNext(TNode<PromiseReaction> p_o, TNode<Object> p_v);
TNode<HeapObject> LoadPromiseReactionRejectHandler(TNode<PromiseReaction> p_o);
void StorePromiseReactionRejectHandler(TNode<PromiseReaction> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadPromiseReactionFulfillHandler(TNode<PromiseReaction> p_o);
void StorePromiseReactionFulfillHandler(TNode<PromiseReaction> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadPromiseReactionPromiseOrCapability(TNode<PromiseReaction> p_o);
void StorePromiseReactionPromiseOrCapability(TNode<PromiseReaction> p_o, TNode<HeapObject> p_v);
TNode<Object> LoadPromiseReactionContinuationPreservedEmbedderData(TNode<PromiseReaction> p_o);
void StorePromiseReactionContinuationPreservedEmbedderData(TNode<PromiseReaction> p_o, TNode<Object> p_v);
TNode<Object> LoadPromiseReactionJobTaskArgument(TNode<PromiseReactionJobTask> p_o);
void StorePromiseReactionJobTaskArgument(TNode<PromiseReactionJobTask> p_o, TNode<Object> p_v);
TNode<Context> LoadPromiseReactionJobTaskContext(TNode<PromiseReactionJobTask> p_o);
void StorePromiseReactionJobTaskContext(TNode<PromiseReactionJobTask> p_o, TNode<Context> p_v);
TNode<HeapObject> LoadPromiseReactionJobTaskHandler(TNode<PromiseReactionJobTask> p_o);
void StorePromiseReactionJobTaskHandler(TNode<PromiseReactionJobTask> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadPromiseReactionJobTaskPromiseOrCapability(TNode<PromiseReactionJobTask> p_o);
void StorePromiseReactionJobTaskPromiseOrCapability(TNode<PromiseReactionJobTask> p_o, TNode<HeapObject> p_v);
TNode<Object> LoadPromiseReactionJobTaskContinuationPreservedEmbedderData(TNode<PromiseReactionJobTask> p_o);
void StorePromiseReactionJobTaskContinuationPreservedEmbedderData(TNode<PromiseReactionJobTask> p_o, TNode<Object> p_v);
TNode<Context> LoadPromiseResolveThenableJobTaskContext(TNode<PromiseResolveThenableJobTask> p_o);
void StorePromiseResolveThenableJobTaskContext(TNode<PromiseResolveThenableJobTask> p_o, TNode<Context> p_v);
TNode<JSPromise> LoadPromiseResolveThenableJobTaskPromiseToResolve(TNode<PromiseResolveThenableJobTask> p_o);
void StorePromiseResolveThenableJobTaskPromiseToResolve(TNode<PromiseResolveThenableJobTask> p_o, TNode<JSPromise> p_v);
TNode<JSReceiver> LoadPromiseResolveThenableJobTaskThenable(TNode<PromiseResolveThenableJobTask> p_o);
void StorePromiseResolveThenableJobTaskThenable(TNode<PromiseResolveThenableJobTask> p_o, TNode<JSReceiver> p_v);
TNode<JSReceiver> LoadPromiseResolveThenableJobTaskThen(TNode<PromiseResolveThenableJobTask> p_o);
void StorePromiseResolveThenableJobTaskThen(TNode<PromiseResolveThenableJobTask> p_o, TNode<JSReceiver> p_v);
TNode<Smi> LoadPropertyArrayLengthAndHash(TNode<PropertyArray> p_o);
void StorePropertyArrayLengthAndHash(TNode<PropertyArray> p_o, TNode<Smi> p_v);
TNode<Name> LoadPropertyCellName(TNode<PropertyCell> p_o);
void StorePropertyCellName(TNode<PropertyCell> p_o, TNode<Name> p_v);
TNode<Smi> LoadPropertyCellPropertyDetailsRaw(TNode<PropertyCell> p_o);
void StorePropertyCellPropertyDetailsRaw(TNode<PropertyCell> p_o, TNode<Smi> p_v);
TNode<Object> LoadPropertyCellValue(TNode<PropertyCell> p_o);
void StorePropertyCellValue(TNode<PropertyCell> p_o, TNode<Object> p_v);
TNode<WeakFixedArray> LoadPropertyCellDependentCode(TNode<PropertyCell> p_o);
void StorePropertyCellDependentCode(TNode<PropertyCell> p_o, TNode<WeakFixedArray> p_v);
TNode<Smi> LoadPropertyDescriptorObjectFlags(TNode<PropertyDescriptorObject> p_o);
void StorePropertyDescriptorObjectFlags(TNode<PropertyDescriptorObject> p_o, TNode<Smi> p_v);
TNode<Object> LoadPropertyDescriptorObjectValue(TNode<PropertyDescriptorObject> p_o);
void StorePropertyDescriptorObjectValue(TNode<PropertyDescriptorObject> p_o, TNode<Object> p_v);
TNode<Object> LoadPropertyDescriptorObjectGet(TNode<PropertyDescriptorObject> p_o);
void StorePropertyDescriptorObjectGet(TNode<PropertyDescriptorObject> p_o, TNode<Object> p_v);
TNode<Object> LoadPropertyDescriptorObjectSet(TNode<PropertyDescriptorObject> p_o);
void StorePropertyDescriptorObjectSet(TNode<PropertyDescriptorObject> p_o, TNode<Object> p_v);
TNode<HeapObject> LoadPrototypeInfoModuleNamespace(TNode<PrototypeInfo> p_o);
void StorePrototypeInfoModuleNamespace(TNode<PrototypeInfo> p_o, TNode<HeapObject> p_v);
TNode<Object> LoadPrototypeInfoPrototypeUsers(TNode<PrototypeInfo> p_o);
void StorePrototypeInfoPrototypeUsers(TNode<PrototypeInfo> p_o, TNode<Object> p_v);
TNode<Object> LoadPrototypeInfoPrototypeChainEnumCache(TNode<PrototypeInfo> p_o);
void StorePrototypeInfoPrototypeChainEnumCache(TNode<PrototypeInfo> p_o, TNode<Object> p_v);
TNode<Smi> LoadPrototypeInfoRegistrySlot(TNode<PrototypeInfo> p_o);
void StorePrototypeInfoRegistrySlot(TNode<PrototypeInfo> p_o, TNode<Smi> p_v);
TNode<MaybeObject> LoadPrototypeInfoObjectCreateMap(TNode<PrototypeInfo> p_o);
void StorePrototypeInfoObjectCreateMap(TNode<PrototypeInfo> p_o, TNode<MaybeObject> p_v);
TNode<Smi> LoadPrototypeInfoBitField(TNode<PrototypeInfo> p_o);
void StorePrototypeInfoBitField(TNode<PrototypeInfo> p_o, TNode<Smi> p_v);
TNode<PrimitiveHeapObject> LoadScriptSource(TNode<Script> p_o);
void StoreScriptSource(TNode<Script> p_o, TNode<PrimitiveHeapObject> p_v);
TNode<Object> LoadScriptName(TNode<Script> p_o);
void StoreScriptName(TNode<Script> p_o, TNode<Object> p_v);
TNode<Smi> LoadScriptLineOffset(TNode<Script> p_o);
void StoreScriptLineOffset(TNode<Script> p_o, TNode<Smi> p_v);
TNode<Smi> LoadScriptColumnOffset(TNode<Script> p_o);
void StoreScriptColumnOffset(TNode<Script> p_o, TNode<Smi> p_v);
TNode<Object> LoadScriptContextData(TNode<Script> p_o);
void StoreScriptContextData(TNode<Script> p_o, TNode<Object> p_v);
TNode<Smi> LoadScriptScriptType(TNode<Script> p_o);
void StoreScriptScriptType(TNode<Script> p_o, TNode<Smi> p_v);
TNode<HeapObject> LoadScriptLineEnds(TNode<Script> p_o);
void StoreScriptLineEnds(TNode<Script> p_o, TNode<HeapObject> p_v);
TNode<Smi> LoadScriptId(TNode<Script> p_o);
void StoreScriptId(TNode<Script> p_o, TNode<Smi> p_v);
TNode<HeapObject> LoadScriptEvalFromSharedOrWrappedArgumentsOrSfiTable(TNode<Script> p_o);
void StoreScriptEvalFromSharedOrWrappedArgumentsOrSfiTable(TNode<Script> p_o, TNode<HeapObject> p_v);
TNode<Object> LoadScriptEvalFromPosition(TNode<Script> p_o);
void StoreScriptEvalFromPosition(TNode<Script> p_o, TNode<Object> p_v);
TNode<HeapObject> LoadScriptSharedFunctionInfos(TNode<Script> p_o);
void StoreScriptSharedFunctionInfos(TNode<Script> p_o, TNode<HeapObject> p_v);
TNode<Smi> LoadScriptFlags(TNode<Script> p_o);
void StoreScriptFlags(TNode<Script> p_o, TNode<Smi> p_v);
TNode<PrimitiveHeapObject> LoadScriptSourceUrl(TNode<Script> p_o);
void StoreScriptSourceUrl(TNode<Script> p_o, TNode<PrimitiveHeapObject> p_v);
TNode<Object> LoadScriptSourceMappingUrl(TNode<Script> p_o);
void StoreScriptSourceMappingUrl(TNode<Script> p_o, TNode<Object> p_v);
TNode<FixedArray> LoadScriptHostDefinedOptions(TNode<Script> p_o);
void StoreScriptHostDefinedOptions(TNode<Script> p_o, TNode<FixedArray> p_v);
TNode<Int32T> LoadPreparseDataDataLength(TNode<PreparseData> p_o);
void StorePreparseDataDataLength(TNode<PreparseData> p_o, TNode<Int32T> p_v);
TNode<Int32T> LoadPreparseDataChildrenLength(TNode<PreparseData> p_o);
void StorePreparseDataChildrenLength(TNode<PreparseData> p_o, TNode<Int32T> p_v);
TNode<BytecodeArray> LoadInterpreterDataBytecodeArray(TNode<InterpreterData> p_o);
void StoreInterpreterDataBytecodeArray(TNode<InterpreterData> p_o, TNode<BytecodeArray> p_v);
TNode<Code> LoadInterpreterDataInterpreterTrampoline(TNode<InterpreterData> p_o);
void StoreInterpreterDataInterpreterTrampoline(TNode<InterpreterData> p_o, TNode<Code> p_v);
TNode<Code> LoadBaselineDataBaselineCode(TNode<BaselineData> p_o);
void StoreBaselineDataBaselineCode(TNode<BaselineData> p_o, TNode<Code> p_v);
TNode<HeapObject> LoadBaselineDataData(TNode<BaselineData> p_o);
void StoreBaselineDataData(TNode<BaselineData> p_o, TNode<HeapObject> p_v);
TNode<Object> LoadSharedFunctionInfoFunctionData(TNode<SharedFunctionInfo> p_o);
void StoreSharedFunctionInfoFunctionData(TNode<SharedFunctionInfo> p_o, TNode<Object> p_v);
TNode<Object> LoadSharedFunctionInfoNameOrScopeInfo(TNode<SharedFunctionInfo> p_o);
void StoreSharedFunctionInfoNameOrScopeInfo(TNode<SharedFunctionInfo> p_o, TNode<Object> p_v);
TNode<HeapObject> LoadSharedFunctionInfoOuterScopeInfoOrFeedbackMetadata(TNode<SharedFunctionInfo> p_o);
void StoreSharedFunctionInfoOuterScopeInfoOrFeedbackMetadata(TNode<SharedFunctionInfo> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadSharedFunctionInfoScriptOrDebugInfo(TNode<SharedFunctionInfo> p_o);
void StoreSharedFunctionInfoScriptOrDebugInfo(TNode<SharedFunctionInfo> p_o, TNode<HeapObject> p_v);
TNode<Int16T> LoadSharedFunctionInfoLength(TNode<SharedFunctionInfo> p_o);
void StoreSharedFunctionInfoLength(TNode<SharedFunctionInfo> p_o, TNode<Int16T> p_v);
TNode<Uint16T> LoadSharedFunctionInfoFormalParameterCount(TNode<SharedFunctionInfo> p_o);
void StoreSharedFunctionInfoFormalParameterCount(TNode<SharedFunctionInfo> p_o, TNode<Uint16T> p_v);
TNode<Uint16T> LoadSharedFunctionInfoFunctionTokenOffset(TNode<SharedFunctionInfo> p_o);
void StoreSharedFunctionInfoFunctionTokenOffset(TNode<SharedFunctionInfo> p_o, TNode<Uint16T> p_v);
TNode<Uint8T> LoadSharedFunctionInfoExpectedNofProperties(TNode<SharedFunctionInfo> p_o);
void StoreSharedFunctionInfoExpectedNofProperties(TNode<SharedFunctionInfo> p_o, TNode<Uint8T> p_v);
TNode<Uint8T> LoadSharedFunctionInfoFlags2(TNode<SharedFunctionInfo> p_o);
void StoreSharedFunctionInfoFlags2(TNode<SharedFunctionInfo> p_o, TNode<Uint8T> p_v);
TNode<Uint32T> LoadSharedFunctionInfoFlags(TNode<SharedFunctionInfo> p_o);
void StoreSharedFunctionInfoFlags(TNode<SharedFunctionInfo> p_o, TNode<Uint32T> p_v);
TNode<Int32T> LoadSharedFunctionInfoFunctionLiteralId(TNode<SharedFunctionInfo> p_o);
void StoreSharedFunctionInfoFunctionLiteralId(TNode<SharedFunctionInfo> p_o, TNode<Int32T> p_v);
TNode<String> LoadUncompiledDataInferredName(TNode<UncompiledData> p_o);
void StoreUncompiledDataInferredName(TNode<UncompiledData> p_o, TNode<String> p_v);
TNode<Int32T> LoadUncompiledDataStartPosition(TNode<UncompiledData> p_o);
void StoreUncompiledDataStartPosition(TNode<UncompiledData> p_o, TNode<Int32T> p_v);
TNode<Int32T> LoadUncompiledDataEndPosition(TNode<UncompiledData> p_o);
void StoreUncompiledDataEndPosition(TNode<UncompiledData> p_o, TNode<Int32T> p_v);
TNode<PreparseData> LoadUncompiledDataWithPreparseDataPreparseData(TNode<UncompiledDataWithPreparseData> p_o);
void StoreUncompiledDataWithPreparseDataPreparseData(TNode<UncompiledDataWithPreparseData> p_o, TNode<PreparseData> p_v);
TNode<ByteArray> LoadOnHeapBasicBlockProfilerDataBlockIds(TNode<OnHeapBasicBlockProfilerData> p_o);
void StoreOnHeapBasicBlockProfilerDataBlockIds(TNode<OnHeapBasicBlockProfilerData> p_o, TNode<ByteArray> p_v);
TNode<ByteArray> LoadOnHeapBasicBlockProfilerDataCounts(TNode<OnHeapBasicBlockProfilerData> p_o);
void StoreOnHeapBasicBlockProfilerDataCounts(TNode<OnHeapBasicBlockProfilerData> p_o, TNode<ByteArray> p_v);
TNode<String> LoadOnHeapBasicBlockProfilerDataName(TNode<OnHeapBasicBlockProfilerData> p_o);
void StoreOnHeapBasicBlockProfilerDataName(TNode<OnHeapBasicBlockProfilerData> p_o, TNode<String> p_v);
TNode<String> LoadOnHeapBasicBlockProfilerDataSchedule(TNode<OnHeapBasicBlockProfilerData> p_o);
void StoreOnHeapBasicBlockProfilerDataSchedule(TNode<OnHeapBasicBlockProfilerData> p_o, TNode<String> p_v);
TNode<String> LoadOnHeapBasicBlockProfilerDataCode(TNode<OnHeapBasicBlockProfilerData> p_o);
void StoreOnHeapBasicBlockProfilerDataCode(TNode<OnHeapBasicBlockProfilerData> p_o, TNode<String> p_v);
TNode<Smi> LoadOnHeapBasicBlockProfilerDataHash(TNode<OnHeapBasicBlockProfilerData> p_o);
void StoreOnHeapBasicBlockProfilerDataHash(TNode<OnHeapBasicBlockProfilerData> p_o, TNode<Smi> p_v);
TNode<HeapObject> LoadSourceTextModuleCode(TNode<SourceTextModule> p_o);
void StoreSourceTextModuleCode(TNode<SourceTextModule> p_o, TNode<HeapObject> p_v);
TNode<FixedArray> LoadSourceTextModuleRegularExports(TNode<SourceTextModule> p_o);
void StoreSourceTextModuleRegularExports(TNode<SourceTextModule> p_o, TNode<FixedArray> p_v);
TNode<FixedArray> LoadSourceTextModuleRegularImports(TNode<SourceTextModule> p_o);
void StoreSourceTextModuleRegularImports(TNode<SourceTextModule> p_o, TNode<FixedArray> p_v);
TNode<FixedArray> LoadSourceTextModuleRequestedModules(TNode<SourceTextModule> p_o);
void StoreSourceTextModuleRequestedModules(TNode<SourceTextModule> p_o, TNode<FixedArray> p_v);
TNode<HeapObject> LoadSourceTextModuleImportMeta(TNode<SourceTextModule> p_o);
void StoreSourceTextModuleImportMeta(TNode<SourceTextModule> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadSourceTextModuleCycleRoot(TNode<SourceTextModule> p_o);
void StoreSourceTextModuleCycleRoot(TNode<SourceTextModule> p_o, TNode<HeapObject> p_v);
TNode<ArrayList> LoadSourceTextModuleAsyncParentModules(TNode<SourceTextModule> p_o);
void StoreSourceTextModuleAsyncParentModules(TNode<SourceTextModule> p_o, TNode<ArrayList> p_v);
TNode<Smi> LoadSourceTextModuleDfsIndex(TNode<SourceTextModule> p_o);
void StoreSourceTextModuleDfsIndex(TNode<SourceTextModule> p_o, TNode<Smi> p_v);
TNode<Smi> LoadSourceTextModuleDfsAncestorIndex(TNode<SourceTextModule> p_o);
void StoreSourceTextModuleDfsAncestorIndex(TNode<SourceTextModule> p_o, TNode<Smi> p_v);
TNode<Smi> LoadSourceTextModulePendingAsyncDependencies(TNode<SourceTextModule> p_o);
void StoreSourceTextModulePendingAsyncDependencies(TNode<SourceTextModule> p_o, TNode<Smi> p_v);
TNode<Smi> LoadSourceTextModuleFlags(TNode<SourceTextModule> p_o);
void StoreSourceTextModuleFlags(TNode<SourceTextModule> p_o, TNode<Smi> p_v);
TNode<String> LoadModuleRequestSpecifier(TNode<ModuleRequest> p_o);
void StoreModuleRequestSpecifier(TNode<ModuleRequest> p_o, TNode<String> p_v);
TNode<FixedArray> LoadModuleRequestImportAssertions(TNode<ModuleRequest> p_o);
void StoreModuleRequestImportAssertions(TNode<ModuleRequest> p_o, TNode<FixedArray> p_v);
TNode<Smi> LoadModuleRequestPosition(TNode<ModuleRequest> p_o);
void StoreModuleRequestPosition(TNode<ModuleRequest> p_o, TNode<Smi> p_v);
TNode<PrimitiveHeapObject> LoadSourceTextModuleInfoEntryExportName(TNode<SourceTextModuleInfoEntry> p_o);
void StoreSourceTextModuleInfoEntryExportName(TNode<SourceTextModuleInfoEntry> p_o, TNode<PrimitiveHeapObject> p_v);
TNode<PrimitiveHeapObject> LoadSourceTextModuleInfoEntryLocalName(TNode<SourceTextModuleInfoEntry> p_o);
void StoreSourceTextModuleInfoEntryLocalName(TNode<SourceTextModuleInfoEntry> p_o, TNode<PrimitiveHeapObject> p_v);
TNode<PrimitiveHeapObject> LoadSourceTextModuleInfoEntryImportName(TNode<SourceTextModuleInfoEntry> p_o);
void StoreSourceTextModuleInfoEntryImportName(TNode<SourceTextModuleInfoEntry> p_o, TNode<PrimitiveHeapObject> p_v);
TNode<Smi> LoadSourceTextModuleInfoEntryModuleRequest(TNode<SourceTextModuleInfoEntry> p_o);
void StoreSourceTextModuleInfoEntryModuleRequest(TNode<SourceTextModuleInfoEntry> p_o, TNode<Smi> p_v);
TNode<Smi> LoadSourceTextModuleInfoEntryCellIndex(TNode<SourceTextModuleInfoEntry> p_o);
void StoreSourceTextModuleInfoEntryCellIndex(TNode<SourceTextModuleInfoEntry> p_o, TNode<Smi> p_v);
TNode<Smi> LoadSourceTextModuleInfoEntryBegPos(TNode<SourceTextModuleInfoEntry> p_o);
void StoreSourceTextModuleInfoEntryBegPos(TNode<SourceTextModuleInfoEntry> p_o, TNode<Smi> p_v);
TNode<Smi> LoadSourceTextModuleInfoEntryEndPos(TNode<SourceTextModuleInfoEntry> p_o);
void StoreSourceTextModuleInfoEntryEndPos(TNode<SourceTextModuleInfoEntry> p_o, TNode<Smi> p_v);
TNode<Object> LoadStackFrameInfoReceiverOrInstance(TNode<StackFrameInfo> p_o);
void StoreStackFrameInfoReceiverOrInstance(TNode<StackFrameInfo> p_o, TNode<Object> p_v);
TNode<Object> LoadStackFrameInfoFunction(TNode<StackFrameInfo> p_o);
void StoreStackFrameInfoFunction(TNode<StackFrameInfo> p_o, TNode<Object> p_v);
TNode<HeapObject> LoadStackFrameInfoCodeObject(TNode<StackFrameInfo> p_o);
void StoreStackFrameInfoCodeObject(TNode<StackFrameInfo> p_o, TNode<HeapObject> p_v);
TNode<Smi> LoadStackFrameInfoCodeOffsetOrSourcePosition(TNode<StackFrameInfo> p_o);
void StoreStackFrameInfoCodeOffsetOrSourcePosition(TNode<StackFrameInfo> p_o, TNode<Smi> p_v);
TNode<Smi> LoadStackFrameInfoFlags(TNode<StackFrameInfo> p_o);
void StoreStackFrameInfoFlags(TNode<StackFrameInfo> p_o, TNode<Smi> p_v);
TNode<FixedArray> LoadStackFrameInfoParameters(TNode<StackFrameInfo> p_o);
void StoreStackFrameInfoParameters(TNode<StackFrameInfo> p_o, TNode<FixedArray> p_v);
TNode<String> LoadConsStringFirst(TNode<ConsString> p_o);
void StoreConsStringFirst(TNode<ConsString> p_o, TNode<String> p_v);
TNode<String> LoadConsStringSecond(TNode<ConsString> p_o);
void StoreConsStringSecond(TNode<ConsString> p_o, TNode<String> p_v);
TNode<ExternalPointerT> LoadExternalStringResource(TNode<ExternalString> p_o);
void StoreExternalStringResource(TNode<ExternalString> p_o, TNode<ExternalPointerT> p_v);
TNode<ExternalPointerT> LoadExternalStringResourceData(TNode<ExternalString> p_o);
void StoreExternalStringResourceData(TNode<ExternalString> p_o, TNode<ExternalPointerT> p_v);
TorqueStructSlice_char8_ConstReference_char8_0 FieldSliceSeqOneByteStringChars(TNode<SeqOneByteString> p_o);
TNode<Uint8T> LoadSeqOneByteStringChars(TNode<SeqOneByteString> p_o, TNode<IntPtrT> p_i);
TorqueStructSlice_char16_ConstReference_char16_0 FieldSliceSeqTwoByteStringChars(TNode<SeqTwoByteString> p_o);
TNode<Uint16T> LoadSeqTwoByteStringChars(TNode<SeqTwoByteString> p_o, TNode<IntPtrT> p_i);
TNode<String> LoadSlicedStringParent(TNode<SlicedString> p_o);
void StoreSlicedStringParent(TNode<SlicedString> p_o, TNode<String> p_v);
TNode<Smi> LoadSlicedStringOffset(TNode<SlicedString> p_o);
void StoreSlicedStringOffset(TNode<SlicedString> p_o, TNode<Smi> p_v);
TNode<String> LoadThinStringActual(TNode<ThinString> p_o);
void StoreThinStringActual(TNode<ThinString> p_o, TNode<String> p_v);
TNode<Object> LoadTuple2Value1(TNode<Tuple2> p_o);
void StoreTuple2Value1(TNode<Tuple2> p_o, TNode<Object> p_v);
TNode<Object> LoadTuple2Value2(TNode<Tuple2> p_o);
void StoreTuple2Value2(TNode<Tuple2> p_o, TNode<Object> p_v);
TNode<Uint32T> LoadSwissNameDictionaryHash(TNode<SwissNameDictionary> p_o);
void StoreSwissNameDictionaryHash(TNode<SwissNameDictionary> p_o, TNode<Uint32T> p_v);
TNode<Int32T> LoadSwissNameDictionaryCapacity(TNode<SwissNameDictionary> p_o);
TNode<ByteArray> LoadSwissNameDictionaryMetaTable(TNode<SwissNameDictionary> p_o);
void StoreSwissNameDictionaryMetaTable(TNode<SwissNameDictionary> p_o, TNode<ByteArray> p_v);
TorqueStructSlice_JSReceiver_OR_Smi_OR_HeapNumber_OR_BigInt_OR_String_OR_Symbol_OR_True_OR_False_OR_Null_OR_Undefined_OR_TheHole_MutableReference_JSReceiver_OR_Smi_OR_HeapNumber_OR_BigInt_OR_String_OR_Symbol_OR_True_OR_False_OR_Null_OR_Undefined_OR_TheHole_0 FieldSliceSwissNameDictionaryDataTable(TNode<SwissNameDictionary> p_o);
TNode<Object> LoadSwissNameDictionaryDataTable(TNode<SwissNameDictionary> p_o, TNode<IntPtrT> p_i);
void StoreSwissNameDictionaryDataTable(TNode<SwissNameDictionary> p_o, TNode<IntPtrT> p_i, TNode<Object> p_v);
TorqueStructSlice_uint8_MutableReference_uint8_0 FieldSliceSwissNameDictionaryCtrlTable(TNode<SwissNameDictionary> p_o);
TNode<Uint8T> LoadSwissNameDictionaryCtrlTable(TNode<SwissNameDictionary> p_o, TNode<IntPtrT> p_i);
void StoreSwissNameDictionaryCtrlTable(TNode<SwissNameDictionary> p_o, TNode<IntPtrT> p_i, TNode<Uint8T> p_v);
TorqueStructSlice_uint8_MutableReference_uint8_0 FieldSliceSwissNameDictionaryPropertyDetailsTable(TNode<SwissNameDictionary> p_o);
TNode<Uint8T> LoadSwissNameDictionaryPropertyDetailsTable(TNode<SwissNameDictionary> p_o, TNode<IntPtrT> p_i);
void StoreSwissNameDictionaryPropertyDetailsTable(TNode<SwissNameDictionary> p_o, TNode<IntPtrT> p_i, TNode<Uint8T> p_v);
TNode<String> LoadSyntheticModuleName(TNode<SyntheticModule> p_o);
void StoreSyntheticModuleName(TNode<SyntheticModule> p_o, TNode<String> p_v);
TNode<FixedArray> LoadSyntheticModuleExportNames(TNode<SyntheticModule> p_o);
void StoreSyntheticModuleExportNames(TNode<SyntheticModule> p_o, TNode<FixedArray> p_v);
TNode<Foreign> LoadSyntheticModuleEvaluationSteps(TNode<SyntheticModule> p_o);
void StoreSyntheticModuleEvaluationSteps(TNode<SyntheticModule> p_o, TNode<Foreign> p_v);
TNode<Smi> LoadCachedTemplateObjectSlotId(TNode<CachedTemplateObject> p_o);
void StoreCachedTemplateObjectSlotId(TNode<CachedTemplateObject> p_o, TNode<Smi> p_v);
TNode<JSArray> LoadCachedTemplateObjectTemplateObject(TNode<CachedTemplateObject> p_o);
void StoreCachedTemplateObjectTemplateObject(TNode<CachedTemplateObject> p_o, TNode<JSArray> p_v);
TNode<HeapObject> LoadCachedTemplateObjectNext(TNode<CachedTemplateObject> p_o);
void StoreCachedTemplateObjectNext(TNode<CachedTemplateObject> p_o, TNode<HeapObject> p_v);
TNode<FixedArray> LoadTemplateObjectDescriptionRawStrings(TNode<TemplateObjectDescription> p_o);
void StoreTemplateObjectDescriptionRawStrings(TNode<TemplateObjectDescription> p_o, TNode<FixedArray> p_v);
TNode<FixedArray> LoadTemplateObjectDescriptionCookedStrings(TNode<TemplateObjectDescription> p_o);
void StoreTemplateObjectDescriptionCookedStrings(TNode<TemplateObjectDescription> p_o, TNode<FixedArray> p_v);
TNode<Smi> LoadTemplateInfoTag(TNode<TemplateInfo> p_o);
void StoreTemplateInfoTag(TNode<TemplateInfo> p_o, TNode<Smi> p_v);
TNode<Smi> LoadTemplateInfoSerialNumber(TNode<TemplateInfo> p_o);
void StoreTemplateInfoSerialNumber(TNode<TemplateInfo> p_o, TNode<Smi> p_v);
TNode<Smi> LoadTemplateInfoNumberOfProperties(TNode<TemplateInfo> p_o);
void StoreTemplateInfoNumberOfProperties(TNode<TemplateInfo> p_o, TNode<Smi> p_v);
TNode<HeapObject> LoadTemplateInfoPropertyList(TNode<TemplateInfo> p_o);
void StoreTemplateInfoPropertyList(TNode<TemplateInfo> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadTemplateInfoPropertyAccessors(TNode<TemplateInfo> p_o);
void StoreTemplateInfoPropertyAccessors(TNode<TemplateInfo> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadFunctionTemplateRareDataPrototypeTemplate(TNode<FunctionTemplateRareData> p_o);
void StoreFunctionTemplateRareDataPrototypeTemplate(TNode<FunctionTemplateRareData> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadFunctionTemplateRareDataPrototypeProviderTemplate(TNode<FunctionTemplateRareData> p_o);
void StoreFunctionTemplateRareDataPrototypeProviderTemplate(TNode<FunctionTemplateRareData> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadFunctionTemplateRareDataParentTemplate(TNode<FunctionTemplateRareData> p_o);
void StoreFunctionTemplateRareDataParentTemplate(TNode<FunctionTemplateRareData> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadFunctionTemplateRareDataNamedPropertyHandler(TNode<FunctionTemplateRareData> p_o);
void StoreFunctionTemplateRareDataNamedPropertyHandler(TNode<FunctionTemplateRareData> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadFunctionTemplateRareDataIndexedPropertyHandler(TNode<FunctionTemplateRareData> p_o);
void StoreFunctionTemplateRareDataIndexedPropertyHandler(TNode<FunctionTemplateRareData> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadFunctionTemplateRareDataInstanceTemplate(TNode<FunctionTemplateRareData> p_o);
void StoreFunctionTemplateRareDataInstanceTemplate(TNode<FunctionTemplateRareData> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadFunctionTemplateRareDataInstanceCallHandler(TNode<FunctionTemplateRareData> p_o);
void StoreFunctionTemplateRareDataInstanceCallHandler(TNode<FunctionTemplateRareData> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadFunctionTemplateRareDataAccessCheckInfo(TNode<FunctionTemplateRareData> p_o);
void StoreFunctionTemplateRareDataAccessCheckInfo(TNode<FunctionTemplateRareData> p_o, TNode<HeapObject> p_v);
TNode<FixedArray> LoadFunctionTemplateRareDataCFunctionOverloads(TNode<FunctionTemplateRareData> p_o);
void StoreFunctionTemplateRareDataCFunctionOverloads(TNode<FunctionTemplateRareData> p_o, TNode<FixedArray> p_v);
TNode<HeapObject> LoadFunctionTemplateInfoCallCode(TNode<FunctionTemplateInfo> p_o);
void StoreFunctionTemplateInfoCallCode(TNode<FunctionTemplateInfo> p_o, TNode<HeapObject> p_v);
TNode<PrimitiveHeapObject> LoadFunctionTemplateInfoClassName(TNode<FunctionTemplateInfo> p_o);
void StoreFunctionTemplateInfoClassName(TNode<FunctionTemplateInfo> p_o, TNode<PrimitiveHeapObject> p_v);
TNode<HeapObject> LoadFunctionTemplateInfoSignature(TNode<FunctionTemplateInfo> p_o);
void StoreFunctionTemplateInfoSignature(TNode<FunctionTemplateInfo> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadFunctionTemplateInfoRareData(TNode<FunctionTemplateInfo> p_o);
void StoreFunctionTemplateInfoRareData(TNode<FunctionTemplateInfo> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadFunctionTemplateInfoSharedFunctionInfo(TNode<FunctionTemplateInfo> p_o);
void StoreFunctionTemplateInfoSharedFunctionInfo(TNode<FunctionTemplateInfo> p_o, TNode<HeapObject> p_v);
TNode<Smi> LoadFunctionTemplateInfoFlag(TNode<FunctionTemplateInfo> p_o);
void StoreFunctionTemplateInfoFlag(TNode<FunctionTemplateInfo> p_o, TNode<Smi> p_v);
TNode<Smi> LoadFunctionTemplateInfoLength(TNode<FunctionTemplateInfo> p_o);
void StoreFunctionTemplateInfoLength(TNode<FunctionTemplateInfo> p_o, TNode<Smi> p_v);
TNode<Object> LoadFunctionTemplateInfoCachedPropertyName(TNode<FunctionTemplateInfo> p_o);
void StoreFunctionTemplateInfoCachedPropertyName(TNode<FunctionTemplateInfo> p_o, TNode<Object> p_v);
TNode<Smi> LoadFunctionTemplateInfoInstanceType(TNode<FunctionTemplateInfo> p_o);
void StoreFunctionTemplateInfoInstanceType(TNode<FunctionTemplateInfo> p_o, TNode<Smi> p_v);
TNode<HeapObject> LoadObjectTemplateInfoConstructor(TNode<ObjectTemplateInfo> p_o);
void StoreObjectTemplateInfoConstructor(TNode<ObjectTemplateInfo> p_o, TNode<HeapObject> p_v);
TNode<Smi> LoadObjectTemplateInfoData(TNode<ObjectTemplateInfo> p_o);
void StoreObjectTemplateInfoData(TNode<ObjectTemplateInfo> p_o, TNode<Smi> p_v);
TNode<Smi> LoadInternalClassA(TNode<InternalClass> p_o);
void StoreInternalClassA(TNode<InternalClass> p_o, TNode<Smi> p_v);
TNode<Number> LoadInternalClassB(TNode<InternalClass> p_o);
void StoreInternalClassB(TNode<InternalClass> p_o, TNode<Number> p_v);
TNode<Smi> LoadSmiPairA(TNode<SmiPair> p_o);
void StoreSmiPairA(TNode<SmiPair> p_o, TNode<Smi> p_v);
TNode<Smi> LoadSmiPairB(TNode<SmiPair> p_o);
void StoreSmiPairB(TNode<SmiPair> p_o, TNode<Smi> p_v);
TNode<Smi> LoadSmiBoxValue(TNode<SmiBox> p_o);
void StoreSmiBoxValue(TNode<SmiBox> p_o, TNode<Smi> p_v);
TNode<Smi> LoadSmiBoxUnrelated(TNode<SmiBox> p_o);
void StoreSmiBoxUnrelated(TNode<SmiBox> p_o, TNode<Smi> p_v);
TNode<HeapObject> LoadExportedSubClassBaseA(TNode<ExportedSubClassBase> p_o);
void StoreExportedSubClassBaseA(TNode<ExportedSubClassBase> p_o, TNode<HeapObject> p_v);
TNode<HeapObject> LoadExportedSubClassBaseB(TNode<ExportedSubClassBase> p_o);
void StoreExportedSubClassBaseB(TNode<ExportedSubClassBase> p_o, TNode<HeapObject> p_v);
TNode<Int32T> LoadExportedSubClassCField(TNode<ExportedSubClass> p_o);
void StoreExportedSubClassCField(TNode<ExportedSubClass> p_o, TNode<Int32T> p_v);
TNode<Int32T> LoadExportedSubClassDField(TNode<ExportedSubClass> p_o);
void StoreExportedSubClassDField(TNode<ExportedSubClass> p_o, TNode<Int32T> p_v);
TNode<Smi> LoadExportedSubClassEField(TNode<ExportedSubClass> p_o);
void StoreExportedSubClassEField(TNode<ExportedSubClass> p_o, TNode<Smi> p_v);
TNode<Smi> LoadInternalClassWithSmiElementsData(TNode<InternalClassWithSmiElements> p_o);
void StoreInternalClassWithSmiElementsData(TNode<InternalClassWithSmiElements> p_o, TNode<Smi> p_v);
TNode<Oddball> LoadInternalClassWithSmiElementsObject(TNode<InternalClassWithSmiElements> p_o);
void StoreInternalClassWithSmiElementsObject(TNode<InternalClassWithSmiElements> p_o, TNode<Oddball> p_v);
TorqueStructSlice_Smi_MutableReference_Smi_0 FieldSliceInternalClassWithSmiElementsEntries(TNode<InternalClassWithSmiElements> p_o);
TNode<Smi> LoadInternalClassWithSmiElementsEntries(TNode<InternalClassWithSmiElements> p_o, TNode<IntPtrT> p_i);
void StoreInternalClassWithSmiElementsEntries(TNode<InternalClassWithSmiElements> p_o, TNode<IntPtrT> p_i, TNode<Smi> p_v);
TNode<Int32T> LoadInternalClassWithStructElementsDummy1(TNode<InternalClassWithStructElements> p_o);
void StoreInternalClassWithStructElementsDummy1(TNode<InternalClassWithStructElements> p_o, TNode<Int32T> p_v);
TNode<Int32T> LoadInternalClassWithStructElementsDummy2(TNode<InternalClassWithStructElements> p_o);
void StoreInternalClassWithStructElementsDummy2(TNode<InternalClassWithStructElements> p_o, TNode<Int32T> p_v);
TNode<Smi> LoadInternalClassWithStructElementsCount(TNode<InternalClassWithStructElements> p_o);
TNode<Smi> LoadInternalClassWithStructElementsData(TNode<InternalClassWithStructElements> p_o);
void StoreInternalClassWithStructElementsData(TNode<InternalClassWithStructElements> p_o, TNode<Smi> p_v);
TNode<Object> LoadInternalClassWithStructElementsObject(TNode<InternalClassWithStructElements> p_o);
void StoreInternalClassWithStructElementsObject(TNode<InternalClassWithStructElements> p_o, TNode<Object> p_v);
TorqueStructSlice_Smi_MutableReference_Smi_0 FieldSliceInternalClassWithStructElementsEntries(TNode<InternalClassWithStructElements> p_o);
TNode<Smi> LoadInternalClassWithStructElementsEntries(TNode<InternalClassWithStructElements> p_o, TNode<IntPtrT> p_i);
void StoreInternalClassWithStructElementsEntries(TNode<InternalClassWithStructElements> p_o, TNode<IntPtrT> p_i, TNode<Smi> p_v);
TorqueStructSlice_InternalClassStructElement_MutableReference_InternalClassStructElement_0 FieldSliceInternalClassWithStructElementsMoreEntries(TNode<InternalClassWithStructElements> p_o);
TNode<Int32T> LoadExportedSubClass2XField(TNode<ExportedSubClass2> p_o);
void StoreExportedSubClass2XField(TNode<ExportedSubClass2> p_o, TNode<Int32T> p_v);
TNode<Int32T> LoadExportedSubClass2YField(TNode<ExportedSubClass2> p_o);
void StoreExportedSubClass2YField(TNode<ExportedSubClass2> p_o, TNode<Int32T> p_v);
TNode<Smi> LoadExportedSubClass2ZField(TNode<ExportedSubClass2> p_o);
void StoreExportedSubClass2ZField(TNode<ExportedSubClass2> p_o, TNode<Smi> p_v);
TNode<JSReceiver> LoadSortStateReceiver(TNode<SortState> p_o);
void StoreSortStateReceiver(TNode<SortState> p_o, TNode<JSReceiver> p_v);
TNode<Map> LoadSortStateInitialReceiverMap(TNode<SortState> p_o);
void StoreSortStateInitialReceiverMap(TNode<SortState> p_o, TNode<Map> p_v);
TNode<Number> LoadSortStateInitialReceiverLength(TNode<SortState> p_o);
void StoreSortStateInitialReceiverLength(TNode<SortState> p_o, TNode<Number> p_v);
TNode<HeapObject> LoadSortStateUserCmpFn(TNode<SortState> p_o);
void StoreSortStateUserCmpFn(TNode<SortState> p_o, TNode<HeapObject> p_v);
TNode<BuiltinPtr> LoadSortStateSortComparePtr(TNode<SortState> p_o);
void StoreSortStateSortComparePtr(TNode<SortState> p_o, TNode<BuiltinPtr> p_v);
TNode<BuiltinPtr> LoadSortStateLoadFn(TNode<SortState> p_o);
void StoreSortStateLoadFn(TNode<SortState> p_o, TNode<BuiltinPtr> p_v);
TNode<BuiltinPtr> LoadSortStateStoreFn(TNode<SortState> p_o);
void StoreSortStateStoreFn(TNode<SortState> p_o, TNode<BuiltinPtr> p_v);
TNode<BuiltinPtr> LoadSortStateDeleteFn(TNode<SortState> p_o);
void StoreSortStateDeleteFn(TNode<SortState> p_o, TNode<BuiltinPtr> p_v);
TNode<BuiltinPtr> LoadSortStateCanUseSameAccessorFn(TNode<SortState> p_o);
void StoreSortStateCanUseSameAccessorFn(TNode<SortState> p_o, TNode<BuiltinPtr> p_v);
TNode<Smi> LoadSortStateMinGallop(TNode<SortState> p_o);
void StoreSortStateMinGallop(TNode<SortState> p_o, TNode<Smi> p_v);
TNode<Smi> LoadSortStatePendingRunsSize(TNode<SortState> p_o);
void StoreSortStatePendingRunsSize(TNode<SortState> p_o, TNode<Smi> p_v);
TNode<FixedArray> LoadSortStatePendingRuns(TNode<SortState> p_o);
void StoreSortStatePendingRuns(TNode<SortState> p_o, TNode<FixedArray> p_v);
TNode<FixedArray> LoadSortStateWorkArray(TNode<SortState> p_o);
void StoreSortStateWorkArray(TNode<SortState> p_o, TNode<FixedArray> p_v);
TNode<FixedArray> LoadSortStateTempArray(TNode<SortState> p_o);
void StoreSortStateTempArray(TNode<SortState> p_o, TNode<FixedArray> p_v);
TNode<Smi> LoadSortStateSortLength(TNode<SortState> p_o);
void StoreSortStateSortLength(TNode<SortState> p_o, TNode<Smi> p_v);
TNode<Smi> LoadSortStateNumberOfUndefined(TNode<SortState> p_o);
void StoreSortStateNumberOfUndefined(TNode<SortState> p_o, TNode<Smi> p_v);
 private:
  compiler::CodeAssemblerState* state_;
};
}  // namespace internal
}  // namespace v8
#endif  // V8_GEN_TORQUE_GENERATED_EXPORTED_MACROS_ASSEMBLER_H_
