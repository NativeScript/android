println "Build.gradle running"

import org.gradle.internal.os.OperatingSystem;

apply plugin: 'com.android.model.library'

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle-experimental:0.8.1'
    }
}

allprojects {
    repositories {
        jcenter()
    }
}

def ndkDebuggable = false;
def optimized = project.hasProperty("optimized")

if(optimized) {
    println "Optimized build triggered."
}

List<String> runTasks = gradle.startParameter.getTaskNames();
for (String runTask : runTasks) {
    if (!ndkDebuggable && runTask.contains("Debug") && (runTask.contains("assemble") || runTask.contains("compile") || runTask.contains("generate"))) {
        println "DEBUG build DETECTED. Switching ndk debuggable to true"
        ndkDebuggable = true;
    }
}


project.ext.sdkDir = System.getenv("ANDROID_HOME")
def ndkDir = System.getenv("ANDROID_NDK_HOME")
def propertiesFile = project.rootProject.file('local.properties')
if (propertiesFile.exists()) {
    Properties properties = new Properties()
    properties.load(propertiesFile.newDataInputStream())
    ndkDir = properties.getProperty('ndk.dir')
}
project.ext.ndkDir = ndkDir;


class StripSymbolsTaskExecutionListener implements TaskExecutionListener
{
    @Override
    void beforeExecute(Task task)
    {
    }

    String getMachineName()
    {
        if (OperatingSystem.current().isWindows())
        {
            return "windows";
        }
        else if (OperatingSystem.current().isMacOsX())
        {
            return "darwin";
        }
        else
        {
            return "linux";
        }
    }

    String getStripToolName(String stripTaskName)
    {
        stripTaskName = stripTaskName.toLowerCase();
        def stripToolName = ""
        if (stripTaskName.contains("arm64"))
        {
            stripToolName = "aarch64-linux-android-strip";
        }
        else if (stripTaskName.contains("arm"))
        {
            stripToolName = "arm-linux-androideabi-strip";
        }
        else if (stripTaskName.contains("mips64"))
        {
            stripToolName = "mips64el-linux-android-strip";
        }
        else if (stripTaskName.contains("mips"))
        {
            stripToolName = "mipsel-linux-android-strip";
        }
        else if (stripTaskName.contains("x86_64"))
        {
            stripToolName = "x86_64-linux-android-strip";
        }
        else if (stripTaskName.contains("x86"))
        {
            stripToolName = "i686-linux-android-strip";
        }
        else
        {
            throw new IllegalArgumentException("NOT SUPPORTED ARCHITECTURE NAME: ${stripTaskName}");
        }

        if (OperatingSystem.current().isWindows())
        {
            stripToolName += ".exe";
        }

        return stripToolName;
    }

    String getStripToolDirectory(String stripTaskName)
    {
        stripTaskName = stripTaskName.toLowerCase();
        def stripToolDirectory = ""
        if (stripTaskName.contains("arm64"))
        {
            stripToolDirectory = "aarch64-linux-android-4.9";
        }
        else if (stripTaskName.contains("arm"))
        {
            stripToolDirectory = "arm-linux-androideabi-4.9";
        }
        else if (stripTaskName.contains("mips64"))
        {
            stripToolDirectory = "mips64el-linux-android-4.9";
        }
        else if (stripTaskName.contains("mips"))
        {
            stripToolDirectory = "mipsel-linux-android-4.9";
        }
        else if (stripTaskName.contains("x86_64"))
        {
            stripToolDirectory = "x86_64-4.9";
        }
        else if (stripTaskName.contains("x86"))
        {
            stripToolDirectory = "x86-4.9";
        }
        else
        {
            throw new IllegalArgumentException("NOT SUPPORTED ARCHITECTURE: ${stripTaskName}");
        }

        return stripToolDirectory;
    }

    void afterExecute(Task task, TaskState taskState)
    {
        if (task.getName().contains("stripSymbols") && !taskState.failure)
        {
            println "Found STRIP COMMAND: ${task.getName()}"
            println "input file " + task.getInputs().getFiles().getAsPath();
            println "output dir " + task.getOutputs().getFiles().getAsPath();
            def _ndkDir = task.project.ext.ndkDir;

            def libName = new File(task.getInputs().getFiles().getAsPath()).getName();
            def libToStripPath = new File(task.getOutputs().getFiles().getAsPath(), libName).getAbsolutePath();

            println "output file ${libToStripPath}";

            def stripToolName = getStripToolName(task.getName());
            def machineName = getMachineName();
            def stripToolDirectory = getStripToolDirectory(task.getName());
            def s = File.separatorChar;
            def stripToolPath = "${_ndkDir}${s}toolchains${s}${stripToolDirectory}${s}prebuilt${s}${machineName}-x86_64${s}bin${s}${stripToolName}"

            println "Library to strip: ${libToStripPath}"
            println "Strip tool: ${stripToolPath}"

            def command = "";
            if (OperatingSystem.current().isWindows())
            {
                command =  "cmd /c ${stripToolPath} ${libToStripPath}";
            }
            else
            {
                command = "${stripToolPath} ${libToStripPath}";
            }

            println "Executing strip command: ${command}"
            def result = command.execute();
            println result.text;
        }
    }
}

if (!ndkDebuggable)
{
    project.gradle.addListener(new StripSymbolsTaskExecutionListener())
}


project.ext._buildToolsVersion = "25.0.2"

model {
    android {
        compileSdkVersion = 23
        buildToolsVersion = project.ext._buildToolsVersion

        defaultConfig.with {
            if(optimized) {
                project.archivesBaseName = "${archivesBaseName}-optimized"
            } else {
                project.archivesBaseName = "${archivesBaseName}-regular"
            }

            minSdkVersion.apiLevel = 17
            targetSdkVersion.apiLevel = 22
        }

        lintOptions.with {
            abortOnError = false
        }
    }

    android.ndk {
        moduleName = "NativeScript"

        cppFlags.addAll(["-I${file("src/main/jni")}".toString(),
                         "-I${file("src/main/jni/include")}".toString(),
                         "-I${file("src/main/jni/v8_inspector/")}".toString(),
                         //"-I${file("src/main/jni/v8_inspector/platform/inspector_protocol/")}".toString(),
                         //"-I${file("src/main/jni/v8_inspector/protocol/")}".toString(),
        ])

        CFlags.addAll(["-I${file("src/main/jni")}".toString(),
                       "-I${file("src/main/jni/include")}".toString(),
                       "-I${file("src/main/jni/v8_inspector")}".toString(),
                       //"-I${file("src/main/jni/v8_inspector/platform/inspector_protocol/")}".toString(),
                       //"-I${file("src/main/jni/v8_inspector/protocol/")}".toString(),
                       ])

        cppFlags.addAll(["-std=c++11", "-fexceptions", "-fno-builtin-stpcpy", "-DHAVE_INSPECTOR", "-D__ANDROID__"]) //, "-DV8_INSPECTOR_USE_STL=1", "-D__GXX_EXPERIMENTAL_CXX0X__=1"


        CFlags.addAll(["-Wno-error=format-security", "-g", "-fno-builtin-stpcpy"])

        ldLibs.addAll(["android", "dl", "log", "atomic", "z"])

        if(optimized) {
            ldFlags.addAll(["-Wl,--exclude-libs=ALL", "-Wl,--gc-sections"])
        }
        ldFlags.addAll(["-Wl,--allow-multiple-definition"])

        toolchain = "clang"
        stl = "c++_static"

        abiFilters.addAll(["armeabi-v7a", "x86"])

        if (System.getProperties()['idea.platform.prefix'] != null)
        {
            // Built from AndroidStudio
            println "Build from AndroidStudio"

            if (!ndkDebuggable)
            {
                abiFilters.addAll(["x86", "arm64-v8a"])

            }
        }
        else
        {
            // Built from command line
            abiFilters.addAll(["x86", "arm64-v8a"])

            println "Build from Command Line"
        }
    }

    android.sources {
        main {
            java {
                source {
                    srcDirs 'src/main/java'
                }
            }

            jni {
                source {
                    srcDirs 'src/main/jni'
                }

                exportedHeaders {
                    srcDir "src/main/jni/include"
                }

                dependencies {
                    library "v8" linkage "static"
                }
            }
        }
    }

    android.buildTypes {
        release {
            minifyEnabled = false
            proguardFiles.add(file('proguard-rules.txt'))

            ndk {
                debuggable = ndkDebuggable

                if (optimized) {
                    cppFlags.addAll(["-O3", "-fvisibility=hidden", "-ffunction-sections", "-fno-data-sections", "-Wl,--exclude-libs=ALL", "-Wl,--gc-sections"])
                    CFlags.addAll(["-O3", "-fvisibility=hidden", "-ffunction-sections", "-fno-data-sections", "-Wl,--exclude-libs=ALL", "--Wl,-gc-sections"])
                }
            }

            setRuntimeCommit.dependsOn(setPackageVersion)

            tasks.whenTaskAdded { task ->
                def taskName = task.getName()
                if (taskName == "androidRelease")
                {
                    task.dependsOn(setRuntimeCommit)
                    task.mustRunAfter setRuntimeCommit
                    task.finalizedBy revertVersionFile
                }
                if ((taskName == "bundleDebug") || (taskName == "bundleRelease")) {
                    task.finalizedBy createPackageConfigFileTask(taskName)
                }
//                else if (task.getName().contains("stripSymbols")
//                {
//
//                }
            }
        }
    }

    android.abis {
        create("armeabi-v7a") {
            abiFilters.add("armeabi-v7a")

            ldLibs.add("${file("src/main/libs/armeabi-v7a/libv8_base.a")}".toString())
            ldLibs.add("${file("src/main/libs/armeabi-v7a/libv8_libplatform.a")}".toString())
            ldLibs.add("${file("src/main/libs/armeabi-v7a/libv8_libbase.a")}".toString())
            ldLibs.add("${file("src/main/libs/armeabi-v7a/libv8_libsampler.a")}".toString())
            ldLibs.add("${file("src/main/libs/armeabi-v7a/libv8_nosnapshot.a")}".toString())
            ldLibs.add("${file("src/main/libs/armeabi-v7a/libinspector.a")}".toString())
            ldLibs.add("${file("src/main/libs/armeabi-v7a/libzip.a")}".toString())
        }

        create("x86") {
            abiFilters.add("x86")

            ldLibs.add("${file("src/main/libs/x86/libv8_base.a")}".toString())
            ldLibs.add("${file("src/main/libs/x86/libv8_libplatform.a")}".toString())
            ldLibs.add("${file("src/main/libs/x86/libv8_libbase.a")}".toString())
            ldLibs.add("${file("src/main/libs/x86/libv8_libsampler.a")}".toString())
            ldLibs.add("${file("src/main/libs/x86/libv8_nosnapshot.a")}".toString())
            ldLibs.add("${file("src/main/libs/x86/libinspector.a")}".toString())
            ldLibs.add("${file("src/main/libs/x86/libzip.a")}".toString())
        }

        create("arm64-v8a") {
            abiFilters.add("arm64-v8a")

            ldFlags.addAll([
                    "-L${file("src/main/libs/arm64-v8a")}".toString(),
                    "-lv8_base",
                    "-lv8_libplatform",
                    "-lv8_libbase",
                    "-lv8_libsampler",
                    "-lv8_nosnapshot",
                    "-linspector",
                    "-lzip"
            ])

            //The correct way of setting these flags is not working hence the workaround above
            //ldFlags.add("-L ${file("src/main/libs/arm64-v8a")}" -l v8_base".toString())
            //ldFlags.add("-L ${file("src/main/libs/arm64-v8a")}" -l v8_libplatform".toString())
            //ldFlags.add("-L ${file("src/main/libs/arm64-v8a")}" -l v8_libbase".toString())
            //ldFlags.add("-L ${file("src/main/libs/arm64-v8a")}" -l v8_nosnapshot".toString())
            //ldFlags.add("-L ${file("src/main/libs/arm64-v8a")}" -l zip".toString())

            //ldLibs.add("${file("src/main/libs/arm64-v8a/libv8_base.a")}".toString())
            //ldLibs.add("${file("src/main/libs/arm64-v8a/libv8_libplatform.a")}".toString())
            //ldLibs.add("${file("src/main/libs/arm64-v8a/libv8_libbase.a")}".toString())
            //ldLibs.add("${file("src/main/libs/arm64-v8a/libv8_nosnapshot.a")}".toString())
            //ldLibs.add("${file("src/main/libs/arm64-v8a/libzip.a")}".toString())
        }
    }

    repositories {
        prebuilt(PrebuiltLibraries) {
            v8 {
                headers.srcDir "src/main/jni/include"
                binaries.withType(StaticLibraryBinary) {
                    staticLibraryFile = file("src/main/libs/${targetPlatform.getName()}/libv8_base.a")
                    staticLibraryFile = file("src/main/libs/${targetPlatform.getName()}/libv8_libplatform.a")
                    staticLibraryFile = file("src/main/libs/${targetPlatform.getName()}/libv8_libbase.a")
                    staticLibraryFile = file("src/main/libs/${targetPlatform.getName()}/libv8_libsampler.a")
                    staticLibraryFile = file("src/main/libs/${targetPlatform.getName()}/libv8_nosnapshot.a")
                    staticLibraryFile = file("src/main/libs/${targetPlatform.getName()}/libzip.a")
                }
            }
        }
    }
}

if (project.hasProperty("embedBindingGenerator")) {
    dependencies {
        compile fileTree(dir: (project(':binding-generator').buildDir.toString() + "/libs"), include: ['*.jar'])
    }
} else {
    dependencies {
        compile project(':binding-generator')
    }
}

task setPackageVersion {
    onlyIf {
        project.hasProperty('packageVersion')
    }

    doFirst {
        println "Setting runtime version: '${packageVersion}'"

        def versionFile = "$rootDir/src/main/jni//Version.h"
        String contents = new File(versionFile).getText("UTF-8")
        contents = contents.replaceAll(/0.0.0.0/, packageVersion)
        new File(versionFile).write(contents, "UTF-8")
    }
}

task setRuntimeCommit {
    onlyIf {
        project.hasProperty('gitCommitVersion')
    }

    doFirst {
        println "Setting runtime commit: '${gitCommitVersion}'"

        def versionFile = "$rootDir/src/main/jni//Version.h"
        String contents = new File(versionFile).getText("UTF-8")
        contents = contents.replaceAll(/RUNTIME_COMMIT_SHA_PLACEHOLDER/, gitCommitVersion)
        new File(versionFile).write(contents, "UTF-8")
    }
}

//task stripArmBinary(type: Exec) {
//    onlyIf {
//        ndkDebuggable == false
//    }
//
//    doFirst {
//        def binaryPath = "$rootDir/build/intermediates/binaries/release/lib/armeabi-v7a/libNativeScript.so"
//        println "Striping ARM binary  ${binaryPath}"
//
//        if (isWinOs) {
//            commandLine "cmd", "/c", "git", "checkout", "--", versionFilePath
//        } else {
//            commandLine "git", "checkout", "--", versionFilePath
//        }
//
//    }
//}

task revertVersionFile(type: Exec) {

    onlyIf {
        project.hasProperty('packageVersion') || project.hasProperty('gitCommitVersion')
    }

    doFirst {
        def isWinOs = System.properties['os.name'].toLowerCase().contains('windows')
        def versionFileName = "./src/main/jni//Version.h"
        def versionFilePath = new File(versionFileName).getAbsolutePath()
        println "Reverting Version.h file: ${versionFilePath}"

        if (isWinOs) {
            commandLine "cmd", "/c", "git", "checkout", "--", versionFilePath
        } else {
            commandLine "git", "checkout", "--", versionFilePath
        }
    }
}

def createPackageConfigFileTask(taskName) {
    def mode = (taskName == "bundleDebug") ? "debug" : "release"

    return tasks.create(name: "packageConfigFileTaskFor${mode}",) {
        onlyIf {
            project.ext.sdkDir != null && !project.ext.sdkDir.isEmpty()
        }

        doFirst {
            def pathToAAR = "${buildDir}/outputs/aar/${project.archivesBaseName}-${mode}.aar"

            if (new File(pathToAAR).exists()) {
                def isWinOs = System.properties['os.name'].toLowerCase().contains('windows')

                def aaptCommand = new File(project.ext.sdkDir, "/build-tools/$project.ext._buildToolsVersion/aapt").getAbsolutePath()
                if (isWinOs) {
                    aaptCommand += ".exe"
                }

                def removeCmdParams = new ArrayList<String>([aaptCommand, "remove", pathToAAR, "config.json"])
                exec {
                    ignoreExitValue true
                    workingDir "$projectDir/src/main"
                    commandLine removeCmdParams.toArray()
                }

                def addCmdParams = new ArrayList<String>([aaptCommand, "add", pathToAAR, "config.json"])
                exec {
                    workingDir "$projectDir/src/main"
                    commandLine addCmdParams.toArray()
                }
            }
        }
    }
}